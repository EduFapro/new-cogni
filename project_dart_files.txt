=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\config\environment.dart ===


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\constants\audio_file_paths.dart ===
class AudioFilePaths {

  static String get hello_how_are_you => 'assets/task_prompts/audio_01.wav';
  static String get whats_your_name => 'assets/task_prompts/audio_02.wav';
  static String get whats_your_dob => 'assets/task_prompts/audio_03.wav';
  static String get whats_your_education_level => 'assets/task_prompts/audio_04.wav';
  static String get what_was_your_profession => 'assets/task_prompts/audio_05.wav';

  static String get who_do_you_live_with => 'assets/task_prompts/audio_06.wav';
  static String get do_you_exercise_frequently => 'assets/task_prompts/audio_07.wav';
  static String get do_you_read_frequently => 'assets/task_prompts/audio_08.wav';
  static String get do_you_play_puzzles_or_video_games_frequently => 'assets/task_prompts/audio_09.wav';
  static String get do_you_have_any_diseases => 'assets/task_prompts/audio_10.wav';

  static String get pay_close_attention => 'assets/task_prompts/audio_11.wav';
  static String get subtracting_3_and_again => 'assets/task_prompts/audio_12.wav';
  static String get what_year_are_we_in => 'assets/task_prompts/audio_13.wav';
  static String get what_month_are_we_in => 'assets/task_prompts/audio_14.wav';
  static String get what_day_of_the_month_is_it => 'assets/task_prompts/audio_15.wav';

  static String get what_day_of_the_week_is_it => 'assets/task_prompts/audio_16.wav';
  static String get how_old_are_you => 'assets/task_prompts/audio_17.wav';
  static String get where_are_we_now => 'assets/task_prompts/audio_18.wav';
  static String get current_president_of_brazil => 'assets/task_prompts/audio_19.wav';
  static String get former_president_of_brazil => 'assets/task_prompts/audio_20.wav';

  static String get repeat_words_after_listening_first_time => 'assets/task_prompts/audio_21.wav';
  static String get recall_words_from_list_first_time => 'assets/task_prompts/audio_22.wav';
  static String get repeat_words_after_listening_second_time => 'assets/task_prompts/audio_23.wav';
  static String get recall_words_from_list_second_time => 'assets/task_prompts/audio_24.wav';
  static String get repeat_words_after_listening_third_time => 'assets/task_prompts/audio_25.wav';

  static String get recall_words_from_list_third_time => 'assets/task_prompts/audio_26.wav';
  static String get what_did_you_do_yesterday => 'assets/task_prompts/audio_27.wav';
  static String get favorite_childhood_game => 'assets/task_prompts/audio_28.wav';
  static String get retell_words_heard_before => 'assets/task_prompts/audio_29.wav';
  static String get pay_close_attention_to_the_story => 'assets/task_prompts/audio_30.wav';

  static String get anas_cat_story => 'assets/task_prompts/audio_31.wav';
  static String get how_many_animals_can_you_think_of => 'assets/task_prompts/audio_32.wav';
  static String get words_starting_with_f => 'assets/task_prompts/audio_33.wav';
  static String get words_starting_with_a => 'assets/task_prompts/audio_34.wav';
  static String get words_starting_with_s => 'assets/task_prompts/audio_35.wav';

  static String get describe_what_you_see => 'assets/task_prompts/audio_36.wav';
  static String get retell_story => 'assets/task_prompts/audio_37.wav';
  static String get yes_or_no_questions => 'assets/task_prompts/audio_38.wav';
  static String get can_you_bathe_alone => 'assets/task_prompts/audio_39.wav';
  static String get can_you_dress_alone => 'assets/task_prompts/audio_40.wav';

  static String get can_you_use_toilet_alone => 'assets/task_prompts/audio_41.wav';
  static String get can_you_use_phone_alone => 'assets/task_prompts/audio_42.wav';
  static String get can_you_shop_alone => 'assets/task_prompts/audio_43.wav';
  static String get can_you_handle_money_alone => 'assets/task_prompts/audio_44.wav';
  static String get can_you_manage_medication_alone => 'assets/task_prompts/audio_45.wav';

  static String get can_you_use_transport_alone => 'assets/task_prompts/audio_46.wav';
  static String get feelings_in_past_two_weeks => 'assets/task_prompts/audio_47.wav';
  static String get feeling_sad_frequently => 'assets/task_prompts/audio_48.wav';
  static String get feeling_tired_or_lacking_energy => 'assets/task_prompts/audio_49.wav';
  static String get trouble_sleeping => 'assets/task_prompts/audio_50.wav';

  static String get preferring_to_stay_home => 'assets/task_prompts/audio_51.wav';
  static String get feeling_useless_or_guilty => 'assets/task_prompts/audio_52.wav';
  static String get lost_interest_in_activities => 'assets/task_prompts/audio_53.wav';
  static String get hopeful_about_future => 'assets/task_prompts/audio_54.wav';
  static String get feeling_life_is_worth_living => 'assets/task_prompts/audio_55.wav';
  static String get thanking_for_participation => 'assets/task_prompts/audio_56.wav';

  static String get audioPlaceholder => 'assets/audio/audio_placeholder.mp3';

  static String get aPressaEhInimiga => 'assets/test_prompts/a_pressa_eh_inimiga_da_perfeicao.mp3';
  static String get ehMelhorUmPassaro => 'assets/test_prompts/eh_melhor_um_passaro_na_mao.mp3';
  static String get nemTudoQueReluz => 'assets/test_prompts/nem_tudo_que_reluz_eh_ouro.mp3';

  static String get conteAte5 => 'assets/test_prompts/conte_ateh_5.mp3';
  static String get digaDoisAnimais => 'assets/test_prompts/diga_dois_animais_4_patas.mp3';
  static String get repitaAFrase => 'assets/test_prompts/repita_a_frase.mp3';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\constants\database_constants.dart ===
class DatabaseConfig {
  static const name = "cognivoice_db.db";
  static const version = 1;
}

class Tables {
  static const evaluators = "evaluators";
  static const participants = "participants";
  static const evaluations = "evaluations";
  static const modules = "modules";
  static const tasks = "tasks";
  static const evaluationModules = "evaluation_modules";
  static const taskInstances = "task_instances";
  static const moduleInstances = "module_instances";
  static const taskPrompts = "task_prompts";
  static const recordings = "recordings";
  static const currentUser = "current_user";
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\constants\enums\laterality_enums.dart ===
enum Laterality {
  rightHanded(1, "Right-handed"),
  leftHanded(2, "Left-handed"),
  ambidextrous(3, "Ambidextrous");

  final int numericValue;
  final String description;

  const Laterality(this.numericValue, this.description);

  static Laterality fromValue(int value) {
    return Laterality.values.firstWhere(
          (l) => l.numericValue == value,
      orElse: () => Laterality.rightHanded,
    );
  }

  static Laterality fromLabel(String label) {
    switch (label.toLowerCase()) {
      case 'destro':
        return Laterality.rightHanded;
      case 'canhoto':
        return Laterality.leftHanded;
      case 'ambidestro':
        return Laterality.ambidextrous;
      default:
        return Laterality.rightHanded;
    }
  }

  String get label {
    switch (this) {
      case Laterality.rightHanded:
        return 'Destro';
      case Laterality.leftHanded:
        return 'Canhoto';
      case Laterality.ambidextrous:
        return 'Ambidestro';
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\constants\enums\person_enums.dart ===
enum EducationLevel {
  incompleteElementary(1, "Incomplete Elementary"),
  completeElementary(2, "Complete Elementary"),
  incompleteHighSchool(3, "Incomplete High School"),
  completeHighSchool(4, "Complete High School"),
  incompleteCollege(5, "Incomplete College"),
  completeCollege(6, "Complete College"),
  postgraduate(7, "Postgraduate"),
  master(8, "Master's Degree"), // Optional
  doctorate(9, "Doctorate");    // Optional

  final int numericValue;
  final String description;

  const EducationLevel(this.numericValue, this.description);

  static EducationLevel fromValue(int value) {
    return EducationLevel.values.firstWhere(
          (level) => level.numericValue == value,
      orElse: () => EducationLevel.completeElementary,
    );
  }

  static EducationLevel fromLabel(String label) {
    switch (label.toLowerCase()) {
      case 'gradua√ß√£o':
        return EducationLevel.completeCollege;
      case 'mestrado':
        return EducationLevel.master;
      case 'doutorado':
        return EducationLevel.doctorate;
      default:
        return EducationLevel.completeElementary;
    }
  }

  String get label {
    switch (this) {
      case EducationLevel.master:
        return 'Mestrado';
      case EducationLevel.doctorate:
        return 'Doutorado';
      case EducationLevel.completeCollege:
        return 'Gradua√ß√£o';
      default:
        return description;
    }
  }
}

enum Sex {
  male(1, "Male"),
  female(2, "Female"),
  other(3, "Other");

  final int numericValue;
  final String description;

  const Sex(this.numericValue, this.description);

  static Sex fromValue(int value) {
    return Sex.values.firstWhere(
          (s) => s.numericValue == value,
      orElse: () => Sex.other,
    );
  }

  static Sex fromString(String str) {
    switch (str.toLowerCase()) {
      case 'male':
        return Sex.male;
      case 'female':
        return Sex.female;
      case 'other':
        return Sex.other;
      default:
        return Sex.other;
    }
  }

  static Sex fromLabel(String label) {
    switch (label.toLowerCase()) {
      case 'masculino':
        return Sex.male;
      case 'feminino':
        return Sex.female;
      case 'outro':
        return Sex.other;
      default:
        return Sex.other;
    }
  }

  String get label {
    switch (this) {
      case Sex.male:
        return 'Masculino';
      case Sex.female:
        return 'Feminino';
      case Sex.other:
        return 'Outro';
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\constants\enums\progress_status.dart ===
enum ProgressStatus {
  pending(1, "Pending"),
  inProgress(2, "In Progress"),
  completed(3, "Completed");

  final int numericValue;
  final String description;

  const ProgressStatus(this.numericValue, this.description);

  static ProgressStatus fromValue(int value) {
    return ProgressStatus.values.firstWhere(
          (s) => s.numericValue == value,
      orElse: () => ProgressStatus.pending,
    );
  }
}

/// Type aliases for semantic clarity
typedef EvaluationStatus = ProgressStatus;
typedef ModuleStatus = ProgressStatus;
typedef TaskStatus = ProgressStatus;

=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\constants\enums\task_mode.dart ===
enum TaskMode {
  play(0, "Play"),
  record(1, "Record");

  final int numericValue;
  final String description;

  const TaskMode(this.numericValue, this.description);

  static TaskMode fromValue(int value) {
    return TaskMode.values.firstWhere(
          (mode) => mode.numericValue == value,
      orElse: () => TaskMode.play,
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\database\base_database_helper.dart ===
import 'package:path/path.dart' as p;
import 'package:segundo_cogni/core/logger/app_logger.dart';
import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import 'package:meta/meta.dart';


abstract class BaseDatabaseHelper {
  BaseDatabaseHelper(this.dbName);

  final String dbName;
  Database? _db;

  int get dbVersion => 1;

  Future<void> onCreate(Database db, int version);
  Future<void> onUpgrade(Database db, int oldVersion, int newVersion) async {}

  Future<Database> get database async {
    if (_db != null && _db!.isOpen) {
      AppLogger.db('Database already initialized.');
      return _db!;
    }
    _db = await initDb();
    return _db!;
  }

  Future<Database> initDb() async {
    AppLogger.db('Initializing database: $dbName');

    final dbPath = await databaseFactory.getDatabasesPath();
    final path = p.join(dbPath, dbName);
    AppLogger.db('Database path resolved: $path');

    final db = await databaseFactory.openDatabase(
      path,
      options: OpenDatabaseOptions(
        version: dbVersion,
        onCreate: (db, version) async {
          AppLogger.db('Creating database schema.');
          await onCreate(db, version);
        },
        onUpgrade: (db, oldV, newV) async {
          AppLogger.db('Upgrading database from $oldV to $newV.');
          await onUpgrade(db, oldV, newV);
        },
      ),
    );

    AppLogger.db('Database opened successfully.');
    return db;
  }

  Future<void> close() async {
    if (_db != null) {
      await _db!.close();
      _db = null;
      AppLogger.db('Database closed and reset.');
    }
  }

  Future<void> deleteDb() async {
    final dbPath = await databaseFactory.getDatabasesPath();
    final path = p.join(dbPath, dbName);
    await databaseFactory.deleteDatabase(path);
    _db = null;
    AppLogger.db('Database deleted: $dbName');
  }

  @protected
  Database? get dbInstance => _db;

  @protected
  void setDbInstance(Database? db) {
    _db = db;
  }

}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\database\database_schema.dart ===
import 'package:sqflite_common/sqlite_api.dart';
import '../../features/evaluator/data/current_user_constants.dart';
import '../constants/database_constants.dart';
import 'package:segundo_cogni/core/logger/app_logger.dart';

// Import table scripts
import '../../features/evaluator/data/evaluator_constants.dart';
import '../../features/module/data/module_constants.dart';
import '../../features/module_instance/data/module_instance_constants.dart';
import '../../features/participant/data/participant_constants.dart';
import '../../features/evaluation/data/evaluation_constants.dart';
import '../../features/recording_file/data/recording_file_constants.dart';
import '../../features/task/data/task_constants.dart';
import '../../features/task_instance/data/task_instance_constants.dart';
import '../../features/task_prompt/data/task_prompt_constants.dart';

class DatabaseSchema {
  static final List<String> _createScripts = [
    scriptCreateTableEvaluators,
    scriptCreateTableParticipants,
    scriptCreateTableModules,
    scriptCreateTableTasks,
    scriptCreateTableEvaluations,
    scriptCreateTableTaskPrompts,
    scriptCreateTableCurrentUser,
    scriptCreateTableModuleInstances,
    scriptCreateTableTaskInstances,
    scriptCreateTableRecordings,
  ];


  static final List<String> _tableNames = [
    Tables.evaluators,         // 0
    Tables.participants,       // 1
    Tables.modules,            // 2
    Tables.tasks,              // 3
    Tables.evaluations,        // 4
    Tables.taskPrompts,        // 5
    Tables.currentUser,        // 6
    Tables.moduleInstances,    // 7
    Tables.taskInstances,      // 8
    Tables.recordings          // 9


  ];


  /// Creates all tables and verifies that they were created successfully.
  static Future<void> createAll(Database db) async {
    for (int i = 0; i < _createScripts.length; i++) {
      final tableName = _tableNames[i];
      final script = _createScripts[i];

      AppLogger.db('üìÑ Creating table: $tableName...');
      AppLogger.db('üìù Script:\n$script');

      try {
        await db.execute(script);
        AppLogger.db('‚úÖ Created table: $tableName');
      } catch (e, stack) {
        AppLogger.error('‚ö†Ô∏è Failed to create table "$tableName"', e, stack);
      }
    }

    AppLogger.db('üîç Verifying schema...');
    await _verifySchema(db);
  }


  /// Drops all tables (for upgrades or tests).
  static Future<void> dropAll(Database db) async {
    for (final name in _tableNames.reversed) {
      try {
        await db.execute('DROP TABLE IF EXISTS $name');
        AppLogger.db('üóëÔ∏è Dropped table: $name');
      } catch (e) {
        AppLogger.db('‚ö†Ô∏è Failed to drop $name: $e');
      }
    }
  }

  /// Confirms that all expected tables exist in the DB.
  static Future<void> _verifySchema(Database db) async {
    final result = await db.rawQuery(
      "SELECT name FROM sqlite_master WHERE type='table';",
    );
    final existing = result.map((e) => e['name']).toSet();

    for (final expected in _tableNames) {
      if (existing.contains(expected)) {
        AppLogger.db('‚úÖ Verified: $expected');
      } else {
        AppLogger.error('‚ùå Missing table: $expected');
      }
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\database\prod_database_helper.dart ===
import 'package:sqflite_common/sqlite_api.dart';
import 'package:segundo_cogni/core/database/base_database_helper.dart';
import 'package:segundo_cogni/core/database/database_schema.dart';
import 'package:segundo_cogni/core/logger/app_logger.dart';

class ProdDatabaseHelper extends BaseDatabaseHelper {
  ProdDatabaseHelper._() : super('cognivoice_db.db');

  static final ProdDatabaseHelper instance = ProdDatabaseHelper._();

  @override
  Future<void> onCreate(Database db, int version) async {
    AppLogger.db('Creating production schema...');
    await DatabaseSchema.createAll(db);
  }

  @override
  Future<void> onUpgrade(Database db, int oldVersion, int newVersion) async {
    AppLogger.db('Upgrading DB $oldVersion ‚Üí $newVersion');
    await DatabaseSchema.dropAll(db);
    await DatabaseSchema.createAll(db);
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\database\test_database_helper.dart ===
import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import 'package:segundo_cogni/core/database/base_database_helper.dart';
import 'package:segundo_cogni/core/database/database_schema.dart';
import 'package:segundo_cogni/core/logger/app_logger.dart';

class TestDatabaseHelper extends BaseDatabaseHelper {
  TestDatabaseHelper._() : super('test_cognivoice_db.db');

  static final TestDatabaseHelper instance = TestDatabaseHelper._();

  @override
  Future<Database> initDb() async {
    if (dbInstance != null && dbInstance!.isOpen) {
      AppLogger.db('‚úÖ Test DB already initialized.');
      return dbInstance!;
    }

    sqfliteFfiInit();
    databaseFactory = databaseFactoryFfi;

    AppLogger.db('üõ†Ô∏è Creating in-memory test database...');

    final db = await databaseFactory.openDatabase(
      inMemoryDatabasePath,
      options: OpenDatabaseOptions(
        version: dbVersion,
        onCreate: (db, version) async {
          AppLogger.db('üì¶ Creating test schema...');
          await onCreate(db, version);
        },
        onUpgrade: (db, oldV, newV) async {
          AppLogger.db('üîÑ Upgrading test DB $oldV ‚Üí $newV (recreating schema)');
          await onUpgrade(db, oldV, newV);
        },
      ),
    );

    // Use protected setter to store the opened DB
    setDbInstance(db);

    return db;
  }

  @override
  Future<void> onCreate(Database db, int version) async {
    await DatabaseSchema.createAll(db);
  }
  static Future<void> delete() async {
    if (instance.dbInstance != null && instance.dbInstance!.isOpen) {
      await instance.dbInstance!.close();
      instance.setDbInstance(null);
      AppLogger.db('üßπ In-memory test DB reset.');
    }
  }

  @override
  Future<void> onUpgrade(Database db, int oldVersion, int newVersion) async {
    await DatabaseSchema.dropAll(db);
    await DatabaseSchema.createAll(db);
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\environment.dart ===
enum AppEnv {
  local,
  remote,
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\logger\app_logger.dart ===
import 'package:flutter/foundation.dart';
import 'package:logger/logger.dart';

class AppLogger {
  static final bool _isRelease = kReleaseMode;

  static final Logger _logger = Logger(
    printer: PrettyPrinter(
      methodCount: 2,
      errorMethodCount: 5,
      lineLength: 100,
      colors: true,
      printEmojis: true,
      printTime: true,
    ),
  );

  static void info(String message) {
    if (_isRelease) return;
    _logger.i(message);
  }

  static void debug(String message) {
    if (_isRelease) return;
    _logger.d(message);
  }

  static void warning(String message) {
    if (_isRelease) return;
    _logger.w(message);
  }

  static void error(String message, [dynamic error, StackTrace? stack]) {
    if (_isRelease) return;
    _logger.e(
      message,
      error: error,
      stackTrace: stack,
    );
  }

  static void db(String message) {
    if (_isRelease) return;
    _logger.d('[DB] $message');
  }

  static void nav(String message) {
    if (_isRelease) return;
    _logger.i('[NAV] $message');
  }

  static void trace(String message) {
    if (_isRelease) return;
    _logger.t(message);
  }

  static void seed(String message) {
    if (_isRelease) return;
    _logger.i('[SEED] $message');
  }

}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\logger\app_logger_cli.dart ===
class AppLoggerCli {
  static void info(String message) => print('[INFO] $message');
  static void debug(String message) => print('[DEBUG] $message');
  static void warning(String message) => print('[WARNING] $message');

  static void error(String message, [dynamic error, StackTrace? stack]) {
    print('[ERROR] $message');
    if (error != null) print('Exception: $error');
    if (stack != null) print(stack);
  }

  static void seed(String message) => print('[SEED] $message');
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\network.dart ===
import 'dart:convert';

import 'package:http/http.dart' as http;

import 'logger/app_logger.dart';

class NetworkService {
  final String baseUrl = 'https://api.example.com';

  Future<http.Response> get(String endpoint) async {
    final url = Uri.parse('$baseUrl$endpoint');
    AppLogger.info('HTTP GET ‚Üí $url');

    try {
      final response = await http.get(url);
      AppLogger.info('HTTP ${response.statusCode} ‚Üê $url');
      if (response.statusCode >= 400) {
        AppLogger.warning('HTTP error ${response.statusCode}: ${response.body}');
      }
      return response;
    } catch (e, s) {
      AppLogger.error('HTTP GET failed for $url', e, s);
      rethrow;
    }
  }

  Future<http.Response> post(String endpoint, Map<String, dynamic> body) async {
    final url = Uri.parse('$baseUrl$endpoint');
    AppLogger.info('HTTP POST ‚Üí $url body=$body');

    try {
      final response = await http.post(url,
          headers: {'Content-Type': 'application/json'},
          body: jsonEncode(body));
      AppLogger.info('HTTP ${response.statusCode} ‚Üê $url');
      if (response.statusCode >= 400) {
        AppLogger.warning('HTTP error ${response.statusCode}: ${response.body}');
      }
      return response;
    } catch (e, s) {
      AppLogger.error('HTTP POST failed for $url', e, s);
      rethrow;
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\router.dart ===
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';

import '../features/auth/presentation/login_screen.dart';
import '../features/evaluator/presentation/evaluator_registration_screen.dart';
import '../features/home/home_screen.dart';
import '../features/splash/splash_screen.dart';
import 'logger/app_logger.dart';

final router = GoRouter(
  initialLocation: '/',
  observers: [
    LoggingNavigatorObserver(),
  ],
  routes: [
    GoRoute(
      path: '/',
      name: 'splash',
      builder: (BuildContext context, GoRouterState state) =>
      const SplashScreen(),
    ),
    GoRoute(
      path: '/login',
      name: 'login',
      builder: (BuildContext context, GoRouterState state) =>
      const LoginScreen(),
    ),
    GoRoute(
      path: '/home',
      name: 'home',
      builder: (BuildContext context, GoRouterState state) =>
      const HomeScreen(),
    ),
    GoRoute(
      path: '/register',
      name: 'evaluator_registration',
      builder: (context, state) => const EvaluatorRegistrationScreen(),
    ),
  ],
);

class LoggingNavigatorObserver extends NavigatorObserver {
  @override
  void didPush(Route route, Route? previousRoute) {
    AppLogger.nav('PUSHED: ${route.settings.name}');
  }

  @override
  void didPop(Route route, Route? previousRoute) {
    AppLogger.nav('POPPED: ${route.settings.name}');
  }

  @override
  void didReplace({Route? newRoute, Route? oldRoute}) {
    AppLogger.nav(
        'REPLACED: ${oldRoute?.settings.name} ‚Üí ${newRoute?.settings.name}');
  }

  @override
  void didRemove(Route route, Route? previousRoute) {
    AppLogger.nav('REMOVED: ${route.settings.name}');
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\theme\app_colors.dart ===
import 'package:flutter/material.dart';

class AppColors {
  // Y2K Palette (already defined)
  static const Color lightCyan = Color(0xFFB3DDE5);
  static const Color aquaBlue = Color(0xFF02D3D2);
  static const Color chromeBlue = Color(0xFF4073A0);
  static const Color skyBlue = Color(0xFF7AC9F2);
  static const Color mistTeal = Color(0xFF5F9C9D);

  static const List<Color> y2kPalette = [
    lightCyan,
    aquaBlue,
    chromeBlue,
    skyBlue,
    mistTeal,
  ];

  // Neutrals
  static const Color pureWhite = Color(0xFFFFFFFF);
  static const Color softWhite = Color(0xFFF5F5F5);
  static const Color coolGray100 = Color(0xFFE5E7EB);
  static const Color coolGray500 = Color(0xFF6B7280);
  static const Color coolGray900 = Color(0xFF111827);
  static const Color trueBlack = Color(0xFF000000);

  // FluentUI Base
  static const Color primary = Color(0xFF0063B1); // azul Microsoft
  static const Color secondary = Color(0xFF107C10); // verde
  static const Color accent = Color(0xFFB4009E); // roxo
  static const Color neutralLight = Color(0xFFF3F2F1);
  static const Color neutralDark = Color(0xFF201F1E);

  // === New Dark Blue Shades ===
  static const Color midnightBlue = Color(0xFF0D1B2A);   // Very dark navy
  static const Color deepSeaBlue = Color(0xFF1B263B);    // Muted deep blue
  static const Color steelBlue = Color(0xFF2C3E50);      // Grayish blue
  static const Color indigoBlue = Color(0xFF283593);     // Rich indigo
  static const Color navyBlue = Color(0xFF001F54);       // Classic navy
  static const Color darkCyanBlue = Color(0xFF0A3D62);   // Cyan-tinted navy

  static const List<Color> darkBluePalette = [
    midnightBlue,
    deepSeaBlue,
    steelBlue,
    indigoBlue,
    navyBlue,
    darkCyanBlue,
  ];
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\theme\app_theme.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import 'app_colors.dart';

class AppTheme {
  static final AccentColor accent = AccentColor.swatch({
    'darkest': AppColors.chromeBlue,
    'darker': AppColors.primary,
    'dark': AppColors.skyBlue,
    'normal': AppColors.skyBlue,
    'light': AppColors.aquaBlue,
    'lighter': AppColors.lightCyan,
    'lightest': AppColors.softWhite,
    'secondary': AppColors.mistTeal,
    'tertiary': AppColors.accent,
    'transparent': const Color(0x00000000),
  });

  /// Light mode Fluent theme
  static final FluentThemeData light = FluentThemeData(
    brightness: Brightness.light,
    accentColor: accent,
    scaffoldBackgroundColor: AppColors.softWhite,
    cardColor: AppColors.pureWhite,
    menuColor: AppColors.lightCyan,
  );

  /// Dark mode Fluent theme
  static final FluentThemeData dark = FluentThemeData(
    brightness: Brightness.dark,
    accentColor: accent,
    scaffoldBackgroundColor: AppColors.coolGray900,
    cardColor: AppColors.coolGray500,
    menuColor: AppColors.neutralDark,
  );
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\utils\error_parser.dart ===
String parseLoginError(dynamic error) {
  final errStr = error.toString();

  if (errStr.contains('no such table: current_user')) {
    return 'Erro interno: tabela de usu√°rio n√£o encontrada. Tente reinstalar o app.';
  }

  if (errStr.contains('no column named')) {
    return 'Erro no banco de dados. Contate o suporte t√©cnico.';
  }

  if (errStr.contains('DatabaseException')) {
    return 'Erro ao acessar o banco de dados. Tente novamente.';
  }

  if (errStr.contains('Credenciais inv√°lidas')) {
    return 'E-mail ou senha incorretos.';
  }

  if (errStr.contains('Exception:')) {
    return errStr.replaceFirst('Exception:', '').trim();
  }

  // Default fallback
  return 'Erro inesperado. Verifique sua conex√£o ou tente novamente.';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\utils\file_helper.dart ===
import 'dart:io';
import 'package:excel/excel.dart';
import 'package:path_provider/path_provider.dart';
import 'package:flutter/foundation.dart';
import '../../features/participant/domain/participant_with_evaluation.dart';

Future<void> exportParticipantsToExcel(List<ParticipantWithEvaluation> list) async {
  final excel = Excel.createExcel();
  final sheet = excel['Pacientes'];

  // Header
  sheet.appendRow([
    TextCellValue('Nome'),
    TextCellValue('Status'),
    TextCellValue('Data da Avalia√ß√£o'),
  ]);

  // Rows
  for (final p in list) {
    sheet.appendRow([
      TextCellValue(p.fullName),
      TextCellValue(p.statusLabel),
      TextCellValue(p.evaluationDateFormatted),
    ]);
  }

  final directory = await getApplicationDocumentsDirectory();
  final filePath = '${directory.path}/pacientes_exportados.xlsx';

  final fileBytes = excel.encode();
  if (fileBytes == null) return;

  final file = File(filePath)..createSync(recursive: true);
  await file.writeAsBytes(fileBytes);

  debugPrint('üìÅ Exported to $filePath');
}

Future<void> exportSingleParticipantToExcel(ParticipantWithEvaluation participant) async {
  final excel = Excel.createExcel();
  final sheet = excel['Participante'];

  sheet.appendRow([
    TextCellValue('Nome'),
    TextCellValue('Status'),
    TextCellValue('Data da Avalia√ß√£o'),
  ]);

  sheet.appendRow([
    TextCellValue(participant.fullName),
    TextCellValue(participant.statusLabel),
    TextCellValue(participant.evaluationDateFormatted),
  ]);

  final directory = await getApplicationDocumentsDirectory();
  final filePath = '${directory.path}/participante_${participant.fullName}.xlsx';

  final fileBytes = excel.encode();
  if (fileBytes == null) return;

  final file = File(filePath)..createSync(recursive: true);
  await file.writeAsBytes(fileBytes);

  debugPrint('üìÅ Exported single participant to $filePath');
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\utils\validation_helper.dart ===
class ValidationHelper {
  static bool isValidEmail(String email) {
    final regex = RegExp(r'^[\w\.-]+@[\w\.-]+\.\w+$');
    return regex.hasMatch(email);
  }

  static bool isValidPassword(String password) {
    return password.length >= 8;
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\fake_seed.dart ===
import 'dart:io';
import 'dart:math';

import 'package:segundo_cogni/shared/encryption/deterministic_encryption_helper.dart';

import 'package:segundo_cogni/core/constants/database_constants.dart';
import 'package:segundo_cogni/core/constants/enums/task_mode.dart';
import 'package:segundo_cogni/features/evaluation/data/evaluation_constants.dart';
import 'package:segundo_cogni/features/evaluator/data/evaluator_constants.dart';
import 'package:segundo_cogni/features/module_instance/data/module_instance_constants.dart';
import 'package:segundo_cogni/features/participant/data/participant_constants.dart';
import 'package:segundo_cogni/features/recording_file/data/recording_file_constants.dart';
import 'package:segundo_cogni/features/task/domain/task_entity.dart';
import 'package:segundo_cogni/features/task_instance/data/task_instance_constants.dart';
import 'package:segundo_cogni/seeders/modules/modules_seeds.dart';
import 'package:segundo_cogni/seeders/tasks/task_seeds.dart';

void main() {
  // Output files
  final sqlFile = File('lib/fake_prod_seed_encrypted.sql');
  final credentialsFile = File('lib/evaluator_credentials.txt');

  final buffer = StringBuffer();
  final credentialsBuffer = StringBuffer();

  final random = Random(42); // deterministic
  final now = DateTime.now();

  credentialsBuffer.writeln('--- Evaluator Credentials (Generated) ---');
  credentialsBuffer.writeln('Generated at: ${now.toIso8601String()}');
  credentialsBuffer.writeln('-----------------------------------');

  // Group tasks by moduleID, using your seeds.
  final Map<int, List<TaskEntity>> tasksByModule = {};
  for (final t in tasksList) {
    tasksByModule.putIfAbsent(t.moduleID, () => []).add(t);
  }

  // ID counters
  // Start Evaluator ID from 2 as requested (ID 1 is reserved/already inserted)
  var nextEvaluatorId = 2;
  var nextParticipantId = 1;
  var nextEvaluationId = 1;
  var nextModuleInstanceId = 1;
  var nextTaskInstanceId = 1;
  var nextRecordingId = 1;

  // Some name pools for fake data.
  final firstNames = <String>[
    'Ana',
    'Bruno',
    'Carla',
    'Diego',
    'Eduarda',
    'Felipe',
    'Gabriela',
    'Henrique',
    'Isabela',
    'Jo√£o',
    'Karen',
    'Lucas',
    'Marina',
    'Nicolas',
    'Ot√°vio',
    'Patr√≠cia',
    'Rafael',
    'Sara',
  ];

  final lastNames = <String>[
    'Silva',
    'Pereira',
    'Souza',
    'Oliveira',
    'Almeida',
    'Costa',
    'Lima',
    'Gomes',
  ];

  // Small helper for random picks.
  String pick(List<String> list, Random r) => list[r.nextInt(list.length)];

  // Start of SQL file.
  // NOTE: Removed comments to ensure compatibility with sqflite execution if needed.
  buffer.writeln('BEGIN TRANSACTION;');
  buffer.writeln();

  // ------------------------------------------------------------
  // EVALUATORS
  // ------------------------------------------------------------

  for (var e = 0; e < 10; e++) {
    final id = nextEvaluatorId++;
    final name = pick(firstNames, random);
    final surname = pick(lastNames, random);
    final email =
        '${name.toLowerCase()}.${surname.toLowerCase()}$id@example.com';
    final username = '${name[0].toLowerCase()}${surname.toLowerCase()}$id';
    final passwordPlain = '0000';

    final birthDate = _formatDate(
      DateTime(
        1970 + random.nextInt(25), // 1970‚Äì1994
        1 + random.nextInt(12),
        1 + random.nextInt(28),
      ),
    );

    final specialtyOptions = <String>[
      'Geriatria',
      'Neurologia',
      'Psiquiatria',
      'Neuropsicologia',
      'Fonoaudiologia',
    ];
    final specialty = pick(specialtyOptions, random);
    final cpf = '000000000$id';

    // ID 1 is usually admin, but we are starting from 2.
    // Let's make the first generated one (ID 2) NOT admin, or random.
    // The prompt implied ID 1 exists. We'll set these to 0 (not admin) for safety,
    // or maybe make one of them admin? Let's stick to 0 for generated ones.
    final isAdmin = 0;

    // --- Credentials Log ---
    credentialsBuffer.writeln('ID: $id | Name: $name $surname');
    credentialsBuffer.writeln('Email: $email');
    credentialsBuffer.writeln('Password: $passwordPlain');
    credentialsBuffer.writeln('-----------------------------------');

    // --- Encryption ---
    final encName = DeterministicEncryptionHelper.encryptText(name);
    final encSurname = DeterministicEncryptionHelper.encryptText(surname);
    final encEmail = DeterministicEncryptionHelper.encryptText(email);
    final encBirthDate = DeterministicEncryptionHelper.encryptText(birthDate);
    final encSpecialty = DeterministicEncryptionHelper.encryptText(specialty);
    final encCpf = DeterministicEncryptionHelper.encryptText(cpf);
    final encUsername = DeterministicEncryptionHelper.encryptText(username);
    final hashedPassword = DeterministicEncryptionHelper.hashPassword(passwordPlain);

    buffer.writeln(
      'INSERT INTO ${Tables.evaluators} ('
      '${EvaluatorFields.id}, '
      '${EvaluatorFields.name}, '
      '${EvaluatorFields.surname}, '
      '${EvaluatorFields.email}, '
      '${EvaluatorFields.birthDate}, '
      '${EvaluatorFields.specialty}, '
      '${EvaluatorFields.cpf}, '
      '${EvaluatorFields.username}, '
      '${EvaluatorFields.password}, '
      '${EvaluatorFields.firstLogin}, '
      '${EvaluatorFields.isAdmin}'
      ') VALUES ('
      '$id, '
      '${_q(encName)}, '
      '${_q(encSurname)}, '
      '${_q(encEmail)}, '
      '${_q(encBirthDate)}, '
      '${_q(encSpecialty)}, '
      '${_q(encCpf)}, '
      '${_q(encUsername)}, '
      '${_q(hashedPassword)}, '
      '0, ' // first_login = false
      '$isAdmin'
      ');',
    );
  }

  buffer.writeln();
  // ------------------------------------------------------------
  // PARTICIPANTS + EVALUATIONS + MODULE_INSTANCES + TASK_INSTANCES + RECORDINGS
  // ------------------------------------------------------------

  // Reset evaluator ID to 2 to assign participants
  var currentEvaluatorId = 2;

  for (var e = 0; e < 10; e++) {
    final evaluatorId = currentEvaluatorId++;

    // 8‚Äì12 participants per evaluator
    final participantCount = 8 + random.nextInt(5);

    for (var p = 0; p < participantCount; p++) {
      final participantId = nextParticipantId++;
      final evalId = nextEvaluationId++;

      final pName = pick(firstNames, random);
      final pSurname = pick(lastNames, random);

      final birthDate = _formatDate(
        DateTime(
          1940 + random.nextInt(45), // 1940‚Äì1984
          1 + random.nextInt(12),
          1 + random.nextInt(28),
        ),
      );

      final educationLevel = 1 + random.nextInt(5); // 1..5
      final sex = 1 + random.nextInt(2); // 1..2
      final laterality = 1 + random.nextInt(2); // 1..2

      // --- Encryption for Participant ---
      final encPName = DeterministicEncryptionHelper.encryptText(pName);
      final encPSurname = DeterministicEncryptionHelper.encryptText(pSurname);
      // birthDate is NOT encrypted for participants in the original schema/logic

      // Insert participant
      buffer.writeln(
        'INSERT INTO ${Tables.participants} ('
        '${ParticipantFields.id}, '
        '${ParticipantFields.name}, '
        '${ParticipantFields.surname}, '
        '${ParticipantFields.educationLevel}, '
        '${ParticipantFields.sex}, '
        '${ParticipantFields.birthDate}, '
        '${ParticipantFields.laterality}'
        ') VALUES ('
        '$participantId, '
        '${_q(encPName)}, '
        '${_q(encPSurname)}, '
        '$educationLevel, '
        '$sex, '
        '${_q(birthDate)}, '
        '$laterality'
        ');',
      );

      // Evaluation date in the last ~120 days
      final daysBack = random.nextInt(120);
      final baseDate = now.subtract(Duration(days: daysBack));
      final evalDate = DateTime(
        baseDate.year,
        baseDate.month,
        baseDate.day,
        8 + random.nextInt(9), // 8h‚Äì16h
        random.nextInt(60),
        0,
      );
      final evalDateStr = _formatDateTime(evalDate);

      // evaluation status: mostly completed (3), some in-progress (2) or planned (1)
      final evalStatus = _randomStatus123(random);
      // language: 1 or 2
      final language = 1 + random.nextInt(2);

      // Insert evaluation
      buffer.writeln(
        'INSERT INTO ${Tables.evaluations} ('
        '${EvaluationFields.id}, '
        '${EvaluationFields.date}, '
        '${EvaluationFields.evaluatorId}, '
        '${EvaluationFields.participantId}, '
        '${EvaluationFields.status}, '
        '${EvaluationFields.language}'
        ') VALUES ('
        '$evalId, '
        '${_q(evalDateStr)}, '
        '$evaluatorId, '
        '$participantId, '
        '$evalStatus, '
        '$language'
        ');',
      );

      // For this evaluation, create module_instances for all modules in modulesList.
      for (final module in modulesList) {
        final moduleInstId = nextModuleInstanceId++;

        final moduleStatus = _randomStatus123(random);

        buffer.writeln(
          'INSERT INTO ${Tables.moduleInstances} ('
          '${ModuleInstanceFields.id}, '
          '${ModuleInstanceFields.moduleId}, '
          '${ModuleInstanceFields.evaluationId}, '
          '${ModuleInstanceFields.status}'
          ') VALUES ('
          '$moduleInstId, '
          '${module.moduleID}, '
          '$evalId, '
          '$moduleStatus'
          ');',
        );

        // Tasks for this module
        final moduleTasks = tasksByModule[module.moduleID] ?? const [];

        for (final task in moduleTasks) {
          final taskInstId = nextTaskInstanceId++;

          final taskStatus = _randomTaskStatus(random); // 0 or 1
          final completingSeconds = _randomCompletingTime(
            random,
            task.taskMode,
          );
          final completingStr = completingSeconds.toString();

          buffer.writeln(
            'INSERT INTO ${Tables.taskInstances} ('
            '${TaskInstanceFields.id}, '
            '${TaskInstanceFields.taskId}, '
            '${TaskInstanceFields.moduleInstanceId}, '
            '${TaskInstanceFields.status}, '
            '${TaskInstanceFields.completingTime}'
            ') VALUES ('
            '$taskInstId, '
            '${task.taskID}, '
            '$moduleInstId, '
            '$taskStatus, '
            '${_q(completingStr)}'
            ');',
          );

          // Dummy recording for this task_instance
          final recordingId = nextRecordingId++;
          final path =
              'recordings/eval_${evalId}_mod_${module.moduleID}_task_$taskInstId.wav';

          buffer.writeln(
            'INSERT INTO ${Tables.recordings} ('
            '${RecordingFileFields.id}, '
            '${RecordingFileFields.taskInstanceId}, '
            '${RecordingFileFields.filePath}'
            ') VALUES ('
            '$recordingId, '
            '$taskInstId, '
            '${_q(path)}'
            ');',
          );
        }
      }
    }
  }

  buffer.writeln('COMMIT;');

  sqlFile.writeAsStringSync(buffer.toString());
  credentialsFile.writeAsStringSync(credentialsBuffer.toString());

  // ignore: avoid_print
  print('‚úÖ Generated ${sqlFile.path} with encrypted data.');
  print('üîë Generated ${credentialsFile.path} with credentials.');
}

// ----------------------------------------------------------------------
// Helpers
// ----------------------------------------------------------------------

String _q(String s) {
  // SQL single-quote escape: ' -> ''
  final escaped = s.replaceAll("'", "''");
  return "'$escaped'";
}

String _formatDate(DateTime dt) =>
    '${dt.year.toString().padLeft(4, '0')}-'
    '${dt.month.toString().padLeft(2, '0')}-'
    '${dt.day.toString().padLeft(2, '0')}';

String _formatDateTime(DateTime dt) =>
    '${_formatDate(dt)} '
    '${dt.hour.toString().padLeft(2, '0')}:'
    '${dt.minute.toString().padLeft(2, '0')}:'
    '${dt.second.toString().padLeft(2, '0')}';

int _randomStatus123(Random r) {
  final roll = r.nextInt(100);
  if (roll < 10) return 1; // ~10% status 1
  if (roll < 30) return 2; // ~20% status 2
  return 3; // ~70% status 3
}

int _randomTaskStatus(Random r) {
  // 80% completed(1), 20% not completed(0)
  return r.nextInt(100) < 80 ? 1 : 0;
}

int _randomCompletingTime(Random r, TaskMode mode) {
  // For record tasks: 20‚Äì300s
  // For play tasks: 5‚Äì60s, mostly short
  if (mode == TaskMode.record) {
    return 20 + r.nextInt(280);
  } else {
    return 5 + r.nextInt(55);
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\auth\application\login_notifier.dart ===
import 'package:hooks_riverpod/hooks_riverpod.dart';
import '../../../core/logger/app_logger.dart';
import '../../../core/utils/error_parser.dart';
import '../../../providers/auth_providers.dart'; // ‚úÖ Restored import
import '../../../providers/evaluator_providers.dart'; // ‚úÖ Required import
import '../../evaluator/presentation/providers/evaluator_provider.dart'; // ‚úÖ Required import

class LoginNotifier extends AsyncNotifier<bool> {
  @override
  Future<bool> build() async {
    return false;
  }

  Future<void> login(String email, String password) async {
    state = const AsyncLoading();
    AppLogger.info('Login attempt started for $email');

    if (email.isEmpty || password.isEmpty) {
      state = AsyncError('E-mail e senha s√£o obrigat√≥rios', StackTrace.current);
      return;
    }

    try {
      final repo = await ref.read(authRepositoryProvider.future);
      final user = await repo.login(email, password);

      if (user == null) {
        state = AsyncError('Credenciais inv√°lidas', StackTrace.current);
      } else {
        await repo.saveCurrentUserToDB(user);
        ref
            .read(currentUserProvider.notifier)
            .setUser(user); // ‚úÖ Update in-memory state
        ref.invalidate(currentEvaluatorProvider); // ‚úÖ Now this works
        state = const AsyncData(true);
      }
    } catch (e, st) {
      AppLogger.error('Login exception', e, st);
      final userFriendly = parseLoginError(e);
      state = AsyncError(userFriendly, st);
    } finally {
      AppLogger.info('Login attempt finished for $email');
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\auth\data\auth_local_datasource.dart ===
import 'package:sqflite_common/sqlite_api.dart';
import '../../../core/constants/database_constants.dart';
import '../../../core/logger/app_logger.dart';
import '../../../shared/encryption/deterministic_encryption_helper.dart';
import '../../evaluator/application/evaluator_secure_service.dart';
import '../../evaluator/data/evaluator_model.dart';
import '../../evaluator/data/evaluator_constants.dart';

class AuthLocalDataSource {
  final Database _db;
  AuthLocalDataSource(this._db);
  Future<EvaluatorModel?> getEvaluatorByEmail(String email) async {
    final encryptedEmail = DeterministicEncryptionHelper.encryptText(email);
    AppLogger.debug('Looking up evaluator: $email (encrypted: $encryptedEmail)');

    final result = await _db.query(
      Tables.evaluators,
      where: '${EvaluatorFields.email} = ?',
      whereArgs: [encryptedEmail],
      limit: 1,
    );

    if (result.isEmpty) {
      AppLogger.db('No evaluator found for $email');
      return null;
    }

    AppLogger.db('Evaluator found for $email');
    return EvaluatorModel.fromMap(result.first);
  }


  Future<void> clearCurrentUser() async {
    AppLogger.db('Clearing current user from DB');
    await _db.delete('current_user');
  }

  Future<EvaluatorModel?> getCachedUser() async {
    AppLogger.db('Fetching cached user from DB');
    final result = await _db.query('current_user', limit: 1);
    if (result.isEmpty) return null;

    final encrypted = EvaluatorModel.fromMap(result.first);
    return EvaluatorSecureService.decrypt(encrypted);
  }

  Future<void> saveCurrentUser(EvaluatorModel user) async {
    AppLogger.db('Encrypting and saving current user to DB');
    final encrypted = EvaluatorSecureService.encrypt(user);
    await _db.delete('current_user');
    await _db.insert('current_user', encrypted.toMap());
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\auth\data\auth_model.dart ===
class AuthModel {
  final int id;
  final String email;
  final String password;

  AuthModel({required this.id, required this.email, required this.password});

  factory AuthModel.fromMap(Map<String, dynamic> map) {
    return AuthModel(
      id: map['id'] as int,
      email: map['email'] as String,
      password: map['password'] as String,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'email': email,
      'password': password,
    };
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\auth\data\auth_repository_impl.dart ===
import '../../auth/domain/auth_repository.dart';
import '../../evaluator/application/evaluator_secure_service.dart';
import '../../evaluator/data/evaluator_model.dart';
import 'auth_local_datasource.dart';

class AuthRepositoryImpl implements AuthRepository {
  final AuthLocalDataSource _local;

  AuthRepositoryImpl(this._local);

  @override
  Future<EvaluatorModel?> login(String email, String password) async {
    print('[AuthRepositoryImpl] üîê Login request for: $email');
    final evaluator = await _local.getEvaluatorByEmail(email);

    if (evaluator == null) {
      print('[AuthRepositoryImpl] ‚ùå No evaluator found');
      return null;
    }

    // Hash password instead of encrypting it
    final hashedInputPassword = EvaluatorSecureService.hash(password);
    print('[AuthRepositoryImpl] üîê Hashed input password: $hashedInputPassword');
    print('[AuthRepositoryImpl] üóÉÔ∏è Stored password: ${evaluator.password}');

    if (evaluator.password != hashedInputPassword) {
      print('[AuthRepositoryImpl] ‚ùå Password mismatch');
      return null;
    }

    print('[AuthRepositoryImpl] ‚úÖ Login successful');
    return evaluator;
  }

  @override
  Future<void> saveCurrentUserToDB(EvaluatorModel user) {
    return _local.saveCurrentUser(user);
  }

  @override
  Future<EvaluatorModel?> getCachedUser() {
    return _local.getCachedUser();
  }

  @override
  Future<void> clearCurrentUser() {
    return _local.clearCurrentUser();
  }

  @override
  Future<void> clearCurrentUserFromDB() {
    return _local.clearCurrentUser();
  }

  @override
  Future<void> cacheUser(EvaluatorModel user) {
    // Optional: implement this if different from saveCurrentUserToDB
    return _local.saveCurrentUser(user);
  }

  @override
  Future<void> clearCachedUser() {
    return _local.clearCurrentUser();
  }

  @override
  Future<EvaluatorModel?> fetchCurrentUserOrNull() {
    return _local.getCachedUser();
  }

  @override
  Future<void> signOut() {
    return _local.clearCurrentUser();
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\auth\domain\auth_repository.dart ===
import '../../evaluator/data/evaluator_model.dart';

abstract class AuthRepository {
  Future<EvaluatorModel?> login(String email, String password);
  Future<void> signOut();
  Future<void> cacheUser(EvaluatorModel user);
  Future<void> clearCachedUser();
  Future<EvaluatorModel?> getCachedUser();
  Future<EvaluatorModel?> fetchCurrentUserOrNull();
  Future<void> saveCurrentUserToDB(EvaluatorModel user);
  Future<void> clearCurrentUserFromDB();
  Future<void> clearCurrentUser();
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\auth\presentation\login_form.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../core/logger/app_logger.dart';
import '../../../core/theme/app_colors.dart';
import '../../../providers/auth_providers.dart';

class LoginForm extends HookConsumerWidget {
  const LoginForm({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final emailController = useTextEditingController();
    final passwordController = useTextEditingController();
    final showPassword = useState(false);

    final loginState = ref.watch(loginProvider);
    final showInfoBar = useState(false);
    final infoBarMsg = useState('');
    final isSuccess = useState(false);

    ref.listen<AsyncValue<bool>>(loginProvider, (previous, next) {
      next.when(
        data: (success) {
          if (success) {
            AppLogger.nav('Login successful ‚Üí navigating to /home');
            isSuccess.value = true;
            infoBarMsg.value = 'Login successful!';
            showInfoBar.value = true;
            Future.delayed(const Duration(seconds: 1), () {
              if (context.mounted) context.go('/home');
            });
          }
        },
        error: (err, _) {
          AppLogger.warning('Login error: $err');
          isSuccess.value = false;
          infoBarMsg.value = err.toString();
          showInfoBar.value = true;
        },
        loading: () {
          AppLogger.debug('Login loading...');
        },
      );
    });

    void onLoginPressed() {
      final email = emailController.text.trim();
      final password = passwordController.text;
      AppLogger.info('Login pressed: $email');
      ref.read(loginProvider.notifier).login(email, password);
    }

    return Center(
      child: Container(
        padding: const EdgeInsets.all(24),
        constraints: const BoxConstraints(maxWidth: 400),
        decoration: BoxDecoration(
          color: AppColors.coolGray900,
          borderRadius: BorderRadius.circular(16),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Text(
              "Login",
              style: TextStyle(
                fontSize: 28,
                fontWeight: FontWeight.bold,
                color: AppColors.softWhite,
              ),
            ),
            const SizedBox(height: 24),

            // Email
            InfoLabel(
              label: "Email",
              child: TextBox(
                placeholder: "email@exemplo.com",
                controller: emailController,
              ),
            ),
            const SizedBox(height: 16),

            // Password + visibility toggle
            InfoLabel(
              label: "Password",
              child: Stack(
                alignment: Alignment.centerRight,
                children: [
                  TextBox(
                    controller: passwordController,
                    obscureText: !showPassword.value,
                    placeholder: "Sua senha",
                  ),
                  IconButton(
                    icon: Icon(
                      showPassword.value ? FluentIcons.hide3 : FluentIcons.view,
                    ),
                    onPressed: () => showPassword.value = !showPassword.value,
                  ),
                ],
              ),
            ),
            const SizedBox(height: 16),

            Align(
              alignment: Alignment.centerLeft,
              child: Text(
                "Forgot password?",
                style: TextStyle(
                  color: AppColors.skyBlue,
                  decoration: TextDecoration.underline,
                ),
              ),
            ),
            const SizedBox(height: 16),

            // Login button with loading
            FilledButton(
              child: loginState.isLoading
                  ? const ProgressRing()
                  : const Text("Sign in"),
              onPressed: loginState.isLoading ? null : onLoginPressed,
            ),
            const SizedBox(height: 12),

// üëá New: Register link
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Text(
                  "Don't have an account?",
                  style: TextStyle(
                    color: AppColors.softWhite,
                  ),
                ),
                const SizedBox(width: 6),
                HyperlinkButton(
                  onPressed: () {
                    context.go('/register'); // must match your router
                  },
                  child: const Text(
                    "Create one",
                    style: TextStyle(
                      color: AppColors.skyBlue,
                      decoration: TextDecoration.underline,
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),


            // Info bar
            if (showInfoBar.value)
              InfoBar(
                title: Text(isSuccess.value ? "Success" : "Error"),
                content: Text(infoBarMsg.value),
                severity: isSuccess.value
                    ? InfoBarSeverity.success
                    : InfoBarSeverity.error,
                isLong: true,
                onClose: () => showInfoBar.value = false,
              ),
          ],
        ),
      ),
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\auth\presentation\login_screen.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:go_router/go_router.dart';
import '../../../core/logger/app_logger.dart';
import '../../../core/theme/app_colors.dart';
import '../../../providers/auth_providers.dart';
import 'login_form.dart';

class LoginScreen extends HookConsumerWidget {
  const LoginScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    AppLogger.nav('LoginScreen initialized');

    final showInfoBar = useState(false);
    final infoBarMsg = useState('');
    final isSuccess = useState(false);

    ref.listen<AsyncValue<bool>>(loginProvider, (previous, next) {
      next.when(
        data: (success) {
          if (success) {
            AppLogger.nav('Login successful ‚Üí navigating to /home');
            Future.delayed(const Duration(seconds: 1), () {
              if (context.mounted) context.go('/home');
            });
          }
        },
        error: (err, _) {
          AppLogger.warning('Login error displayed: $err');
          isSuccess.value = false;
          infoBarMsg.value = err.toString();
          showInfoBar.value = true;
        },
        loading: () => AppLogger.debug('Login process loading...'),
      );
    });

    return NavigationView(
      content: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [AppColors.aquaBlue, AppColors.skyBlue, AppColors.chromeBlue],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: const Center(child: LoginForm()),
      ),
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluation\application\notifier\evaluation_notifier.dart ===
import 'dart:async';
import 'package:riverpod/riverpod.dart';
import '../../../../core/logger/app_logger.dart';
import '../../domain/evaluation_entity.dart';
import '../../domain/evaluation_repository.dart';
import '../../presentation/evaluation_provider.dart';

class EvaluationNotifier extends AsyncNotifier<List<EvaluationEntity>> {
  late final EvaluationRepository _repository;

  @override
  FutureOr<List<EvaluationEntity>> build() async {
    _repository = ref.read(evaluationRepositoryProvider);
    AppLogger.info('EvaluationNotifier.build ‚Üí loading evaluations');
    try {
      final evaluations = await _repository.getAllEvaluations();
      AppLogger.info('EvaluationNotifier.build ‚Üí loaded ${evaluations.length} evaluations');
      return evaluations;
    } catch (e, s) {
      AppLogger.error('EvaluationNotifier.build ‚Üí failed to load evaluations', e, s);
      rethrow;
    }
  }

  Future<void> refresh() async {
    AppLogger.info('EvaluationNotifier.refresh ‚Üí reloading evaluations');
    state = const AsyncLoading();
    try {
      final evaluations = await _repository.getAllEvaluations();
      AppLogger.info('EvaluationNotifier.refresh ‚Üí loaded ${evaluations.length} evaluations');
      state = AsyncData(evaluations);
    } catch (e, s) {
      AppLogger.error('EvaluationNotifier.refresh ‚Üí error', e, s);
      state = AsyncError(e, s);
    }
  }

  Future<void> addEvaluation(EvaluationEntity evaluation) async {
    AppLogger.info(
      'EvaluationNotifier.addEvaluation ‚Üí participantId=${evaluation.participantID}, evaluatorId=${evaluation.evaluatorID}',
    );
    state = const AsyncLoading();
    try {
      print('üöÄ Adding evaluation for participantId=${evaluation.participantID}');
      await _repository.insertEvaluation(evaluation);

      final updated = await _repository.getAllEvaluations();
      AppLogger.db('EvaluationNotifier.addEvaluation ‚Üí now ${updated.length} evaluations');
      print('‚úÖ Evaluation added. Total now: ${updated.length}');
      state = AsyncData(updated);
    } catch (e, s) {
      AppLogger.error('EvaluationNotifier.addEvaluation ‚Üí error', e, s);
      print('‚ùå addEvaluation failed: $e');
      state = AsyncError(e, s);
      rethrow; // Let the UI optionally handle it
    }

  }

  Future<EvaluationEntity?> getEvaluationById(int id) async {
    AppLogger.info('EvaluationNotifier.getEvaluationById ‚Üí id=$id');
    try {
      final evaluation = await _repository.getById(id);
      if (evaluation == null) {
        AppLogger.warning('EvaluationNotifier.getEvaluationById ‚Üí no evaluation found for id=$id');
      }
      return evaluation;
    } catch (e, s) {
      AppLogger.error('EvaluationNotifier.getEvaluationById ‚Üí error', e, s);
      rethrow;
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluation\data\evaluation_constants.dart ===
import '../../../core/constants/database_constants.dart';
import '../../evaluator/data/evaluator_constants.dart';
import '../../participant/data/participant_constants.dart';

class EvaluationFields {
    static const id = "evaluation_id";
    static const date = "evaluation_date";
    static const evaluatorId = "evaluator_id"; // FK
    static const participantId = "participant_id"; // FK
    static const status = "status";
    static const language = "language";

    static const values = [
        id,
        date,
        evaluatorId,
        participantId,
        status,
        language,
    ];
}

const scriptCreateTableEvaluations = '''
CREATE TABLE ${Tables.evaluations} (
  ${EvaluationFields.id} INTEGER PRIMARY KEY AUTOINCREMENT,
  ${EvaluationFields.date} TIMESTAMP NOT NULL,
  ${EvaluationFields.evaluatorId} INTEGER NOT NULL,
  ${EvaluationFields.participantId} INTEGER UNIQUE NOT NULL,
  ${EvaluationFields.status} INT CHECK(${EvaluationFields.status} >= 0 AND ${EvaluationFields.status} <= 3) NOT NULL,
  ${EvaluationFields.language} INT CHECK(${EvaluationFields.language} >= 1 AND ${EvaluationFields.language} <= 3),
  FOREIGN KEY (${EvaluationFields.evaluatorId}) REFERENCES ${Tables.evaluators}(${EvaluatorFields.id}),
  FOREIGN KEY (${EvaluationFields.participantId}) REFERENCES ${Tables.participants}(${ParticipantFields.id})
);
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluation\data\evaluation_local_datasource.dart ===
import 'package:sqflite_common/sqlite_api.dart';
import '../../../core/constants/database_constants.dart';
import '../../../core/database/base_database_helper.dart';
import '../../../core/logger/app_logger.dart';
import '../domain/evaluation_entity.dart';
import '../data/evaluation_constants.dart';

class EvaluationLocalDataSource {
  final BaseDatabaseHelper dbHelper;

  EvaluationLocalDataSource({required this.dbHelper});

  Future<Database> get _db async => dbHelper.database;

  Future<int?> insertEvaluation(Transaction txn, Map<String, dynamic> data) async {
    try {
      final id = await txn.insert(Tables.evaluations, data); // ‚úÖ use txn
      AppLogger.db('Inserted evaluation with ID=$id');
      return id;
    } catch (e, s) {
      AppLogger.error('EvaluationLocalDataSource.insertEvaluation ‚Üí DB error', e, s);
      rethrow;
    }
  }

  Future<List<EvaluationEntity>> getAllEvaluations() async {
    final db = await _db;
    final maps = await db.query(Tables.evaluations);
    return maps.map(EvaluationEntity.fromMap).toList();
  }

  Future<EvaluationEntity?> getById(Database db, int id) async {
    final maps = await db.query(
      Tables.evaluations,
      where: '${EvaluationFields.id} = ?',
      whereArgs: [id],
      limit: 1,
    );

    if (maps.isNotEmpty) {
      return EvaluationEntity.fromMap(maps.first);
    }
    return null;
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluation\data\evaluation_repository_impl.dart ===
import '../../../core/constants/database_constants.dart';
import '../../../core/logger/app_logger.dart';
import '../domain/evaluation_entity.dart';
import '../domain/evaluation_repository.dart';
import 'evaluation_constants.dart';
import 'evaluation_local_datasource.dart';

class EvaluationRepositoryImpl implements EvaluationRepository {
  final EvaluationLocalDataSource local;

  EvaluationRepositoryImpl({required this.local});

  // ‚ö†Ô∏è This should no longer be used directly outside a transaction
  @override
  Future<void> insertEvaluation(EvaluationEntity evaluation) {
    throw UnimplementedError(
      'Use EvaluationLocalDataSource.insertEvaluation within a transaction instead.',
    );
  }

  @override
  Future<List<EvaluationEntity>> getAllEvaluations() async {
    AppLogger.db('EvaluationRepositoryImpl.getAllEvaluations ‚Üí fetching');
    final list = await local.getAllEvaluations();
    AppLogger.db('EvaluationRepositoryImpl.getAllEvaluations ‚Üí fetched ${list.length} evaluations');
    return list;
  }

  @override
  Future<EvaluationEntity?> getById(int id) async {
    AppLogger.db('EvaluationRepositoryImpl.getById ‚Üí id=$id');
    final db = await local.dbHelper.database;
    final evaluation = await local.getById(db, id);
    if (evaluation == null) {
      AppLogger.warning('EvaluationRepositoryImpl.getById ‚Üí not found id=$id');
    }
    return evaluation;
  }

  @override
  Future<List<EvaluationEntity>> getEvaluationsByEvaluator(int evaluatorId) async {
    final db = await local.dbHelper.database;
    final maps = await db.query(
      Tables.evaluations,
      where: '${EvaluationFields.evaluatorId} = ?',
      whereArgs: [evaluatorId],
    );

    return maps.map((map) => EvaluationEntity.fromMap(map)).toList();
  }

}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluation\domain\evaluation_entity.dart ===
import 'dart:convert';

import '../../../core/constants/enums/progress_status.dart';
import '../data/evaluation_constants.dart';

class EvaluationEntity {
  final int? evaluationID;
  final int evaluatorID;
  final int participantID;
  final EvaluationStatus status;
  final DateTime evaluationDate;
  final int language;

  EvaluationEntity({
    this.evaluationID,
    DateTime? evaluationDate,
    this.status = EvaluationStatus.pending,
    required this.evaluatorID,
    required this.participantID,
    required this.language,
  }) : evaluationDate = evaluationDate ?? DateTime.now();

  Map<String, dynamic> toMap() => {
    EvaluationFields.id: evaluationID,
    EvaluationFields.date: evaluationDate.toIso8601String(),
    EvaluationFields.evaluatorId: evaluatorID,
    EvaluationFields.participantId: participantID,
    EvaluationFields.status: status.numericValue,
    EvaluationFields.language: language,
  };

  static EvaluationEntity fromMap(Map<String, dynamic> map) {
    return EvaluationEntity(
      evaluationID: map[EvaluationFields.id] as int?,
      evaluatorID: map[EvaluationFields.evaluatorId] as int,
      participantID: map[EvaluationFields.participantId] as int,
      language: map[EvaluationFields.language] as int,
      status: EvaluationStatus.fromValue(
        map[EvaluationFields.status] ?? 1,
      ),
      evaluationDate: map[EvaluationFields.date] != null
          ? DateTime.tryParse(map[EvaluationFields.date]) ?? DateTime.now()
          : DateTime.now(),
    );
  }

  String toJson() => jsonEncode(toMap());

  static EvaluationEntity fromJson(String jsonString) =>
      EvaluationEntity.fromMap(jsonDecode(jsonString));

  @override
  String toString() =>
      'EvaluationEntity(evaluationID: $evaluationID, evaluatorID: $evaluatorID, participantID: $participantID, status: ${status.description})';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluation\domain\evaluation_repository.dart ===
import 'evaluation_entity.dart';

abstract class EvaluationRepository {
  Future<void> insertEvaluation(EvaluationEntity evaluation);
  Future<List<EvaluationEntity>> getAllEvaluations();
  Future<EvaluationEntity?> getById(int id);

  Future getEvaluationsByEvaluator(int i) async {}
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluation\domain\usecases\create_participant_evaluation_usecase.dart ===
import 'package:sqflite_common_ffi/sqflite_ffi.dart';

import '../../../../core/logger/app_logger.dart';
import '../../../../core/constants/enums/progress_status.dart';

import '../../../../shared/encryption/deterministic_encryption_helper.dart';
import '../../../participant/domain/participant_entity.dart';
import '../../../participant/data/participant_local_datasource.dart';

import '../../../evaluation/data/evaluation_local_datasource.dart';
import '../../../evaluation/domain/evaluation_entity.dart';

import '../../../module/domain/module_repository.dart';
import '../../../module_instance/domain/module_instance_entity.dart';
import '../../../module_instance/domain/module_instance_repository.dart';

import '../../../task/data/task_local_datasource.dart';
import '../../../task_instance/domain/task_instance_entity.dart';
import '../../../task_instance/domain/task_instance_repository.dart';

class CreateParticipantEvaluationUseCase {
  final ParticipantLocalDataSource participantDataSource;
  final EvaluationLocalDataSource evaluationDataSource;
  final ModuleRepository moduleRepository;
  final ModuleInstanceRepository moduleInstanceRepository;
  final TaskLocalDataSource taskDataSource;
  final TaskInstanceRepository taskInstanceRepository;
  final Database db;

  CreateParticipantEvaluationUseCase({
    required this.participantDataSource,
    required this.evaluationDataSource,
    required this.moduleRepository,
    required this.moduleInstanceRepository,
    required this.taskDataSource,
    required this.taskInstanceRepository,
    required this.db,
  });

  Future<ParticipantEntity> execute({
    required ParticipantEntity participant,
    required int evaluatorId,
    required List<int> selectedModuleIds,
    int language = 1,
  }) async {
    AppLogger.info('[USECASE] Starting participant creation: ${participant.name} (selectedModules=$selectedModuleIds)');

    late final int participantId;
    late final int evaluationId;

    try {
      // üîÅ FIRST TRANSACTION: Insert participant and evaluation
      await db.transaction((txn) async {
        final hashedParticipant = participant.copyWith(
          name: DeterministicEncryptionHelper.encryptText(participant.name),
          surname: DeterministicEncryptionHelper.encryptText(participant.surname),
        );

        final insertedParticipantId = await participantDataSource.insertParticipant(txn, hashedParticipant.toMap());

        if (insertedParticipantId == null) {
          AppLogger.error('[USECASE] ‚ùå Failed to insert participant (null returned)');
          throw Exception('Participant insertion failed');
        }
        participantId = insertedParticipantId;
        AppLogger.db('[USECASE] ‚úÖ Participant inserted: id=$participantId');


        final evaluation = EvaluationEntity(
          evaluatorID: evaluatorId,
          participantID: participantId,
          status: EvaluationStatus.pending,
          language: language,
        );

        final insertedEvaluationId = await evaluationDataSource.insertEvaluation(txn, evaluation.toMap());

        if (insertedEvaluationId == null) {
          AppLogger.error('[USECASE] ‚ùå Failed to insert evaluation (null returned)');
          throw Exception('Evaluation insertion failed');
        }
        evaluationId = insertedEvaluationId;
        AppLogger.db('[USECASE] ‚úÖ Evaluation inserted: id=$evaluationId');

      });

      // üîÅ SECOND TRANSACTION: Fetch modules and create module/task instances
      final allModules = await moduleRepository.getAllModules().timeout(
        const Duration(seconds: 5),
        onTimeout: () {
          AppLogger.error('[USECASE] ‚ùå Timeout while fetching modules');
          throw Exception('Timeout fetching modules');
        },
      );
      AppLogger.info('[USECASE] üß© Fetched ${allModules.length} modules');

      final modulesToUse = selectedModuleIds.isEmpty
          ? allModules
          : allModules.where((m) => m.moduleID != null && selectedModuleIds.contains(m.moduleID)).toList();

      AppLogger.info('[USECASE] üì¶ Using ${modulesToUse.length} modules');

      for (final module in modulesToUse) {
        if (module.moduleID == null) continue;

        final moduleInstance = ModuleInstanceEntity(
          moduleId: module.moduleID!,
          status: ModuleStatus.pending, evaluationId: evaluationId,
        );

        final moduleInstanceCreated = await moduleInstanceRepository.createModuleInstance(moduleInstance);
        final moduleInstanceId = moduleInstanceCreated?.id;

        if (moduleInstanceId == null) {
          AppLogger.error('[USECASE] ‚ùå Failed to create ModuleInstance for moduleId=${module.moduleID}');
          continue;
        }

        final tasks = await taskDataSource.getTasksByModuleId(module.moduleID!);
        AppLogger.info('[USECASE] üîß Found ${tasks.length} tasks for moduleId=${module.moduleID}');

        for (final task in tasks) {
          if (task.taskID == null) continue;

          final taskInstance = TaskInstanceEntity(
            taskId: task.taskID!,
            moduleInstanceId: moduleInstanceId,
            status: TaskStatus.pending,
          );

          final taskInstanceId = await taskInstanceRepository.insert(taskInstance);
          AppLogger.db('[USECASE] ‚úÖ TaskInstance inserted: id=$taskInstanceId (taskId=${task.taskID})');
        }
      }

      final createdParticipant = participant.copyWith(participantID: participantId);
      AppLogger.info('[USECASE] ‚úÖ Participant + Evaluation + Modules + Tasks created successfully');

      return createdParticipant;
    } catch (e, s) {
      AppLogger.error('[USECASE] ‚ùå Creation failed. DB may be partially written.', e, s);
      rethrow;
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluation\presentation\evaluation_provider.dart ===
import 'package:hooks_riverpod/hooks_riverpod.dart';
import '../../../core/database/prod_database_helper.dart';
import '../../../core/logger/app_logger.dart';
import '../data/evaluation_local_datasource.dart';
import '../data/evaluation_repository_impl.dart';
import '../domain/evaluation_repository.dart';

final evaluationDbHelperProvider = Provider((ref) {
  AppLogger.db('Providing ProdDatabaseHelper.instance for evaluation (presentation)');
  return ProdDatabaseHelper.instance;
});

final evaluationLocalDataSourceProvider = Provider((ref) {
  final dbHelper = ref.watch(evaluationDbHelperProvider);
  AppLogger.db('Creating EvaluationLocalDataSource');
  return EvaluationLocalDataSource(dbHelper: dbHelper);
});

final evaluationRepositoryProvider = Provider<EvaluationRepository>((ref) {
  final local = ref.watch(evaluationLocalDataSourceProvider);
  AppLogger.info('Creating EvaluationRepositoryImpl (presentation/provider)');
  return EvaluationRepositoryImpl(local: local);
});


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluation\presentation\module_evaluation_screen.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import '../../module_instance/presentation/module_instance_provider.dart';
import 'module_table.dart';

class ModuleEvaluationScreen extends HookConsumerWidget {
  final int evaluationId;

  const ModuleEvaluationScreen({super.key, required this.evaluationId});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final repo = ref.watch(moduleInstanceRepositoryProvider);

    final future = useMemoized(
          () => repo.getModuleInstancesByEvaluationId(evaluationId),
      [evaluationId],
    );
    final snapshot = useFuture(future);

    if (!snapshot.hasData) {
      return const Center(child: ProgressRing());
    }

    final modules = snapshot.data!;

    return ScaffoldPage(
      header: PageHeader(
        title: const Text('Avalia√ß√£o por M√≥dulo'),
        leading: IconButton(
          icon: const Icon(FluentIcons.back),
          onPressed: () {
            Navigator.pop(context);
          },
        ),
      ),
      content: Column(
        children: [
          const SizedBox(height: 12),
          Expanded(child: ModuleTable(modules: modules)),
        ],
      ),
    );

  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluation\presentation\module_table.dart ===
import 'package:fluent_ui/fluent_ui.dart';

import '../../../core/constants/enums/progress_status.dart';
import '../../module_instance/domain/module_instance_entity.dart';

class ModuleTable extends StatelessWidget {
  final List<ModuleInstanceEntity> modules;

  const ModuleTable({super.key, required this.modules});

  @override
  Widget build(BuildContext context) {
    return Table(
      columnWidths: const {
        0: FlexColumnWidth(3),
        1: FlexColumnWidth(2),
        2: FlexColumnWidth(4),
      },
      children: [
        const TableRow(
          decoration: BoxDecoration(color: Color(0xFFE4ECF7)),
          children: [
            Padding(
              padding: EdgeInsets.all(8.0),
              child: Text('M√≥dulo', style: TextStyle(fontWeight: FontWeight.bold)),
            ),
            Padding(
              padding: EdgeInsets.all(8.0),
              child: Text('Status'),
            ),
            Padding(
              padding: EdgeInsets.all(8.0),
              child: Text('A√ß√µes'),
            ),
          ],
        ),
        ...modules.map((instance) {
          final title = instance.module?.title ?? 'Sem t√≠tulo';
          final icon = _statusIcon(instance.status);

          return TableRow(
            decoration: const BoxDecoration(
              border: Border(bottom: BorderSide(color: Color(0xFFD0D0D0))),
            ),
            children: [
              Padding(
                padding: const EdgeInsets.all(8.0),
                child: Text(title),
              ),
              Padding(
                padding: const EdgeInsets.all(8.0),
                child: Row(children: [icon, const SizedBox(width: 6), Text(instance.status.description)]),
              ),
              Padding(
                padding: const EdgeInsets.all(8.0),
                child: Button(
                  child: const Text('Iniciar'),
                  onPressed: () {
                    // TODO: implementar l√≥gica de iniciar m√≥dulo
                  },
                ),
              ),
            ],
          );
        }),
      ],
    );
  }

  Widget _statusIcon(ModuleStatus status) {
    switch (status) {
      case ModuleStatus.completed:
        return Icon(FluentIcons.check_mark, color: Colors.green);
      case ModuleStatus.inProgress:
        return Icon(FluentIcons.clock, color: Colors.orange);
      case ModuleStatus.pending:
      return const Icon(FluentIcons.circle_ring, color: Colors.grey);
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\application\evaluator_notifier.dart ===
import 'package:hooks_riverpod/hooks_riverpod.dart';
import '../../../core/database/prod_database_helper.dart';
import '../../../core/environment.dart';
import '../../../core/logger/app_logger.dart';
import '../../../providers/providers.dart';
import '../data/evaluator_local_datasource.dart';
import '../data/evaluator_remote_datasource.dart';
import '../data/evaluator_repository_impl.dart';
import '../domain/evaluator_repository.dart';

class EvaluatorRepositoryNotifier extends AsyncNotifier<EvaluatorRepository> {
  @override
  Future<EvaluatorRepository> build() async {
    try {
      final env = ref.watch(environmentProvider);
      AppLogger.info('EvaluatorRepositoryNotifier started (env=$env)');

      if (env == AppEnv.local) {
        final db = await ProdDatabaseHelper.instance.database;
        AppLogger.db('Initializing local EvaluatorRepository...');
        return EvaluatorRepositoryImpl.local(EvaluatorLocalDataSource(db));
      } else {
        AppLogger.info('Initializing remote EvaluatorRepository...');
        return EvaluatorRepositoryImpl.remote(EvaluatorRemoteDataSource());
      }
    } catch (e, s) {
      AppLogger.error('EvaluatorRepository initialization failed', e, s);
      rethrow;
    }
  }
}

final evaluatorRepositoryProvider =
AsyncNotifierProvider<EvaluatorRepositoryNotifier, EvaluatorRepository>(
  EvaluatorRepositoryNotifier.new,
);


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\application\evaluator_secure_service.dart ===
import 'dart:convert';
import 'package:crypto/crypto.dart';
import '../../../shared/encryption/deterministic_encryption_helper.dart';
import '../data/evaluator_model.dart';

class EvaluatorSecureService {
  static EvaluatorModel encrypt(EvaluatorModel model) {
    return model.copyWith(
      name: DeterministicEncryptionHelper.encryptText(model.name),
      surname: DeterministicEncryptionHelper.encryptText(model.surname),
      email: DeterministicEncryptionHelper.encryptText(model.email),
      birthDate: DeterministicEncryptionHelper.encryptText(model.birthDate),
      specialty: DeterministicEncryptionHelper.encryptText(model.specialty),
      cpfOrNif: DeterministicEncryptionHelper.encryptText(model.cpfOrNif),
      username: DeterministicEncryptionHelper.encryptText(model.username),
      password: hash(model.password), // password stays hashed
    );
  }

  static EvaluatorModel decrypt(EvaluatorModel model) {
    return model.copyWith(
      name: DeterministicEncryptionHelper.decryptText(model.name),
      surname: DeterministicEncryptionHelper.decryptText(model.surname),
      email: DeterministicEncryptionHelper.decryptText(model.email),
      birthDate: DeterministicEncryptionHelper.decryptText(model.birthDate),
      specialty: DeterministicEncryptionHelper.decryptText(model.specialty),
      cpfOrNif: DeterministicEncryptionHelper.decryptText(model.cpfOrNif),
      username: DeterministicEncryptionHelper.decryptText(model.username),
      // password remains hashed
    );
  }

  static String hash(String input) {
    return sha256.convert(utf8.encode(input)).toString();
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\data\current_user_constants.dart ===
import '../../../core/constants/database_constants.dart';
import 'evaluator_constants.dart';

class CurrentUserFields {
  static const id = EvaluatorFields.id;
  static const name = EvaluatorFields.name;
  static const surname = EvaluatorFields.surname;
  static const email = EvaluatorFields.email;
  static const birthDate = EvaluatorFields.birthDate;
  static const specialty = EvaluatorFields.specialty;
  static const cpf = EvaluatorFields.cpf;
  static const username = EvaluatorFields.username;
  static const password = EvaluatorFields.password;
  static const firstLogin = EvaluatorFields.firstLogin;
  static const isAdmin = EvaluatorFields.isAdmin;

  static const values = [
    id,
    name,
    surname,
    email,
    birthDate,
    specialty,
    cpf,
    username,
    password,
    firstLogin,
    isAdmin,
  ];
}


const scriptCreateTableCurrentUser = '''
CREATE TABLE ${Tables.currentUser} (
  ${CurrentUserFields.id} INTEGER PRIMARY KEY,
  ${CurrentUserFields.name} TEXT NOT NULL,
  ${CurrentUserFields.surname} TEXT NOT NULL,
  ${CurrentUserFields.email} TEXT NOT NULL,
  ${CurrentUserFields.birthDate} TIMESTAMP,
  ${CurrentUserFields.specialty} TEXT,
  ${CurrentUserFields.cpf} TEXT,
  ${CurrentUserFields.username} TEXT NOT NULL UNIQUE,
  ${CurrentUserFields.password} TEXT NOT NULL,
  ${CurrentUserFields.isAdmin} INTEGER NOT NULL DEFAULT 0,
  ${CurrentUserFields.firstLogin} INTEGER NOT NULL DEFAULT 0,
  FOREIGN KEY (${CurrentUserFields.id})
    REFERENCES ${Tables.evaluators}(${EvaluatorFields.id})
    ON DELETE CASCADE ON UPDATE CASCADE
);
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\data\evaluator_constants.dart ===
import '../../../core/constants/database_constants.dart';

class EvaluatorFields {
  static const id = "evaluator_id";
  static const name = "name";
  static const surname = "surname";
  static const email = "email";
  static const birthDate = "birth_date";
  static const specialty = "specialty";
  static const cpf = "cpf";
  static const username = "username";
  static const password = "password";
  static const firstLogin = "first_login";
  static const isAdmin = "is_admin";

  static const values = [
    id,
    name,
    surname,
    email,
    birthDate,
    specialty,
    cpf,
    username,
    password,
    firstLogin,
    isAdmin,
  ];
}

const scriptCreateTableEvaluators = '''
CREATE TABLE ${Tables.evaluators} (
  ${EvaluatorFields.id} INTEGER PRIMARY KEY AUTOINCREMENT,
  ${EvaluatorFields.name} TEXT NOT NULL,
  ${EvaluatorFields.surname} TEXT NOT NULL,
  ${EvaluatorFields.email} TEXT NOT NULL,
  ${EvaluatorFields.birthDate} TIMESTAMP,
  ${EvaluatorFields.specialty} TEXT,
  ${EvaluatorFields.cpf} TEXT,
  ${EvaluatorFields.username} TEXT NOT NULL UNIQUE,
  ${EvaluatorFields.password} TEXT NOT NULL DEFAULT '0000',
  ${EvaluatorFields.firstLogin} INTEGER NOT NULL DEFAULT 0,
  ${EvaluatorFields.isAdmin} INTEGER NOT NULL DEFAULT 0
);
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\data\evaluator_local_datasource.dart ===
import 'package:sqflite_common/sqlite_api.dart';

import '../../../core/constants/database_constants.dart';
import '../../../core/logger/app_logger.dart';
import '../../../shared/encryption/deterministic_encryption_helper.dart';
import '../application/evaluator_secure_service.dart';
import 'evaluator_constants.dart';
import 'evaluator_model.dart';

class EvaluatorLocalDataSource {
  final DatabaseExecutor _db;
  EvaluatorLocalDataSource(this._db);

  /// Insert evaluator securely (encrypt PII, hash password)
  Future<void> insert(EvaluatorModel evaluator) async {
    AppLogger.db('[EVALUATOR] Inserting evaluator: ${evaluator.email}');
    final secured = EvaluatorSecureService.encrypt(evaluator);
    await _db.insert(
      Tables.evaluators,
      secured.toMap(),
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
  }

  /// Fetch all evaluators (decrypted)
  Future<List<EvaluatorModel>> getAll() async {
    AppLogger.db('[EVALUATOR] Fetching all evaluators');
    final result = await _db.query(Tables.evaluators);
    return result
        .map(EvaluatorModel.fromMap)
        .map(EvaluatorSecureService.decrypt)
        .toList();
  }

  /// Get evaluator by ID (decrypted)
  Future<EvaluatorModel?> getById(int id) async {
    final result = await _db.query(
      Tables.evaluators,
      where: '${EvaluatorFields.id} = ?',
      whereArgs: [id],
      limit: 1,
    );
    return result.isNotEmpty
        ? EvaluatorSecureService.decrypt(EvaluatorModel.fromMap(result.first))
        : null;
  }

  /// Get the first evaluator (decrypted)
  Future<EvaluatorModel?> getFirstEvaluator() async {
    final result = await _db.query(
      Tables.evaluators,
      orderBy: '${EvaluatorFields.id} ASC',
      limit: 1,
    );
    return result.isNotEmpty
        ? EvaluatorSecureService.decrypt(EvaluatorModel.fromMap(result.first))
        : null;
  }

  /// Legacy support: check if any admin exists
  Future<bool> hasAnyEvaluatorAdmin() async {
    AppLogger.db('[EVALUATOR] Checking if any admin evaluator exists...');
    final result = await _db.query(
      Tables.evaluators,
      where: '${EvaluatorFields.isAdmin} = ?',
      whereArgs: [1],
      limit: 1,
    );
    return result.isNotEmpty;
  }

  /// Delete evaluator
  Future<int> deleteById(int id) async {
    return await _db.delete(
      Tables.evaluators,
      where: '${EvaluatorFields.id} = ?',
      whereArgs: [id],
    );
  }

  /// Existence check by email (encrypt the lookup value)
  Future<bool> existsByEmail(String email) async {
    AppLogger.db('[EVALUATOR] Checking if evaluator exists for email: $email');
    try {
      final encEmail = DeterministicEncryptionHelper.encryptText(email);
      final result = await _db.query(
        Tables.evaluators,
        where: '${EvaluatorFields.email} = ?',
        whereArgs: [encEmail],
        limit: 1,
      );
      final exists = result.isNotEmpty;
      AppLogger.db('[EVALUATOR] existsByEmail($email) ‚Üí $exists');
      return exists;
    } catch (e, s) {
      AppLogger.error('[EVALUATOR] Error checking existsByEmail', e, s);
      return false;
    }
  }

  /// Login using encrypted username + hashed password
  Future<EvaluatorModel?> login(String username, String password) async {
    final encryptedUsername = DeterministicEncryptionHelper.encryptText(username);
    final hashedPassword = EvaluatorSecureService.hash(password);

    final result = await _db.query(
      Tables.evaluators,
      where: '${EvaluatorFields.username} = ? AND ${EvaluatorFields.password} = ?',
      whereArgs: [encryptedUsername, hashedPassword],
      limit: 1,
    );

    return result.isNotEmpty
        ? EvaluatorSecureService.decrypt(EvaluatorModel.fromMap(result.first))
        : null;
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\data\evaluator_model.dart ===
import 'package:segundo_cogni/features/evaluator/domain/evaluator_registration_data.dart';
import '../domain/evaluator_entity.dart';
import 'evaluator_constants.dart';

class EvaluatorModel extends EvaluatorEntity {
  const EvaluatorModel({
    super.evaluatorId,
    required super.name,
    required super.surname,
    required super.email,
    required super.birthDate,
    required super.specialty,
    required super.cpfOrNif,
    required super.username,
    required super.password,
    // Align with DB default (0 ‚Üí false)
    super.firstLogin = false,
  });

  factory EvaluatorModel.fromMap(Map<String, dynamic> map) => EvaluatorModel(
    evaluatorId: map[EvaluatorFields.id] as int?,
    name: map[EvaluatorFields.name] as String,
    surname: map[EvaluatorFields.surname] as String,
    email: map[EvaluatorFields.email] as String,
    birthDate: map[EvaluatorFields.birthDate] as String,
    specialty: map[EvaluatorFields.specialty] as String,
    cpfOrNif: map[EvaluatorFields.cpf] as String,
    username: map[EvaluatorFields.username] as String,
    password: map[EvaluatorFields.password] as String,
    firstLogin: (map[EvaluatorFields.firstLogin] as int) == 1,
  );

  Map<String, dynamic> toMap() => {
    EvaluatorFields.id: evaluatorId,
    EvaluatorFields.name: name,
    EvaluatorFields.surname: surname,
    EvaluatorFields.email: email,
    EvaluatorFields.birthDate: birthDate,
    EvaluatorFields.specialty: specialty,
    EvaluatorFields.cpf: cpfOrNif,
    EvaluatorFields.username: username,
    EvaluatorFields.password: password,
    EvaluatorFields.firstLogin: firstLogin ? 1 : 0,
  };

  Map<String, dynamic> toJson() => {
    'evaluator_id': evaluatorId,
    'name': name,
    'surname': surname,
    'email': email,
    'birthDate': birthDate,
    'specialty': specialty,
    'cpfOrNif': cpfOrNif,
    'username': username,
    'password': password,
    'firstLogin': firstLogin,
  };

  factory EvaluatorModel.fromEntity(EvaluatorEntity entity) => EvaluatorModel(
    evaluatorId: entity.evaluatorId,
    name: entity.name,
    surname: entity.surname,
    email: entity.email,
    birthDate: entity.birthDate,
    specialty: entity.specialty,
    cpfOrNif: entity.cpfOrNif,
    username: entity.username,
    password: entity.password,
    firstLogin: entity.firstLogin,
  );

  factory EvaluatorModel.fromDTO(EvaluatorRegistrationData dto) {
    return EvaluatorModel(
      name: dto.name,
      surname: dto.surname,
      email: dto.email,
      birthDate: dto.birthDate,
      specialty: dto.specialty,
      cpfOrNif: dto.cpf,
      username: dto.username,
      password: dto.password,
      firstLogin: dto.firstLogin,
    );
  }

  EvaluatorModel copyWith({
    int? evaluatorId,
    String? name,
    String? surname,
    String? email,
    String? birthDate,
    String? specialty,
    String? cpfOrNif,
    String? username,
    String? password,
    bool? firstLogin,
  }) {
    return EvaluatorModel(
      evaluatorId: evaluatorId ?? this.evaluatorId,
      name: name ?? this.name,
      surname: surname ?? this.surname,
      email: email ?? this.email,
      birthDate: birthDate ?? this.birthDate,
      specialty: specialty ?? this.specialty,
      cpfOrNif: cpfOrNif ?? this.cpfOrNif,
      username: username ?? this.username,
      password: password ?? this.password,
      firstLogin: firstLogin ?? this.firstLogin,
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\data\evaluator_model_extensions.dart ===
// import '../../../core/deterministic_encryption_helper.dart';
// import '../application/evaluator_secure_service.dart';
// import 'evaluator_model.dart';
//
// /// Encrypt PII and hash password
// extension EvaluatorModelSecurity on EvaluatorModel {
//   EvaluatorModel encryptedAndHashed() {
//     return EvaluatorModel(
//       evaluatorId: evaluatorId,
//       name: DeterministicEncryptionHelper.encryptText(name),
//       surname: DeterministicEncryptionHelper.encryptText(surname),
//       email: DeterministicEncryptionHelper.encryptText(email),
//       birthDate: DeterministicEncryptionHelper.encryptText(birthDate),
//       specialty: DeterministicEncryptionHelper.encryptText(specialty),
//       cpfOrNif: DeterministicEncryptionHelper.encryptText(cpfOrNif),
//       username: DeterministicEncryptionHelper.encryptText(username),
//       password: EvaluatorSecureService.hash(password),
//       firstLogin: firstLogin,
//     );
//   }
// }
//
// extension EvaluatorModelDecryption on EvaluatorModel {
//   EvaluatorModel decrypted() {
//     return EvaluatorModel(
//       evaluatorId: evaluatorId,
//       name: DeterministicEncryptionHelper.decryptText(name),
//       surname: DeterministicEncryptionHelper.decryptText(surname),
//       email: DeterministicEncryptionHelper.decryptText(email),
//       birthDate: DeterministicEncryptionHelper.decryptText(birthDate),
//       specialty: DeterministicEncryptionHelper.decryptText(specialty),
//       cpfOrNif: DeterministicEncryptionHelper.decryptText(cpfOrNif),
//       username: DeterministicEncryptionHelper.decryptText(username),
//       password: password,
//       firstLogin: firstLogin,
//     );
//   }
// }


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\data\evaluator_remote_datasource.dart ===
import 'dart:convert';
import 'package:http/http.dart' as http;
import '../../../core/logger/app_logger.dart';
import 'evaluator_model.dart';

class EvaluatorRemoteDataSource {
  final String baseUrl = 'https://api.example.com/evaluators';

  Future<List<EvaluatorModel>> fetchAllEvaluators() async {
    final url = Uri.parse(baseUrl);
    AppLogger.info('HTTP GET ‚Üí $url');
    try {
      final response = await http.get(url);
      AppLogger.info('HTTP ${response.statusCode} ‚Üê $url');
      if (response.statusCode == 200) {
        final List<dynamic> data = jsonDecode(response.body);
        return data.map((e) => EvaluatorModel.fromMap(e)).toList();
      } else {
        AppLogger.warning('Failed to fetch evaluators: ${response.body}');
        return [];
      }
    } catch (e, s) {
      AppLogger.error('Error fetching evaluators from API', e, s);
      return [];
    }
  }

  Future<void> createEvaluator(EvaluatorModel evaluator) async {
    final url = Uri.parse(baseUrl);
    final body = jsonEncode(evaluator.toMap());
    AppLogger.info('HTTP POST ‚Üí $url | body: $body');
    try {
      final response = await http.post(
        url,
        headers: {'Content-Type': 'application/json'},
        body: body,
      );
      AppLogger.info('HTTP ${response.statusCode} ‚Üê $url');
      if (response.statusCode >= 400) {
        AppLogger.warning('Error creating evaluator: ${response.body}');
      }
    } catch (e, s) {
      AppLogger.error('HTTP POST failed for evaluator ${evaluator.email}', e, s);
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\data\evaluator_repository_impl.dart ===
import '../../../core/logger/app_logger.dart';
import '../domain/evaluator_repository.dart';
import '../domain/evaluator_registration_data.dart';
import 'evaluator_local_datasource.dart';
import 'evaluator_remote_datasource.dart';
import 'evaluator_model.dart';

class EvaluatorRepositoryImpl implements EvaluatorRepository {
  final EvaluatorLocalDataSource? _local;
  final EvaluatorRemoteDataSource? _remote;
  final bool _isLocal;

  EvaluatorRepositoryImpl.local(this._local)
      : _remote = null,
        _isLocal = true {
    AppLogger.info('[REPO] EvaluatorRepositoryImpl running in LOCAL mode');
  }

  EvaluatorRepositoryImpl.remote(this._remote)
      : _local = null,
        _isLocal = false {
    AppLogger.info('[REPO] EvaluatorRepositoryImpl running in REMOTE mode');
  }

  String get _mode => _isLocal ? 'LOCAL' : 'REMOTE';

  Future<List<EvaluatorModel>> getAllEvaluators() async {
    AppLogger.info('[REPO] Fetching all evaluators ($_mode)');
    try {
      if (_isLocal) {
        final list = await _local!.getAll();
        AppLogger.db('Fetched ${list.length} evaluators from local DB');
        return list;
      } else {
        final list = await _remote!.fetchAllEvaluators();
        AppLogger.info('Fetched ${list.length} evaluators from API');
        return list;
      }
    } catch (e, s) {
      AppLogger.error('[REPO] Error fetching all evaluators ($_mode)', e, s);
      rethrow;
    }
  }

  Future<void> addEvaluator(EvaluatorModel evaluator) async {
    AppLogger.info('[REPO] Adding evaluator ${evaluator.email} ($_mode)');
    try {
      if (_isLocal) {
        await _local!.insert(evaluator);
        AppLogger.db('[REPO] Evaluator inserted into local DB');
      } else {
        await _remote!.createEvaluator(evaluator);
        AppLogger.info('[REPO] Evaluator created remotely');
      }
    } catch (e, s) {
      AppLogger.error('[REPO] Failed to add evaluator', e, s);
      rethrow;
    }
  }

  @override
  Future<void> insertEvaluator(EvaluatorRegistrationData data) async {
    final model = EvaluatorModel.fromDTO(data);
    await _local!.insert(model); // Local insert secures data internally.
  }

  @override
  Future<bool> hasAnyEvaluatorAdmin() async {
    return await _local!.hasAnyEvaluatorAdmin();
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\domain\evaluator_entity.dart ===
class EvaluatorEntity {
  final int? evaluatorId;
  final String name;
  final String surname;
  final String email;
  final String birthDate;
  final String specialty;
  final String cpfOrNif;
  final String username;
  final String password;
  final bool firstLogin;

  const EvaluatorEntity({
    this.evaluatorId,
    required this.name,
    required this.surname,
    required this.email,
    required this.birthDate,
    required this.specialty,
    required this.cpfOrNif,
    required this.username,
    required this.password,
    this.firstLogin = true,
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\domain\evaluator_registration_data.dart ===
class EvaluatorRegistrationData {
  final String name;
  final String surname;
  final String email;
  final String birthDate;
  final String specialty;
  final String cpf;
  final String username;
  final String password;
  final bool isAdmin;
  final bool firstLogin;

  EvaluatorRegistrationData({
    required this.name,
    required this.surname,
    required this.email,
    required this.birthDate,
    required this.specialty,
    required this.cpf,
    required this.username,
    required this.password,
    this.isAdmin = false,
    this.firstLogin = true,
  });

  Map<String, dynamic> toMap() => {
    'name': name,
    'surname': surname,
    'email': email,
    'birthDate': birthDate,
    'specialty': specialty,
    'cpfOrNif': cpf,
    'username': username,
    'password': password,
    'isAdmin': isAdmin,
    'firstLogin': firstLogin,
  };
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\domain\evaluator_repository.dart ===
import 'evaluator_registration_data.dart';

abstract class EvaluatorRepository {
  Future<void> insertEvaluator(EvaluatorRegistrationData data);
  Future<bool> hasAnyEvaluatorAdmin();
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\presentation\evaluator_registration_form.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:intl/intl.dart';
import 'package:syncfusion_flutter_datepicker/datepicker.dart';
import 'package:go_router/go_router.dart';

import '../../../../core/logger/app_logger.dart';
import '../../../../core/theme/app_colors.dart';
import '../domain/evaluator_registration_data.dart';
import 'evaluator_registration_provider.dart';

class EvaluatorRegistrationForm extends HookConsumerWidget {
  const EvaluatorRegistrationForm({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    AppLogger.nav('Opened EvaluatorRegistrationForm');

    final formKey = useMemoized(() => GlobalKey<FormState>());
    final nameController = useTextEditingController();
    final surnameController = useTextEditingController();
    final emailController = useTextEditingController();
    final usernameController = useTextEditingController();
    final cpfController = useTextEditingController();
    final passwordController = useTextEditingController();
    final confirmPasswordController = useTextEditingController();
    final specialtyController = useTextEditingController();

    final selectedDate = useState<DateTime?>(null);
    final showPassword = useState(false);
    final showConfirmPassword = useState(false);
    final manualUsername = useState(false);
    final isDateExpanded = useState(false);
    final isRedirecting = useState(false);

    final state = ref.watch(evaluatorRegistrationProvider);
    final notifier = ref.read(evaluatorRegistrationProvider.notifier);

    // auto-generate username
    useEffect(() {
      void listener() {
        if (!manualUsername.value) {
          final name = nameController.text.trim();
          final surname = surnameController.text.trim();
          if (name.isNotEmpty && surname.isNotEmpty) {
            usernameController.text =
            "${name.toLowerCase()}_${surname.toLowerCase()}";
          } else {
            usernameController.clear();
          }
        }
      }

      nameController.addListener(listener);
      surnameController.addListener(listener);
      return () {
        nameController.removeListener(listener);
        surnameController.removeListener(listener);
      };
    }, [manualUsername.value]);

    // Listen for registration result
    ref.listen<AsyncValue<EvaluatorRegistrationState>>(
      evaluatorRegistrationProvider,
          (prev, next) {
        next.whenData((value) async {
          if (value == EvaluatorRegistrationState.success) {
            AppLogger.info('Evaluator registered successfully ‚Äî redirecting');
            isRedirecting.value = true;

            displayInfoBar(
              context,
              builder: (ctx, close) => InfoBar(
                title: const Text("Avaliador registrado!"),
                content:
                const Text("Voc√™ ser√° redirecionado para o home!"),
                severity: InfoBarSeverity.success,
                isLong: true,
                onClose: close,
              ),
            );

            await Future.delayed(const Duration(seconds: 2));
            if (context.mounted) {
              AppLogger.nav('Navigating to /home after registration');
              context.go('/login');
            }
          }
        });
      },
    );

    Future<void> _submit() async {
      if (!formKey.currentState!.validate() || selectedDate.value == null) {
        AppLogger.warning('Registration form validation failed');
        return;
      }

      final data = EvaluatorRegistrationData(
        name: nameController.text,
        surname: surnameController.text,
        email: emailController.text,
        birthDate: DateFormat('yyyy-MM-dd').format(selectedDate.value!),
        cpf: cpfController.text,
        username: usernameController.text,
        password: passwordController.text,
        specialty: specialtyController.text,
        isAdmin: false,
      );

      AppLogger.info('Submitting evaluator registration for ${data.email}');
      await notifier.registerEvaluator(data);
    }

    return Container(
      padding: const EdgeInsets.all(24),
      decoration: BoxDecoration(
        gradient: const LinearGradient(
          colors: [Color(0xFF141E30), Color(0xFF243B55)],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        borderRadius: BorderRadius.circular(16),
      ),
      child: Form(
        key: formKey,
        child: ListView(
          shrinkWrap: true,
          children: [
            const Text(
              "Registro de Administrador",
              textAlign: TextAlign.center,
              style: TextStyle(
                fontSize: 28,
                fontWeight: FontWeight.bold,
                color: AppColors.softWhite,
              ),
            ),
            const SizedBox(height: 24),

            // name + surname
            Row(
              children: [
                Expanded(child: _buildTextField("Nome", nameController)),
                const SizedBox(width: 12),
                Expanded(child: _buildTextField("Sobrenome", surnameController)),
              ],
            ),

            // email + cpf
            Row(
              children: [
                Expanded(child: _buildTextField("Email", emailController)),
                const SizedBox(width: 12),
                Expanded(child: _buildTextField("CPF/NIF", cpfController)),
              ],
            ),

            // username + checkbox
            Padding(
              padding: const EdgeInsets.only(bottom: 16),
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.end,
                children: [
                  Expanded(
                    child: InfoLabel(
                      label: "Usu√°rio",
                      child: TextFormBox(
                        controller: usernameController,
                        enabled: manualUsername.value,
                        validator: (v) =>
                        v!.isEmpty ? "Campo obrigat√≥rio" : null,
                      ),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Padding(
                    padding: const EdgeInsets.only(bottom: 8),
                    child: Checkbox(
                      content: const Text("Definir usu√°rio manualmente"),
                      checked: manualUsername.value,
                      onChanged: (v) {
                        manualUsername.value = v ?? false;
                        AppLogger.debug(
                            'Manual username mode: ${manualUsername.value}');
                      },
                    ),
                  ),
                ],
              ),
            ),

            // password + confirm password
            Row(
              children: [
                Expanded(
                  child: _buildPasswordField(
                    "Senha",
                    passwordController,
                    showPassword,
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: _buildPasswordField(
                    "Confirmar Senha",
                    confirmPasswordController,
                    showConfirmPassword,
                    confirm: passwordController,
                  ),
                ),
              ],
            ),

            const SizedBox(height: 16),

            // date picker
            InfoLabel(
              label: "Data de Nascimento",
              child: Expander(
                key: ValueKey(isDateExpanded.value),
                initiallyExpanded: isDateExpanded.value,
                onStateChanged: (open) =>
                isDateExpanded.value = open,
                header: Text(
                  selectedDate.value != null
                      ? DateFormat('dd/MM/yyyy')
                      .format(selectedDate.value!)
                      : "Selecionar data",
                ),
                content: SfDateRangePicker(
                  onSelectionChanged: (args) {
                    selectedDate.value = args.value;
                    isDateExpanded.value = false;
                    AppLogger.debug(
                        'Selected birth date: ${selectedDate.value}');
                  },
                  selectionMode: DateRangePickerSelectionMode.single,
                  initialSelectedDate: selectedDate.value,
                  showNavigationArrow: true,
                  todayHighlightColor: AppColors.primary,
                  selectionColor: AppColors.primary,
                ),
              ),
            ),

            const SizedBox(height: 16),
            _buildTextField("Especialidade", specialtyController),
            const SizedBox(height: 24),

            FilledButton(
              style: ButtonStyle(
                backgroundColor: ButtonState.all(AppColors.primary),
              ),
              onPressed: state.isLoading || isRedirecting.value ? null : _submit,
              child: (state.isLoading || isRedirecting.value)
                  ? const ProgressRing()
                  : const Text("Registrar"),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildTextField(String label, TextEditingController controller) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12),
      child: InfoLabel(
        label: label,
        child: TextFormBox(
          controller: controller,
          validator: (v) => v!.isEmpty ? "Campo obrigat√≥rio" : null,
        ),
      ),
    );
  }

  Widget _buildPasswordField(String label, TextEditingController controller,
      ValueNotifier<bool> show, {TextEditingController? confirm}) {
    return InfoLabel(
      label: label,
      child: TextFormBox(
        controller: controller,
        obscureText: !show.value,
        placeholder: label == "Senha"
            ? "Digite a senha"
            : "Repita a senha",
        validator: (v) {
          if (v == null || v.isEmpty) return "Campo obrigat√≥rio";
          if (label == "Confirmar Senha" &&
              v != confirm?.text) {
            return "As senhas n√£o coincidem";
          }
          if (label == "Senha" && v.length < 6) {
            return "M√≠nimo 6 caracteres";
          }
          return null;
        },
        suffix: IconButton(
          icon: Icon(show.value
              ? FluentIcons.hide3
              : FluentIcons.view),
          onPressed: () => show.value = !show.value,
        ),
      ),
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\presentation\evaluator_registration_provider.dart ===
import 'package:hooks_riverpod/hooks_riverpod.dart';
import '../../../core/logger/app_logger.dart';
import '../application/evaluator_notifier.dart';
import '../domain/evaluator_registration_data.dart';
import '../domain/evaluator_repository.dart';

enum EvaluatorRegistrationState { initial, loading, success, error }

class EvaluatorRegistrationNotifier
    extends AsyncNotifier<EvaluatorRegistrationState> {
  late final EvaluatorRepository _repository;

  @override
  Future<EvaluatorRegistrationState> build() async {
    _repository = await ref.watch(evaluatorRepositoryProvider.future);
    AppLogger.info('EvaluatorRegistrationNotifier initialized');
    return EvaluatorRegistrationState.initial;
  }

  Future<void> registerEvaluator(EvaluatorRegistrationData data) async {
    AppLogger.info('Starting evaluator registration for ${data.email}');
    state = const AsyncValue.loading();

    try {
      await _repository.insertEvaluator(data);
      AppLogger.info('Evaluator ${data.email} registered successfully');
      state = const AsyncValue.data(EvaluatorRegistrationState.success);
    } catch (e, s) {
      AppLogger.error('Error registering evaluator ${data.email}', e, s);
      state = const AsyncValue.data(EvaluatorRegistrationState.error);
    }
  }
}

final evaluatorRegistrationProvider =
AsyncNotifierProvider<EvaluatorRegistrationNotifier,
    EvaluatorRegistrationState>(
  EvaluatorRegistrationNotifier.new,
);


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\presentation\evaluator_registration_screen.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import '../../../../core/logger/app_logger.dart';
import '../../../../core/theme/app_colors.dart';
import 'evaluator_registration_form.dart';

class EvaluatorRegistrationScreen extends StatelessWidget {
  const EvaluatorRegistrationScreen({super.key});

  @override
  Widget build(BuildContext context) {
    AppLogger.nav('Opened EvaluatorRegistrationScreen');
    return NavigationView(
      content: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [
              AppColors.midnightBlue,
              AppColors.deepSeaBlue,
              AppColors.steelBlue,
            ],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: Center(
          child: Padding(
            padding: const EdgeInsets.all(24),
            child: ConstrainedBox(
              constraints: const BoxConstraints(maxWidth: 700),
              child: const EvaluatorRegistrationForm(),
            ),
          ),
        ),
      ),
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\presentation\providers\evaluator_provider.dart ===
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../../core/database/prod_database_helper.dart';
import '../../data/evaluator_local_datasource.dart';
import '../../data/evaluator_model.dart';

final currentEvaluatorProvider = FutureProvider<EvaluatorModel?>((ref) async {
  final db = await ProdDatabaseHelper.instance.database;
  final ds = EvaluatorLocalDataSource(db);
  return await ds.getFirstEvaluator();
});


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\home\home_providers.dart ===
import 'package:hooks_riverpod/hooks_riverpod.dart';

/// Controls the selected tab index of the HomeScreen
final homeNavigationProvider = NotifierProvider<HomeNavigationNotifier, int>(
  HomeNavigationNotifier.new,
);

class HomeNavigationNotifier extends Notifier<int> {
  @override
  int build() => 0;

  void setIndex(int index) {
    state = index;
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\home\home_screen.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

import '../../providers/providers.dart';
import '../auth/data/auth_local_datasource.dart';
import '../auth/data/auth_repository_impl.dart';
import '../participant/presentation/create_participant_screen.dart';
import '../participant/presentation/participant_list_screen.dart';
import '../../core/database/prod_database_helper.dart';

import 'home_providers.dart';

class HomeScreen extends HookConsumerWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedIndex = ref.watch(homeNavigationProvider);

    return NavigationView(
      appBar: const NavigationAppBar(title: Text('CogniVoice Home')),
      pane: NavigationPane(
        selected: selectedIndex,
        onChanged: (index) => ref
            .read(homeNavigationProvider.notifier)
            .setIndex(index), // ‚úÖ Update provider
        displayMode: PaneDisplayMode.auto,
        items: [
          PaneItem(
            icon: const Icon(FluentIcons.home),
            title: const Text('Dashboard'),
            body: const DashboardContent(),
          ),
          PaneItem(
            icon: const Icon(FluentIcons.contact),
            title: const Text('Participantes'),
            body: ParticipantListScreen(),
          ),
          PaneItem(
            icon: const Icon(FluentIcons.add_friend),
            title: const Text('Criar Paciente'),
            body: const CreatePatientScreen(),
          ),
        ],
        footerItems: [
          PaneItemSeparator(),
          PaneItem(
            icon: const Icon(FluentIcons.sign_out),
            title: const Text('Sair'),
            onTap: () async {
              final db = await ProdDatabaseHelper.instance.database;
              final repository = AuthRepositoryImpl(AuthLocalDataSource(db));
              await repository.signOut();
              ref.read(currentUserProvider.notifier).setUser(null);
              if (context.mounted) context.go('/login');
            },
            body: const SizedBox.shrink(),
          ),
        ],
      ),
    );
  }
}

class DashboardContent extends StatelessWidget {
  const DashboardContent({super.key});

  @override
  Widget build(BuildContext context) {
    return ScaffoldPage.scrollable(
      header: PageHeader(
        title: Text(
          'Bem-vindo!',
          style: FluentTheme.of(context).typography.title,
        ),
      ),
      children: const [Text('Aqui √© o conte√∫do principal do dashboard.')],
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module\data\module_constants.dart ===
// data/module_constants.dart

import '../../../core/constants/database_constants.dart';

class ModuleFields {
  static const String id = 'module_id';
  static const String title = 'title';

  static const List<String> values = [id, title];
}

const scriptCreateTableModules = '''
CREATE TABLE ${Tables.modules} (
  ${ModuleFields.id} INTEGER PRIMARY KEY AUTOINCREMENT,
  ${ModuleFields.title} TEXT NOT NULL
)
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module\data\module_local_datasource.dart ===
// data/module_local_datasource.dart

import 'package:sqflite_common/sqlite_api.dart';

import '../../../core/constants/database_constants.dart';
import '../../../core/database/base_database_helper.dart';
import '../../../core/logger/app_logger.dart';
import 'module_model.dart';
import 'module_constants.dart';

class ModuleLocalDataSource {
  final BaseDatabaseHelper dbHelper;

  ModuleLocalDataSource({required this.dbHelper});

  Future<Database> get _db async => dbHelper.database;

  Future<int?> insertModule(ModuleModel model) async {
    AppLogger.db('[ModuleLocalDataSource] Inserting module "${model.title}"');
    try {
      final db = await _db;
      final id = await db.insert(
        Tables.modules,
        model.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
      AppLogger.db('[ModuleLocalDataSource] Inserted with ID=$id');
      return id;
    } catch (e, s) {
      AppLogger.error('[ModuleLocalDataSource] Failed to insert module', e, s);
      return null;
    }
  }

  Future<List<ModuleModel>> getAllModules() async {
    final db = await _db;
    final rows = await db.query(Tables.modules);
    return rows.map(ModuleModel.fromMap).toList();
  }

  Future<ModuleModel?> getModuleById(int id) async {
    final db = await _db;
    final rows = await db.query(
      Tables.modules,
      where: '${ModuleFields.id} = ?',
      whereArgs: [id],
    );
    return rows.isNotEmpty ? ModuleModel.fromMap(rows.first) : null;
  }

  Future<ModuleModel?> getModuleByTitle(String title) async {
    final db = await _db;
    final rows = await db.query(
      Tables.modules,
      where: '${ModuleFields.title} = ?',
      whereArgs: [title],
    );
    return rows.isNotEmpty ? ModuleModel.fromMap(rows.first) : null;
  }

  Future<int> updateModule(ModuleModel model) async {
    final db = await _db;
    return await db.update(
      Tables.modules,
      model.toMap(),
      where: '${ModuleFields.id} = ?',
      whereArgs: [model.moduleID],
    );
  }

  Future<int> deleteModule(int id) async {
    final db = await _db;
    return await db.delete(
      Tables.modules,
      where: '${ModuleFields.id} = ?',
      whereArgs: [id],
    );
  }

  Future<int> getNumberOfModules() async {
    final db = await _db;
    final result = await db.rawQuery('SELECT COUNT(*) AS count FROM ${Tables.modules}');
    final count = result.first['count'];
    return count is int ? count : int.tryParse(count.toString()) ?? 0;
  }


  Future<bool> exists(int id) async {
    final db = await _db;
    final result = await db.query(
      Tables.modules,
      where: '${ModuleFields.id} = ?',
      whereArgs: [id],
      limit: 1,
    );
    return result.isNotEmpty;
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module\data\module_model.dart ===
// data/module_model.dart

import '../domain/module_entity.dart';
import 'module_constants.dart';

class ModuleModel extends ModuleEntity {
  const ModuleModel({
    int? moduleID,
    required String title,
  }) : super(moduleID: moduleID, title: title);

  factory ModuleModel.fromMap(Map<String, dynamic> map) {
    return ModuleModel(
      moduleID: map[ModuleFields.id] as int?,
      title: map[ModuleFields.title] as String,
    );
  }

  Map<String, dynamic> toMap() => {
    ModuleFields.id: moduleID,
    ModuleFields.title: title,
  };

  factory ModuleModel.fromEntity(ModuleEntity entity) {
    return ModuleModel(
      moduleID: entity.moduleID,
      title: entity.title,
    );
  }

  ModuleEntity toEntity() => ModuleEntity(
    moduleID: moduleID,
    title: title,
  );
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module\data\module_repository_impl.dart ===
// data/module_repository_impl.dart

import '../../task/data/task_local_datasource.dart';
import '../domain/module_entity.dart';
import '../domain/module_repository.dart';
import 'module_local_datasource.dart';
import 'module_model.dart';

class ModuleRepositoryImpl implements ModuleRepository {
  final ModuleLocalDataSource local;
  final TaskLocalDataSource taskLocal;

  ModuleRepositoryImpl({
    required this.local,
    required this.taskLocal,
  });

  @override
  Future<int?> insertModule(ModuleEntity module) {
    return local.insertModule(ModuleModel.fromEntity(module));
  }

  @override
  Future<List<ModuleEntity>> getAllModules() async {
    final modules = await local.getAllModules();
    return modules.map((m) => m.toEntity()).toList();
  }

  @override
  Future<ModuleEntity?> getModuleById(int id) async {
    final module = await local.getModuleById(id);
    if (module == null) return null;
    final tasks = await taskLocal.getTasksByModuleId(id);
    return module.toEntity().copyWith(tasks: tasks);
  }

  @override
  Future<ModuleEntity?> getModuleByTitle(String title) async {
    final module = await local.getModuleByTitle(title);
    if (module == null || module.moduleID == null) return null;
    final tasks = await taskLocal.getTasksByModuleId(module.moduleID!);
    return module.toEntity().copyWith(tasks: tasks);
  }

  @override
  Future<int> updateModule(ModuleEntity module) {
    return local.updateModule(ModuleModel.fromEntity(module));
  }

  @override
  Future<int> deleteModule(int id) {
    return local.deleteModule(id);
  }

  @override
  Future<int> getNumberOfModules() {
    return local.getNumberOfModules();
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module\domain\module_entity.dart ===
// domain/module_entity.dart

import '../../task/domain/task_entity.dart';

class ModuleEntity {
  final int? moduleID;
  final String title;
  final List<TaskEntity> tasks;

  const ModuleEntity({
    this.moduleID,
    required this.title,
    this.tasks = const [],
  });

  ModuleEntity copyWith({
    int? moduleID,
    String? title,
    List<TaskEntity>? tasks,
  }) {
    return ModuleEntity(
      moduleID: moduleID ?? this.moduleID,
      title: title ?? this.title,
      tasks: tasks ?? this.tasks,
    );
  }

  Map<String, dynamic> toMap() => {
    'module_id': moduleID,
    'title': title,
  };

  factory ModuleEntity.fromMap(Map<String, dynamic> map) {
    return ModuleEntity(
      moduleID: map['module_id'] as int?,
      title: map['title'] as String,
    );
  }

  @override
  String toString() => 'ModuleEntity(id: $moduleID, title: $title)';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module\domain\module_repository.dart ===
// domain/module_repository.dart

import 'module_entity.dart';

abstract class ModuleRepository {
  Future<int?> insertModule(ModuleEntity module);
  Future<List<ModuleEntity>> getAllModules();
  Future<ModuleEntity?> getModuleById(int id);
  Future<ModuleEntity?> getModuleByTitle(String title);
  Future<int> updateModule(ModuleEntity module);
  Future<int> deleteModule(int id);
  Future<int> getNumberOfModules();
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module_instance\data\module_instance_constants.dart ===
import '../../../core/constants/database_constants.dart';
import '../../evaluation/data/evaluation_constants.dart';
import '../../module/data/module_constants.dart';

class ModuleInstanceFields {
  static const id = 'module_inst_id';
  static const moduleId = ModuleFields.id;
  static const evaluationId = EvaluationFields.id;
  static const status = 'status';

  static const values = [id, moduleId, evaluationId, status];
}

const scriptCreateTableModuleInstances = '''
CREATE TABLE ${Tables.moduleInstances} (
  ${ModuleInstanceFields.id} INTEGER PRIMARY KEY AUTOINCREMENT,
  ${ModuleInstanceFields.moduleId} INTEGER NOT NULL,
  ${ModuleInstanceFields.evaluationId} INTEGER NOT NULL,
  ${ModuleInstanceFields.status} INT NOT NULL CHECK(${ModuleInstanceFields.status} >= 1 AND ${ModuleInstanceFields.status} <= 3),
    FOREIGN KEY (${ModuleInstanceFields.moduleId}) REFERENCES ${Tables.modules}(${ModuleFields.id}),
  FOREIGN KEY (${ModuleInstanceFields.evaluationId}) REFERENCES ${Tables.evaluations}(${EvaluationFields.id})
)
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module_instance\data\module_instance_local_datasource.dart ===
import 'package:sqflite_common/sqlite_api.dart';
import '../../../core/constants/database_constants.dart';
import '../../../core/constants/enums/progress_status.dart';
import '../../../core/database/base_database_helper.dart';
import '../../../core/logger/app_logger.dart';
import '../../module/domain/module_entity.dart';
import 'module_instance_constants.dart';
import 'module_instance_model.dart';

class ModuleInstanceLocalDataSource {
  final BaseDatabaseHelper dbHelper;

  ModuleInstanceLocalDataSource({required this.dbHelper});

  Future<Database> get _db async => dbHelper.database;

  Future<int?> insertModuleInstance(ModuleInstanceModel instance) async {
    AppLogger.db('Inserting module instance for evaluationId=${instance.evaluationId}');
    try {
      final db = await _db;
      final id = await db.insert(
        Tables.moduleInstances,
        instance.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
      AppLogger.db('Module instance inserted (id=$id)');
      return id;
    } catch (e, s) {
      AppLogger.error('Error inserting module instance', e, s);
      return null;
    }
  }

  Future<ModuleInstanceModel?> getModuleInstanceById(int id) async {
    AppLogger.db('Fetching module instance ID=$id');
    try {
      final db = await _db;
      final maps = await db.query(
        Tables.moduleInstances,
        where: '${ModuleInstanceFields.id} = ?',
        whereArgs: [id],
      );
      return maps.isNotEmpty ? ModuleInstanceModel.fromMap(maps.first) : null;
    } catch (e, s) {
      AppLogger.error('Error fetching module instance ID=$id', e, s);
      return null;
    }
  }

  Future<List<ModuleInstanceModel>> getAllModuleInstances() async {
    AppLogger.db('Fetching all module instances');
    try {
      final db = await _db;
      final maps = await db.query(Tables.moduleInstances);
      AppLogger.db('Fetched ${maps.length} module instances');
      return maps.map(ModuleInstanceModel.fromMap).toList();
    } catch (e, s) {
      AppLogger.error('Error fetching all module instances', e, s);
      return [];
    }
  }

  Future<List<ModuleInstanceModel>> getModuleInstancesByEvaluationId(
      int evaluationId) async {
    AppLogger.db('Fetching module instances by evaluationId=$evaluationId (with JOIN to modules)');
    try {
      final db = await _db;
      final result = await db.rawQuery('''
      SELECT mi.*, m.title as module_title
      FROM ${Tables.moduleInstances} mi
      INNER JOIN ${Tables.modules} m
      ON mi.${ModuleInstanceFields.moduleId} = m.module_id
      WHERE mi.${ModuleInstanceFields.evaluationId} = ?
    ''', [evaluationId]);

      AppLogger.db('Fetched ${result.length} instances with module data');
      return result.map((row) {
        final model = ModuleInstanceModel.fromMap(row);
        return model.copyWith(
          module: ModuleEntity(
            moduleID: model.moduleId,
            title: row['module_title'] as String? ?? 'Sem t√≠tulo',
          ),
        );
      }).toList();
    } catch (e, s) {
      AppLogger.error('Error fetching instances with modules by evaluationId=$evaluationId', e, s);
      return [];
    }
  }


  Future<int> updateModuleInstance(ModuleInstanceModel instance) async {
    AppLogger.db('Updating module instance ID=${instance.id}');
    try {
      final db = await _db;
      final rows = await db.update(
        Tables.moduleInstances,
        instance.toMap(),
        where: '${ModuleInstanceFields.id} = ?',
        whereArgs: [instance.id],
      );
      AppLogger.db('Updated $rows row(s)');
      return rows;
    } catch (e, s) {
      AppLogger.error('Error updating module instance ID=${instance.id}', e, s);
      return 0;
    }
  }

  Future<int> deleteModuleInstance(int id) async {
    AppLogger.db('Deleting module instance ID=$id');
    try {
      final db = await _db;
      final count = await db.delete(
        Tables.moduleInstances,
        where: '${ModuleInstanceFields.id} = ?',
        whereArgs: [id],
      );
      AppLogger.db('Deleted $count module instance(s)');
      return count;
    } catch (e, s) {
      AppLogger.error('Error deleting module instance ID=$id', e, s);
      return 0;
    }
  }

  Future<int> getCount() async {
    AppLogger.db('Counting module instances');
    try {
      final db = await _db;
      final result = await db
          .rawQuery('SELECT COUNT(*) AS count FROM ${Tables.moduleInstances}');
      final count = (result.first['count'] as int?) ?? 0;
      AppLogger.db('Module instance count: $count');
      return count;
    } catch (e, s) {
      AppLogger.error('Error counting module instances', e, s);
      return 0;
    }
  }

  Future<int> setStatus(int instanceId, ModuleStatus status) async {
    AppLogger.db('Setting status=${status.name} for moduleInstanceId=$instanceId');
    try {
      final db = await _db;
      final rows = await db.update(
        Tables.moduleInstances,
        {ModuleInstanceFields.status: status.numericValue},
        where: '${ModuleInstanceFields.id} = ?',
        whereArgs: [instanceId],
      );
      AppLogger.db('Updated status for $rows row(s)');
      return rows;
    } catch (e, s) {
      AppLogger.error('Error setting status for moduleInstanceId=$instanceId', e, s);
      return 0;
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module_instance\data\module_instance_model.dart ===
import '../../../core/constants/enums/progress_status.dart';
import '../../module/domain/module_entity.dart';
import '../../module_instance/domain/module_instance_entity.dart';
import 'module_instance_constants.dart';

class ModuleInstanceModel extends ModuleInstanceEntity {
  const ModuleInstanceModel({
    super.id,
    required super.moduleId,
    required super.evaluationId,
    required super.status,
    super.module,
  });

  factory ModuleInstanceModel.fromMap(Map<String, dynamic> map) {
    return ModuleInstanceModel(
      id: map[ModuleInstanceFields.id] as int?,
      moduleId: map[ModuleInstanceFields.moduleId] as int,
      evaluationId: map[ModuleInstanceFields.evaluationId] as int,
      status: ModuleStatus.fromValue(map[ModuleInstanceFields.status] as int),
    );
  }

  Map<String, dynamic> toMap() => {
    ModuleInstanceFields.id: id,
    ModuleInstanceFields.moduleId: moduleId,
    ModuleInstanceFields.evaluationId: evaluationId,
    ModuleInstanceFields.status: status.numericValue,
  };

  factory ModuleInstanceModel.fromEntity(ModuleInstanceEntity entity) {
    return ModuleInstanceModel(
      id: entity.id,
      moduleId: entity.moduleId,
      evaluationId: entity.evaluationId,
      status: entity.status,
      module: entity.module,
    );
  }

  ModuleInstanceEntity toEntity() {
    return ModuleInstanceEntity(
      id: id,
      moduleId: moduleId,
      evaluationId: evaluationId,
      status: status,
      module: module,
    );
  }

  ModuleInstanceModel copyWith({
    int? id,
    int? moduleId,
    int? evaluationId,
    ModuleStatus? status,
    ModuleEntity? module,
  }) {
    return ModuleInstanceModel(
      id: id ?? this.id,
      moduleId: moduleId ?? this.moduleId,
      evaluationId: evaluationId ?? this.evaluationId,
      status: status ?? this.status,
      module: module ?? this.module,
    );
  }


}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module_instance\data\module_instance_repository_impl.dart ===
import '../../../core/constants/enums/progress_status.dart';
import '../domain/module_instance_repository.dart';
import '../domain/module_instance_entity.dart';
import 'module_instance_model.dart';
import 'module_instance_local_datasource.dart';

class ModuleInstanceRepositoryImpl implements ModuleInstanceRepository {
  final ModuleInstanceLocalDataSource localDataSource;

  ModuleInstanceRepositoryImpl({required this.localDataSource});

  @override
  Future<ModuleInstanceEntity?> createModuleInstance(
      ModuleInstanceEntity instance) async {
    final model = ModuleInstanceModel.fromEntity(instance);
    final id = await localDataSource.insertModuleInstance(model);
    if (id == null) return null;
    final created = await localDataSource.getModuleInstanceById(id);
    return created?.toEntity();
  }

  @override
  Future<ModuleInstanceEntity?> getModuleInstanceById(int id) async {
    final model = await localDataSource.getModuleInstanceById(id);
    return model?.toEntity();
  }

  @override
  Future<List<ModuleInstanceEntity>> getAllModuleInstances() async {
    final models = await localDataSource.getAllModuleInstances();
    return models.map((m) => m.toEntity()).toList();
  }

  @override
  Future<List<ModuleInstanceEntity>> getModuleInstancesByEvaluationId(
      int evaluationId) async {
    final models =
    await localDataSource.getModuleInstancesByEvaluationId(evaluationId);
    return models.map((m) => m.toEntity()).toList();
  }

  @override
  Future<int> updateModuleInstance(ModuleInstanceEntity instance) async {
    final model = ModuleInstanceModel.fromEntity(instance);
    return await localDataSource.updateModuleInstance(model);
  }

  @override
  Future<int> deleteModuleInstance(int id) async {
    return await localDataSource.deleteModuleInstance(id);
  }

  @override
  Future<int> getCount() async {
    return await localDataSource.getCount();
  }

  @override
  Future<int> setModuleInstanceStatus(int instanceId, ModuleStatus status) async {
    return await localDataSource.setStatus(instanceId, status);
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module_instance\domain\module_instance_entity.dart ===
import '../../../core/constants/enums/progress_status.dart';
import '../../module/domain/module_entity.dart';

class ModuleInstanceEntity {
  final int? id;
  final int moduleId;
  final int evaluationId;
  final ModuleStatus status;
  final ModuleEntity? module;

  const ModuleInstanceEntity({
    this.id,
    required this.moduleId,
    required this.evaluationId,
    this.status = ModuleStatus.pending,
    this.module,
  });

  ModuleInstanceEntity copyWith({
    int? id,
    int? moduleId,
    int? evaluationId,
    ModuleStatus? status,
    ModuleEntity? module,
  }) {
    return ModuleInstanceEntity(
      id: id ?? this.id,
      moduleId: moduleId ?? this.moduleId,
      evaluationId: evaluationId ?? this.evaluationId,
      status: status ?? this.status,
      module: module ?? this.module,
    );
  }

  @override
  String toString() =>
      'ModuleInstanceEntity(id: $id, moduleId: $moduleId, evaluationId: $evaluationId, status: $status)';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module_instance\domain\module_instance_repository.dart ===
import '../../../core/constants/enums/progress_status.dart';
import 'module_instance_entity.dart';

abstract class ModuleInstanceRepository {
  Future<ModuleInstanceEntity?> createModuleInstance(ModuleInstanceEntity instance);
  Future<ModuleInstanceEntity?> getModuleInstanceById(int id);
  Future<List<ModuleInstanceEntity>> getAllModuleInstances();
  Future<List<ModuleInstanceEntity>> getModuleInstancesByEvaluationId(int evaluationId);
  Future<int> updateModuleInstance(ModuleInstanceEntity instance);
  Future<int> deleteModuleInstance(int id);
  Future<int> getCount();
  Future<int> setModuleInstanceStatus(int instanceId, ModuleStatus status);
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module_instance\presentation\module_instance_provider.dart ===
import 'package:hooks_riverpod/hooks_riverpod.dart';
import '../../../core/database/prod_database_helper.dart';
import '../data/module_instance_local_datasource.dart';
import '../data/module_instance_repository_impl.dart';
import '../domain/module_instance_repository.dart';

final moduleInstanceDbHelperProvider = Provider((ref) {
  return ProdDatabaseHelper.instance;
});

final moduleInstanceRepositoryProvider = Provider<ModuleInstanceRepository>((ref) {
  final dbHelper = ref.watch(moduleInstanceDbHelperProvider);
  final local = ModuleInstanceLocalDataSource(dbHelper: dbHelper);
  return ModuleInstanceRepositoryImpl(localDataSource: local);
});


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\participant\data\participant_constants.dart ===
import '../../../core/constants/database_constants.dart';

class ParticipantFields {
  static const id = "participant_id";
  static const name = "name";
  static const surname = "surname";
  static const educationLevel = "education_level";
  static const sex = "sex";
  static const birthDate = "birth_date";
  static const laterality = "laterality";

  static const values = [
    id,
    name,
    surname,
    educationLevel,
    sex,
    birthDate,
    laterality,
  ];
}

const scriptCreateTableParticipants =
    '''
CREATE TABLE ${Tables.participants} (
  ${ParticipantFields.id} INTEGER PRIMARY KEY AUTOINCREMENT,
  ${ParticipantFields.name} TEXT NOT NULL,
  ${ParticipantFields.surname} TEXT NOT NULL,
  ${ParticipantFields.educationLevel} INT CHECK(${ParticipantFields.educationLevel} BETWEEN 1 AND 7),
  ${ParticipantFields.sex} INT CHECK(${ParticipantFields.sex} IN (1, 2, 3)),
  ${ParticipantFields.birthDate} TIMESTAMP,
  ${ParticipantFields.laterality} INT NOT NULL
);
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\participant\data\participant_local_datasource.dart ===
import 'package:sqflite_common/sqlite_api.dart';
import '../../../core/constants/database_constants.dart';
import '../../../core/database/base_database_helper.dart';
import '../../../core/logger/app_logger.dart';
import '../../../core/constants/enums/laterality_enums.dart';
import '../../../core/constants/enums/person_enums.dart';
import '../../../shared/encryption/deterministic_encryption_helper.dart';
import '../data/participant_constants.dart';
import '../domain/participant_entity.dart';

class ParticipantLocalDataSource {
  final BaseDatabaseHelper dbHelper;

  ParticipantLocalDataSource({required this.dbHelper});

  Future<Database> get _db async => dbHelper.database;

  Future<int?> insertParticipant(
    DatabaseExecutor txn,
    Map<String, dynamic> data,
  ) async {
    // Make a mutable copy so we don't mutate caller's map.
    final payload = Map<String, dynamic>.from(data);

    // Normalize enums / types to what SQLite understands.

    // laterality: required, stored as int
    if (payload.containsKey(ParticipantFields.laterality)) {
      final value = payload[ParticipantFields.laterality];
      if (value is Laterality) {
        payload[ParticipantFields.laterality] = value.numericValue;
      }
    } else {
      // Fallback for legacy tests/callers that didn't set laterality.
      // Pick a sensible default (or change to whatever your domain expects).
      payload[ParticipantFields.laterality] =
          Laterality.ambidextrous.numericValue;
    }

    // sex may be passed as enum or int
    if (payload[ParticipantFields.sex] is Sex) {
      payload[ParticipantFields.sex] =
          (payload[ParticipantFields.sex] as Sex).numericValue;
    }

    // education_level may be passed as enum or int
    if (payload[ParticipantFields.educationLevel] is EducationLevel) {
      payload[ParticipantFields.educationLevel] =
          (payload[ParticipantFields.educationLevel] as EducationLevel)
              .numericValue;
    }

    AppLogger.db(
      'ParticipantLocalDataSource.insertParticipant ‚Üí name=${payload[ParticipantFields.name]}',
    );

    try {
      final id = await txn.insert(Tables.participants, payload);
      AppLogger.db(
        'ParticipantLocalDataSource.insertParticipant ‚Üí inserted with ID=$id',
      );
      return id;
    } catch (e, s) {
      AppLogger.error(
        'ParticipantLocalDataSource.insertParticipant ‚Üí error inserting participant',
        e,
        s,
      );
      return null;
    }
  }

  Future<List<ParticipantEntity>> getAllParticipants() async {
    AppLogger.db('ParticipantLocalDataSource.getAllParticipants ‚Üí querying DB');
    final db = await _db;
    final maps = await db.query(Tables.participants);
    final participants = maps.map((map) {
      final entity = ParticipantEntity.fromMap(map);
      return entity.copyWith(
        name: DeterministicEncryptionHelper.decryptText(entity.name),
        surname: DeterministicEncryptionHelper.decryptText(entity.surname),
      );
    }).toList();

    AppLogger.db(
      'ParticipantLocalDataSource.getAllParticipants ‚Üí mapped ${participants.length} participants',
    );
    return participants;
  }

  Future<ParticipantEntity?> getById(int id) async {
    AppLogger.db('ParticipantLocalDataSource.getById ‚Üí id=$id');
    final db = await _db;
    final result = await db.query(
      Tables.participants,
      where: '${ParticipantFields.id} = ?',
      whereArgs: [id],
    );

    if (result.isEmpty) {
      AppLogger.warning(
        'ParticipantLocalDataSource.getById ‚Üí no participant found for id=$id',
      );
      return null;
    }

    final participant = ParticipantEntity.fromMap(result.first);
    AppLogger.db(
      'ParticipantLocalDataSource.getById ‚Üí found participant id=$id',
    );
    return participant;
  }

  Future<void> deleteParticipant(int id) async {
    AppLogger.db('ParticipantLocalDataSource.deleteParticipant ‚Üí id=$id');
    final db = await _db;
    try {
      final count = await db.delete(
        Tables.participants,
        where: '${ParticipantFields.id} = ?',
        whereArgs: [id],
      );
      AppLogger.db(
        'ParticipantLocalDataSource.deleteParticipant ‚Üí affected rows=$count for id=$id',
      );
    } catch (e, s) {
      AppLogger.error(
        'ParticipantLocalDataSource.deleteParticipant ‚Üí error deleting id=$id',
        e,
        s,
      );
    }
  }

  Future<List<ParticipantEntity>> getParticipantsByEvaluatorId(
    int evaluatorId,
  ) async {
    AppLogger.db(
      'ParticipantLocalDataSource.getParticipantsByEvaluatorId ‚Üí evaluatorId=$evaluatorId',
    );
    final db = await _db;

    // Join participants and evaluations to filter by evaluator_id
    final query =
        '''
      SELECT p.* 
      FROM ${Tables.participants} p
      INNER JOIN ${Tables.evaluations} e ON p.${ParticipantFields.id} = e.participant_id
      WHERE e.evaluator_id = ?
    ''';

    final maps = await db.rawQuery(query, [evaluatorId]);
    final participants = maps.map((map) {
      final entity = ParticipantEntity.fromMap(map);
      return entity.copyWith(
        name: DeterministicEncryptionHelper.decryptText(entity.name),
        surname: DeterministicEncryptionHelper.decryptText(entity.surname),
      );
    }).toList();


    AppLogger.db(
      'ParticipantLocalDataSource.getParticipantsByEvaluatorId ‚Üí found ${participants.length} participants',
    );
    return participants;
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\participant\data\participant_repository_impl.dart ===
import '../../../core/logger/app_logger.dart';
import '../../participant/domain/participant_entity.dart';
import '../../participant/domain/participant_repository.dart';
import 'participant_local_datasource.dart';

class ParticipantRepositoryImpl implements ParticipantRepository {
  final ParticipantLocalDataSource local;

  ParticipantRepositoryImpl({required this.local});

  @override
  Future<void> insertParticipant(ParticipantEntity participant) async {
    AppLogger.db(
      'ParticipantRepositoryImpl.insertParticipant ‚Üí name=${participant.name} ${participant.surname}',
    );
    // Uses a DB/txn-aware method in the local data source
    final db = await local.dbHelper.database;
    await local.insertParticipant(db, participant.toMap());
  }

  @override
  Future<List<ParticipantEntity>> getAllParticipants() async {
    AppLogger.db('ParticipantRepositoryImpl.getAllParticipants ‚Üí fetching');
    final result = await local.getAllParticipants();
    AppLogger.db(
      'ParticipantRepositoryImpl.getAllParticipants ‚Üí fetched ${result.length} participants',
    );
    return result;
  }

  @override
  Future<ParticipantEntity?> getById(int id) async {
    AppLogger.db('ParticipantRepositoryImpl.getById ‚Üí id=$id');
    final participant = await local.getById(id);
    if (participant == null) {
      AppLogger.warning('ParticipantRepositoryImpl.getById ‚Üí not found id=$id');
    }
    return participant;
  }

  @override
  Future<void> deleteParticipant(int id) async {
    AppLogger.db('ParticipantRepositoryImpl.deleteParticipant ‚Üí id=$id');
    await local.deleteParticipant(id);
  }

  @override
  Future<List<ParticipantEntity>> getParticipantsByEvaluatorId(
    int evaluatorId,
  ) async {
    AppLogger.db(
      'ParticipantRepositoryImpl.getParticipantsByEvaluatorId ‚Üí evaluatorId=$evaluatorId',
    );
    return local.getParticipantsByEvaluatorId(evaluatorId);
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\participant\domain\participant_entity.dart ===
import '../../../core/constants/enums/laterality_enums.dart';
import '../../../core/constants/enums/person_enums.dart';
import '../../../shared/encryption/deterministic_encryption_helper.dart';
import '../data/participant_constants.dart';

class ParticipantEntity {
  final int? participantID;
  final String name;
  final String surname;
  final DateTime birthDate;
  final Sex sex;
  final EducationLevel educationLevel;
  final Laterality laterality;

  ParticipantEntity({
    this.participantID,
    required this.name,
    required this.surname,
    required this.birthDate,
    required this.sex,
    required this.educationLevel,
    required this.laterality,
  });

  static ParticipantEntity fromMap(Map<String, dynamic> map) {
    return ParticipantEntity(
      participantID: map[ParticipantFields.id],
      name: DeterministicEncryptionHelper.decryptText(map[ParticipantFields.name]),
      surname: DeterministicEncryptionHelper.decryptText(map[ParticipantFields.surname]),
      birthDate: DateTime.parse(map[ParticipantFields.birthDate]),
      sex: Sex.fromValue(map[ParticipantFields.sex]),
      educationLevel: EducationLevel.fromValue(map[ParticipantFields.educationLevel]),
      laterality: Laterality.fromValue(map[ParticipantFields.laterality]),
    );
  }

  Map<String, dynamic> toMap() => {
    ParticipantFields.id: participantID,
    ParticipantFields.name: DeterministicEncryptionHelper.encryptText(name),
    ParticipantFields.surname: DeterministicEncryptionHelper.encryptText(surname),
    ParticipantFields.birthDate: birthDate.toIso8601String(),
    ParticipantFields.sex: sex.numericValue,
    ParticipantFields.educationLevel: educationLevel.numericValue,
    ParticipantFields.laterality: laterality.numericValue,
  };

  ParticipantEntity copyWith({
    int? participantID,
    String? name,
    String? surname,
    DateTime? birthDate,
    Sex? sex,
    EducationLevel? educationLevel,
    Laterality? laterality,
  }) {
    return ParticipantEntity(
      participantID: participantID ?? this.participantID,
      name: name ?? this.name,
      surname: surname ?? this.surname,
      birthDate: birthDate ?? this.birthDate,
      sex: sex ?? this.sex,
      educationLevel: educationLevel ?? this.educationLevel,
      laterality: laterality ?? this.laterality,
    );
  }

  @override
  String toString() =>
      'ParticipantEntity(id: $participantID, name: $name, surname: $surname, sex: $sex, education: $educationLevel)';

  String get fullName => '$name $surname';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\participant\domain\participant_repository.dart ===
import 'participant_entity.dart';

abstract class ParticipantRepository {
  Future<void> insertParticipant(ParticipantEntity participant);
  Future<List<ParticipantEntity>> getAllParticipants();
  Future<ParticipantEntity?> getById(int id);
  Future<void> deleteParticipant(int id);
  Future<List<ParticipantEntity>> getParticipantsByEvaluatorId(int evaluatorId);
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\participant\domain\participant_with_evaluation.dart ===
import '../../../core/constants/enums/progress_status.dart';
import '../domain/participant_entity.dart';
import '../../evaluation/domain/evaluation_entity.dart';
import 'package:intl/intl.dart';

class ParticipantWithEvaluation {
  final ParticipantEntity participant;
  final EvaluationEntity? evaluation;

  const ParticipantWithEvaluation(this.participant, this.evaluation);

  bool get isCompleted => evaluation?.status == EvaluationStatus.completed;
  bool get isPending => evaluation?.status == EvaluationStatus.pending;
  bool get isInProgress => evaluation?.status == EvaluationStatus.inProgress;

  bool get isOverdue {
    if (evaluation == null) return false;
    final deadline = DateTime.now().subtract(const Duration(days: 7));
    return evaluation!.evaluationDate.isBefore(deadline) && !isCompleted;
  }

  String get fullName => '${participant.name} ${participant.surname}';

  String get evaluationDateFormatted =>
      evaluation != null ? DateFormat('dd/MM/yyyy').format(evaluation!.evaluationDate) : '‚Äî';

  String get statusLabel {
    if (evaluation == null) return '‚ùå N√£o iniciada';
    switch (evaluation!.status) {
      case EvaluationStatus.completed:
        return '‚úÖ Conclu√≠da';
      case EvaluationStatus.pending:
        return '‚è≥ Pendente';
      case EvaluationStatus.inProgress:
        return 'üõ†Ô∏è Em andamento';
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\participant\presentation\create_participant_evaluation_notifier.dart ===
import 'dart:async';
import 'package:hooks_riverpod/hooks_riverpod.dart';

import '../../../core/logger/app_logger.dart';
import '../../../providers/participant_providers.dart';

import '../../evaluation/data/evaluation_local_datasource.dart';
import '../../evaluation/domain/usecases/create_participant_evaluation_usecase.dart';

import '../../module/data/module_local_datasource.dart';
import '../../module/data/module_repository_impl.dart'; // ‚úÖ Added
import '../../task/data/task_local_datasource.dart';

import '../../module_instance/data/module_instance_local_datasource.dart';
import '../../module_instance/data/module_instance_repository_impl.dart';

import '../../task_instance/data/task_instance_local_datasource.dart';
import '../../task_instance/data/task_instance_repository_impl.dart';

import '../data/participant_local_datasource.dart';
import '../domain/participant_entity.dart';

class CreateParticipantEvaluationNotifier extends AsyncNotifier<ParticipantEntity?> {
  late final CreateParticipantEvaluationUseCase _useCase;

  @override
  FutureOr<ParticipantEntity?> build() async {
    final dbHelper = ref.read(participantDbHelperProvider);
    final db = await dbHelper.database;

    AppLogger.info('[PROVIDER] Initializing CreateParticipantEvaluationUseCase');

    _useCase = CreateParticipantEvaluationUseCase(
      participantDataSource: ParticipantLocalDataSource(dbHelper: dbHelper),
      evaluationDataSource: EvaluationLocalDataSource(dbHelper: dbHelper),
      moduleRepository: ModuleRepositoryImpl(
        local: ModuleLocalDataSource(dbHelper: dbHelper),
        taskLocal: TaskLocalDataSource(dbHelper: dbHelper),
      ), // ‚úÖ ADD THIS
      moduleInstanceRepository: ModuleInstanceRepositoryImpl(
        localDataSource: ModuleInstanceLocalDataSource(dbHelper: dbHelper),
      ),
      taskDataSource: TaskLocalDataSource(dbHelper: dbHelper),
      taskInstanceRepository: TaskInstanceRepositoryImpl(
        localDataSource: TaskInstanceLocalDataSource(dbHelper: dbHelper),
      ),
      db: db,
    );


    return null;
  }

  Future<void> createParticipantWithEvaluation({
    required ParticipantEntity participant,
    required int evaluatorId,
    required List<int> selectedModuleIds,
  }) async {
    state = const AsyncLoading();
    AppLogger.info(
      '[PROVIDER] Creating participant with evaluation for evaluatorId=$evaluatorId '
          'selectedModules=$selectedModuleIds',
    );

    try {
      final created = await _useCase.execute(
        participant: participant,
        evaluatorId: evaluatorId,
        selectedModuleIds: selectedModuleIds,
      );

      AppLogger.info(
        '[PROVIDER] ‚úÖ Participant + Evaluation created (participantId=${created.participantID})',
      );
      state = AsyncData(created);
    } catch (e, s) {
      AppLogger.error(
        '[PROVIDER] ‚ùå Failed to create participant with evaluation',
        e,
        s,
      );
      state = AsyncError(e, s);
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\participant\presentation\create_participant_form.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:intl/intl.dart';

import '../../../core/constants/enums/laterality_enums.dart';
import '../../../core/constants/enums/person_enums.dart';
import '../../../core/logger/app_logger.dart';

import '../../../providers/evaluator_providers.dart';
import '../../../providers/participant_providers.dart';

import '../../module/data/module_local_datasource.dart';
import '../../module/domain/module_entity.dart';
import '../domain/participant_entity.dart';
import '../../home/home_providers.dart'; // ‚úÖ Added import

class ParticipantRegistrationForm extends HookConsumerWidget {
  const ParticipantRegistrationForm({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final formKey = useMemoized(() => GlobalKey<FormState>());
    final nameController = useTextEditingController();
    final surnameController = useTextEditingController();

    final birthDate = useState<DateTime?>(null);
    final evaluationDate = useState<DateTime?>(null);

    final selectedGender = useState<Sex?>(null);
    final selectedEducation = useState<EducationLevel?>(null);
    final selectedLaterality = useState<Laterality?>(null);

    final flyoutController = useMemoized(() => FlyoutController());

    final modulesState = useState<List<ModuleEntity>>([]);
    final selectedModuleIds = useState<Set<int>>({});
    final selectAll = useState<bool>(true);

    final createState = ref.watch(createParticipantEvaluationProvider);

    // üîÑ Carrega m√≥dulos uma vez ao montar
    useEffect(() {
      () async {
        try {
          AppLogger.info('[UI] Carregando m√≥dulos...');
          final dbHelper = ref.read(participantDbHelperProvider);
          final moduleDs = ModuleLocalDataSource(dbHelper: dbHelper);
          final modules = await moduleDs.getAllModules();

          modulesState.value = modules;

          final ids = modules
              .where((m) => m.moduleID != null && m.moduleID != 9001)
              .map((m) => m.moduleID!)
              .toSet();

          selectedModuleIds.value = ids;
          selectAll.value = true;

          AppLogger.info(
            '[UI] M√≥dulos carregados: ${modules.length}, pr√©-selecionados: ${ids.length}',
          );
        } catch (e, s) {
          AppLogger.error('[UI] Erro ao carregar m√≥dulos', e, s);
        }
      }();
      return null;
    }, const []);

    Future<void> _showSuccessAndResetForm() async {
      AppLogger.info('[UI] ‚úÖ Paciente criado com sucesso!');

      // Show flyout (do not await closure)
      flyoutController.showFlyout(
        barrierDismissible: true,
        placementMode: FlyoutPlacementMode.bottomCenter,
        builder: (context) => const FlyoutContent(
          child: Padding(
            padding: EdgeInsets.all(8.0),
            child: Text('‚úÖ Paciente registrado com sucesso! Redirecionando...'),
          ),
        ),
      );

      // Wait briefly so user sees the message
      await Future.delayed(const Duration(milliseconds: 500));

      if (context.mounted) {
        Navigator.of(context).pop(); // Close flyout
      }

      // üßπ Reset form
      formKey.currentState!.reset();
      nameController.clear();
      surnameController.clear();
      birthDate.value = null;
      evaluationDate.value = null;
      selectedGender.value = null;
      selectedEducation.value = null;
      selectedLaterality.value = null;

      // ‚¨ÖÔ∏è Navigate back to dashboard
      ref
          .read(homeNavigationProvider.notifier)
          .setIndex(0); // ‚úÖ Switch tab to Dashboard
    }

    Future<void> _onSubmit() async {
      if (!formKey.currentState!.validate() ||
          birthDate.value == null ||
          selectedGender.value == null ||
          selectedEducation.value == null ||
          selectedLaterality.value == null) {
        AppLogger.warning('[UI] ‚ö†Ô∏è Formul√°rio inv√°lido');

        await showDialog(
          context: context,
          builder: (context) => ContentDialog(
            title: const Text('Dados incompletos'),
            content: const Text(
              'Por favor, preencha todos os campos obrigat√≥rios do paciente.',
            ),
            actions: [
              FilledButton(
                child: const Text('OK'),
                onPressed: () => Navigator.pop(context),
              ),
            ],
          ),
        );
        return;
      }

      if (selectedModuleIds.value.isEmpty) {
        AppLogger.warning('[UI] ‚ö†Ô∏è Nenhum m√≥dulo selecionado');

        await showDialog(
          context: context,
          builder: (context) => ContentDialog(
            title: const Text('Selecione os m√≥dulos'),
            content: const Text(
              'Escolha pelo menos um m√≥dulo para esta avalia√ß√£o.',
            ),
            actions: [
              FilledButton(
                child: const Text('OK'),
                onPressed: () => Navigator.pop(context),
              ),
            ],
          ),
        );
        return;
      }

      final evaluator = ref.read(currentUserProvider);
      if (evaluator == null || evaluator.evaluatorId == null) {
        AppLogger.error('[UI] ‚ùå Nenhum avaliador logado');

        await showDialog(
          context: context,
          builder: (context) => ContentDialog(
            title: const Text('Erro'),
            content: const Text(
              'Nenhum avaliador logado foi encontrado. Fa√ßa login novamente.',
            ),
            actions: [
              FilledButton(
                child: const Text('OK'),
                onPressed: () => Navigator.pop(context),
              ),
            ],
          ),
        );
        return;
      }

      final participant = ParticipantEntity(
        name: nameController.text.trim(),
        surname: surnameController.text.trim(),
        birthDate: birthDate.value!,
        sex: selectedGender.value!,
        educationLevel: selectedEducation.value!,
        laterality: selectedLaterality.value!,
      );

      final moduleIds = selectedModuleIds.value.toList();

      AppLogger.info(
        '[UI] Enviando novo participante: '
        'nome=${participant.name} ${participant.surname}, '
        'nasc=${participant.birthDate}, sexo=${participant.sex}, '
        'educa√ß√£o=${participant.educationLevel}, lateralidade=${participant.laterality}, '
        'avaliador=${evaluator.evaluatorId}, m√≥dulos=$moduleIds',
      );

      try {
        final notifier = ref.read(createParticipantEvaluationProvider.notifier);
        await notifier.createParticipantWithEvaluation(
          participant: participant,
          evaluatorId: evaluator.evaluatorId!,
          selectedModuleIds: moduleIds,
        );

        final state = ref.read(createParticipantEvaluationProvider);
        if (state.hasError) {
          AppLogger.error(
            '[UI] ‚ùå Falha na cria√ß√£o do paciente (state error)',
            state.error,
            state.stackTrace,
          );
          print('‚ùå UI: Falha ao criar participante ‚Üí ${state.error}'); // debug

          await showDialog(
            context: context,
            builder: (context) => ContentDialog(
              title: const Text('Erro ao salvar'),
              content: Text(
                'N√£o foi poss√≠vel registrar o paciente. ${state.error?.toString() ?? "Erro desconhecido."}',
              ),
              actions: [
                FilledButton(
                  child: const Text('OK'),
                  onPressed: () => Navigator.pop(context),
                ),
              ],
            ),
          );
          return;
        }

        await _showSuccessAndResetForm();
      } catch (e, s) {
        AppLogger.error('[UI] ‚ùå Erro inesperado na cria√ß√£o (try/catch)', e, s);
        print('‚ùå UI (try/catch): Erro inesperado ‚Üí $e'); // debug

        await showDialog(
          context: context,
          builder: (context) => ContentDialog(
            title: const Text('Erro inesperado'),
            content: Text(
              'Ocorreu um erro inesperado ao criar o participante. Detalhes: $e',
            ),
            actions: [
              FilledButton(
                child: const Text('OK'),
                onPressed: () => Navigator.pop(context),
              ),
            ],
          ),
        );
      }
    }

    return Form(
      key: formKey,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'üìã Registro do Paciente',
            style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 16),

          TextBox(controller: nameController, placeholder: 'Nome'),
          const SizedBox(height: 12),

          TextBox(controller: surnameController, placeholder: 'Sobrenome'),
          const SizedBox(height: 12),

          InfoLabel(
            label: 'Data de Nascimento',
            child: DatePicker(
              selected: birthDate.value,
              onChanged: (date) => birthDate.value = date,
            ),
          ),
          const SizedBox(height: 12),

          InfoLabel(
            label: 'Sexo',
            child: ComboBox<Sex>(
              isExpanded: true,
              value: selectedGender.value,
              items: Sex.values
                  .map((g) => ComboBoxItem(value: g, child: Text(g.label)))
                  .toList(),
              onChanged: (v) => selectedGender.value = v,
              placeholder: const Text('Selecione o sexo'),
            ),
          ),
          const SizedBox(height: 12),

          InfoLabel(
            label: 'N√≠vel de Educa√ß√£o',
            child: ComboBox<EducationLevel>(
              isExpanded: true,
              value: selectedEducation.value,
              items: EducationLevel.values
                  .map((e) => ComboBoxItem(value: e, child: Text(e.label)))
                  .toList(),
              onChanged: (v) => selectedEducation.value = v,
              placeholder: const Text('Selecione o n√≠vel'),
            ),
          ),
          const SizedBox(height: 12),

          InfoLabel(
            label: 'Lateralidade',
            child: ComboBox<Laterality>(
              isExpanded: true,
              value: selectedLaterality.value,
              items: Laterality.values
                  .map((h) => ComboBoxItem(value: h, child: Text(h.label)))
                  .toList(),
              onChanged: (v) => selectedLaterality.value = v,
              placeholder: const Text('Selecione a lateralidade'),
            ),
          ),
          const SizedBox(height: 12),

          InfoLabel(
            label: 'Data da Avalia√ß√£o (opcional)',
            child: DatePicker(
              selected: evaluationDate.value,
              onChanged: (date) => evaluationDate.value = date,
            ),
          ),
          if (evaluationDate.value != null)
            Padding(
              padding: const EdgeInsets.only(top: 8),
              child: Text(
                'üìÖ Dia da semana: ${DateFormat('EEEE', 'pt_BR').format(evaluationDate.value!)}',
              ),
            ),

          const SizedBox(height: 24),

          Text(
            'M√≥dulos da Avalia√ß√£o',
            style: FluentTheme.of(context).typography.subtitle,
          ),
          const SizedBox(height: 8),

          Row(
            children: [
              Checkbox(
                checked: selectAll.value,
                onChanged: (value) {
                  final v = value ?? false;
                  selectAll.value = v;

                  if (v) {
                    selectedModuleIds.value = modulesState.value
                        .where((m) => m.moduleID != null && m.moduleID != 9001)
                        .map((m) => m.moduleID!)
                        .toSet();
                  } else {
                    selectedModuleIds.value = {};
                  }
                },
              ),
              const SizedBox(width: 8),
              const Text('Selecionar todos'),
            ],
          ),

          const SizedBox(height: 8),

          ...modulesState.value
              .where((m) => m.moduleID != null && m.moduleID != 9001)
              .map((module) {
                final id = module.moduleID!;
                final isChecked = selectedModuleIds.value.contains(id);

                return Row(
                  children: [
                    Checkbox(
                      checked: isChecked,
                      onChanged: (value) {
                        final set = {...selectedModuleIds.value};
                        value == true ? set.add(id) : set.remove(id);
                        selectedModuleIds.value = set;

                        final totalVisible = modulesState.value
                            .where(
                              (m) => m.moduleID != null && m.moduleID != 9001,
                            )
                            .length;
                        selectAll.value = set.length == totalVisible;
                      },
                    ),
                    const SizedBox(width: 8),
                    Text(module.title),
                  ],
                );
              })
              .toList(),

          const SizedBox(height: 24),

          FlyoutTarget(
            controller: flyoutController,
            child: FilledButton(
              onPressed: createState.isLoading ? null : _onSubmit,
              child: createState.isLoading
                  ? const ProgressRing()
                  : const Text('Salvar'),
            ),
          ),
        ],
      ),
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\participant\presentation\create_participant_screen.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import '../../../core/logger/app_logger.dart';
import 'create_participant_form.dart';

class CreatePatientScreen extends StatelessWidget {
  const CreatePatientScreen({super.key});

  @override
  Widget build(BuildContext context) {
    AppLogger.nav('Navigated to CreatePatientScreen');
    return ScaffoldPage.scrollable(
      header: PageHeader(title: Text('Criar Novo Paciente')),
      children: [
        ParticipantRegistrationForm(),
      ],
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\participant\presentation\participant_list_provider.dart ===
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:segundo_cogni/features/participant/presentation/participant_provider.dart';
import '../../../core/logger/app_logger.dart';
import '../../../providers/evaluator_providers.dart';
import '../../evaluation/domain/evaluation_entity.dart';
import '../../evaluation/presentation/evaluation_provider.dart';
import '../domain/participant_with_evaluation.dart';

final participantListProvider = AsyncNotifierProvider.autoDispose<
    ParticipantListNotifier,
    List<ParticipantWithEvaluation>
>(ParticipantListNotifier.new);

class ParticipantListNotifier extends AsyncNotifier<List<ParticipantWithEvaluation>> {
  @override
  Future<List<ParticipantWithEvaluation>> build() async {
    final currentUser = ref.watch(currentUserProvider);
    if (currentUser == null || currentUser.evaluatorId == null) {
      AppLogger.warning('No current user or missing evaluatorId. Skipping fetch.');
      return [];
    }

    AppLogger.info('Fetching participants for evaluatorId=${currentUser.evaluatorId}');

    final participantRepo = ref.watch(participantRepositoryProvider);
    final evaluationRepo = ref.watch(evaluationRepositoryProvider);

    try {
      final participants = await participantRepo.getParticipantsByEvaluatorId(currentUser.evaluatorId!);
      AppLogger.info('Fetched ${participants.length} participants');

      final evaluations = await evaluationRepo.getEvaluationsByEvaluator(currentUser.evaluatorId!);
      AppLogger.info('Fetched ${evaluations.length} evaluations');

      final result = participants.map((participant) {
        final match = evaluations.where(
              (e) => e.participantID == participant.participantID,
        );

        final eval = match.isNotEmpty ? match.first : null;

        return ParticipantWithEvaluation(participant, eval);
      }).toList();


      AppLogger.info('Mapped ${result.length} ParticipantWithEvaluation objects');
      return result;
    } catch (e, s) {
      AppLogger.error('Error while building participant list', e, s);
      rethrow;
    }
  }

}



=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\participant\presentation\participant_list_screen.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:segundo_cogni/features/participant/presentation/participant_status_filter_enum.dart';

import '../../../core/utils/file_helper.dart';
import 'participant_list_provider.dart';
import 'participant_table.dart';

class ParticipantListScreen extends HookConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final searchQuery = useState('');
    final statusFilter = useState(ParticipantStatusFilter.all);

    final participantsAsync = ref.watch(participantListProvider);

    return participantsAsync.when(
      data: (participants) {
        final filtered = participants.where((p) {
          final query = searchQuery.value.toLowerCase();
          final name = p.fullName.toLowerCase();
          final status = p.statusLabel.toLowerCase();
          final evalDate = p.evaluationDateFormatted.toLowerCase();

          final matchesText = name.contains(query) || status.contains(query) || evalDate.contains(query);
          final matchesFilter = switch (statusFilter.value) {
            ParticipantStatusFilter.all => true,
            ParticipantStatusFilter.completed => p.isCompleted,
            ParticipantStatusFilter.pending => p.isPending,
            ParticipantStatusFilter.inProgress => p.isInProgress,
            ParticipantStatusFilter.notStarted => p.evaluation == null,
          };

          return matchesText && matchesFilter;
        }).toList()
          ..sort((a, b) => a.fullName.compareTo(b.fullName));

        return Column(
          children: [
            Padding(
              padding: const EdgeInsets.only(bottom: 12.0),
              child: Row(
                children: [
                  Expanded(
                    child: TextBox(
                      placeholder: 'Buscar por nome, status ou data...',
                      onChanged: (text) => searchQuery.value = text,
                    ),
                  ),
                  const SizedBox(width: 12),
                  ComboBox<ParticipantStatusFilter>(
                    value: statusFilter.value,
                    items: ParticipantStatusFilter.values
                        .map((f) => ComboBoxItem(value: f, child: Text(f.label)))
                        .toList(),
                    onChanged: (val) {
                      if (val != null) statusFilter.value = val;
                    },
                    placeholder: const Text('Filtrar status'),
                  ),
                  const SizedBox(width: 12),
                  FilledButton(
                    child: const Text('Exportar Excel'),
                    onPressed: () async {
                      await exportParticipantsToExcel(filtered);
                      if (context.mounted) {
                        showDialog(
                          context: context,
                          builder: (_) => ContentDialog(
                            title: const Text('Exportado!'),
                            content: const Text('Arquivo salvo em documentos do app.'),
                            actions: [
                              Button(child: const Text('OK'), onPressed: () => Navigator.pop(context)),
                            ],
                          ),
                        );
                      }
                    },
                  ),
                ],
              ),
            ),
            Expanded(child: ParticipantTable(participants: filtered)),
          ],
        );
      },
      loading: () => const Center(child: ProgressRing()),
      error: (err, st) => Center(child: Text('Erro ao carregar participantes: $err')),
    );
  }
}



=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\participant\presentation\participant_provider.dart ===
import 'package:hooks_riverpod/hooks_riverpod.dart';
import '../../../core/database/prod_database_helper.dart';
import '../../../core/logger/app_logger.dart';
import '../data/participant_local_datasource.dart';
import '../data/participant_repository_impl.dart';
import '../domain/participant_repository.dart';

final participantDbHelperProvider = Provider<ProdDatabaseHelper>((ref) {
  AppLogger.db('Providing ProdDatabaseHelper.instance for participants');
  return ProdDatabaseHelper.instance;
});

final participantRepositoryProvider = Provider<ParticipantRepository>((ref) {
  final dbHelper = ref.watch(participantDbHelperProvider);
  AppLogger.info('Creating ParticipantRepositoryImpl via participant_provider');
  return ParticipantRepositoryImpl(
    local: ParticipantLocalDataSource(dbHelper: dbHelper),
  );
});


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\participant\presentation\participant_status_filter_enum.dart ===
enum ParticipantStatusFilter {
  all('Todos'),
  completed('Conclu√≠dos'),
  pending('Pendentes'),
  inProgress('Em andamento'),
  notStarted('N√£o iniciados');

  final String label;
  const ParticipantStatusFilter(this.label);
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\participant\presentation\participant_table.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import '../../../core/theme/app_colors.dart';
import '../../../core/utils/file_helper.dart';
import '../../evaluation/presentation/module_evaluation_screen.dart';
import '../domain/participant_with_evaluation.dart';

class ParticipantTable extends StatelessWidget {
  final List<ParticipantWithEvaluation> participants;

  const ParticipantTable({super.key, required this.participants});

  @override
  Widget build(BuildContext context) {
    return Table(
      columnWidths: const {
        0: FlexColumnWidth(2),
        1: FlexColumnWidth(1),
        2: FlexColumnWidth(4),
      },
      children: [
        // ‚úÖ HEADER row
        const TableRow(
          decoration: BoxDecoration(color: AppColors.indigoBlue),
          children: [
            Padding(
              padding: EdgeInsets.all(8.0),
              child: Text('Paciente', style: TextStyle(fontWeight: FontWeight.bold)),
            ),
            Padding(
              padding: EdgeInsets.all(8.0),
              child: Text('Status'),
            ),
            Padding(
              padding: EdgeInsets.all(8.0),
              child: Text('A√ß√µes'),
            ),
          ],
        ),

        // ‚úÖ DATA rows
        ...participants.map((item) {
          return TableRow(
            decoration: const BoxDecoration(
              border: Border(bottom: BorderSide(color: AppColors.coolGray500)),
            ),
            children: [
              Padding(
                padding: const EdgeInsets.all(8.0),
                child: Text(item.fullName),
              ),
              Padding(
                padding: const EdgeInsets.all(8.0),
                child: Text(item.isCompleted ? '‚úÖ Feita' : '‚è≥ Pendente'),
              ),
              Padding(
                padding: const EdgeInsets.all(8.0),
                child: Wrap(
                  spacing: 4,
                  children: [
                    Button(
                      child: Text(
                        'Mais Informa√ß√µes',
                        style: TextStyle(color: Colors.green, fontWeight: FontWeight.bold),
                      ),
                      onPressed: () {
                        // TODO: Info logic
                      },
                    ),
                    Button(
                      child: Text(
                        'Prosseguir com Avalia√ß√£o',
                        style: TextStyle(color: Colors.orange, fontWeight: FontWeight.bold),
                      ),
                      onPressed: () {
                        Navigator.push(
                          context,
                          FluentPageRoute(
                            builder: (_) => ModuleEvaluationScreen(
                              evaluationId: item.evaluation!.evaluationID!,
                            ),
                          ),
                        );
                      },
                    ),

                    Button(
                      child: Text(
                        'Editar Informa√ß√µes',
                        style: TextStyle(color: Colors.red, fontWeight: FontWeight.bold),
                      ),
                      onPressed: () {
                        // TODO: Edit logic
                      },
                    ),
                    Button(
                      child: Text(
                        'Exportar Excel',
                        style: TextStyle(color: Colors.blue, fontWeight: FontWeight.bold),
                      ),
                      onPressed: () async {
                        await exportSingleParticipantToExcel(item);
                        if (context.mounted) {
                          showDialog(
                            context: context,
                            builder: (_) => ContentDialog(
                              title: const Text('Exportado!'),
                              content: const Text('Participante exportado com sucesso.'),
                              actions: [
                                Button(child: const Text('OK'), onPressed: () => Navigator.pop(context)),
                              ],
                            ),
                          );
                        }
                      },
                    ),

                  ],
                ),
              ),
            ],
          );
        }),
      ],
    );
  }
}




=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\recording_file\data\recording_file_constants.dart ===
import '../../../core/constants/database_constants.dart';
import '../../task_instance/data/task_instance_constants.dart';

class RecordingFileFields {
  static const id = 'recording_id';
  static const taskInstanceId = TaskInstanceFields.id;
  static const filePath = 'file_path';

  static const values = [id, taskInstanceId, filePath];
}

final scriptCreateTableRecordings = '''
CREATE TABLE ${Tables.recordings} (
  ${RecordingFileFields.id} INTEGER PRIMARY KEY AUTOINCREMENT,
  ${RecordingFileFields.taskInstanceId} INTEGER UNIQUE NOT NULL,
  ${RecordingFileFields.filePath} TEXT NOT NULL,
  FOREIGN KEY (${RecordingFileFields.taskInstanceId}) 
    REFERENCES ${Tables.taskInstances}(${TaskInstanceFields.id})
)
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\recording_file\data\recording_file_local_datasource.dart ===
import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import '../../../core/constants/database_constants.dart';
import '../../../core/database/base_database_helper.dart';
import '../../recording_file/data/recording_file_constants.dart';
import '../../recording_file/data/recording_file_model.dart';
import '../../../core/logger/app_logger.dart';

class RecordingFileLocalDataSource {
  final BaseDatabaseHelper dbHelper;

  RecordingFileLocalDataSource({required this.dbHelper});

  Future<Database> get _db async => dbHelper.database;

  Future<int?> insert(RecordingFileModel model) async {
    try {
      final db = await _db;
      final id = await db.insert(
        Tables.recordings,
        model.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
      AppLogger.db('Inserted RecordingFile (id=$id)');
      return id;
    } catch (e, s) {
      AppLogger.error('Error inserting RecordingFile', e, s);
      return null;
    }
  }

  Future<RecordingFileModel?> getById(int id) async {
    try {
      final db = await _db;
      final result = await db.query(
        Tables.recordings,
        where: '${RecordingFileFields.id} = ?',
        whereArgs: [id],
      );
      return result.isNotEmpty ? RecordingFileModel.fromMap(result.first) : null;
    } catch (e, s) {
      AppLogger.error('Error fetching RecordingFile by ID: $id', e, s);
      return null;
    }
  }

  Future<RecordingFileModel?> getByTaskInstanceId(int taskInstanceId) async {
    try {
      final db = await _db;
      final result = await db.query(
        Tables.recordings,
        where: '${RecordingFileFields.taskInstanceId} = ?',
        whereArgs: [taskInstanceId],
      );
      return result.isNotEmpty ? RecordingFileModel.fromMap(result.first) : null;
    } catch (e, s) {
      AppLogger.error('Error fetching RecordingFile by TaskInstanceId: $taskInstanceId', e, s);
      return null;
    }
  }

  Future<List<RecordingFileModel>> getAll() async {
    try {
      final db = await _db;
      final result = await db.query(Tables.recordings);
      return result.map(RecordingFileModel.fromMap).toList();
    } catch (e, s) {
      AppLogger.error('Error fetching all RecordingFiles', e, s);
      return [];
    }
  }

  Future<int> update(RecordingFileModel model) async {
    try {
      final db = await _db;
      return await db.update(
        Tables.recordings,
        model.toMap(),
        where: '${RecordingFileFields.id} = ?',
        whereArgs: [model.id],
      );
    } catch (e, s) {
      AppLogger.error('Error updating RecordingFile ID=${model.id}', e, s);
      return -1;
    }
  }

  Future<int> delete(int id) async {
    try {
      final db = await _db;
      return await db.delete(
        Tables.recordings,
        where: '${RecordingFileFields.id} = ?',
        whereArgs: [id],
      );
    } catch (e, s) {
      AppLogger.error('Error deleting RecordingFile ID=$id', e, s);
      return -1;
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\recording_file\data\recording_file_model.dart ===
import '../../recording_file/domain/recording_file_entity.dart';
import '../../recording_file/data/recording_file_constants.dart';

class RecordingFileModel extends RecordingFileEntity {
  const RecordingFileModel({
    super.id,
    required super.taskInstanceId,
    required super.filePath,
  });

  factory RecordingFileModel.fromMap(Map<String, dynamic> map) {
    return RecordingFileModel(
      id: map[RecordingFileFields.id] as int?,
      taskInstanceId: map[RecordingFileFields.taskInstanceId] as int,
      filePath: map[RecordingFileFields.filePath] as String,
    );
  }

  Map<String, dynamic> toMap() => {
    RecordingFileFields.id: id,
    RecordingFileFields.taskInstanceId: taskInstanceId,
    RecordingFileFields.filePath: filePath,
  };

  factory RecordingFileModel.fromEntity(RecordingFileEntity entity) =>
      RecordingFileModel(
        id: entity.id,
        taskInstanceId: entity.taskInstanceId,
        filePath: entity.filePath,
      );

  RecordingFileEntity toEntity() => RecordingFileEntity(
    id: id,
    taskInstanceId: taskInstanceId,
    filePath: filePath,
  );
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\recording_file\data\recording_file_repository_impl.dart ===
import '../../recording_file/domain/recording_file_entity.dart';
import '../../recording_file/domain/recording_file_repository.dart';
import '../../recording_file/data/recording_file_model.dart';
import '../../recording_file/data/recording_file_local_datasource.dart';

class RecordingFileRepositoryImpl implements RecordingFileRepository {
  final RecordingFileLocalDataSource localDataSource;

  RecordingFileRepositoryImpl({required this.localDataSource});

  @override
  Future<int?> insert(RecordingFileEntity entity) async {
    final model = RecordingFileModel.fromEntity(entity);
    return await localDataSource.insert(model);
  }

  @override
  Future<RecordingFileEntity?> getById(int id) async {
    final model = await localDataSource.getById(id);
    return model?.toEntity();
  }

  @override
  Future<RecordingFileEntity?> getByTaskInstanceId(int taskInstanceId) async {
    final model = await localDataSource.getByTaskInstanceId(taskInstanceId);
    return model?.toEntity();
  }

  @override
  Future<List<RecordingFileEntity>> getAll() async {
    final models = await localDataSource.getAll();
    return models.map((m) => m.toEntity()).toList();
  }

  @override
  Future<int> update(RecordingFileEntity entity) async {
    final model = RecordingFileModel.fromEntity(entity);
    return await localDataSource.update(model);
  }

  @override
  Future<int> delete(int id) async {
    return await localDataSource.delete(id);
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\recording_file\domain\recording_file_entity.dart ===
class RecordingFileEntity {
  final int? id;
  final int taskInstanceId;
  final String filePath;

  const RecordingFileEntity({
    this.id,
    required this.taskInstanceId,
    required this.filePath,
  });

  RecordingFileEntity copyWith({
    int? id,
    int? taskInstanceId,
    String? filePath,
  }) {
    return RecordingFileEntity(
      id: id ?? this.id,
      taskInstanceId: taskInstanceId ?? this.taskInstanceId,
      filePath: filePath ?? this.filePath,
    );
  }

  @override
  String toString() =>
      'RecordingFileEntity(id: $id, taskInstanceId: $taskInstanceId, filePath: $filePath)';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\recording_file\domain\recording_file_repository.dart ===
import 'recording_file_entity.dart';

abstract class RecordingFileRepository {
  Future<int?> insert(RecordingFileEntity entity);
  Future<RecordingFileEntity?> getById(int id);
  Future<RecordingFileEntity?> getByTaskInstanceId(int taskInstanceId);
  Future<List<RecordingFileEntity>> getAll();
  Future<int> update(RecordingFileEntity entity);
  Future<int> delete(int id);
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\splash\splash_screen.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

import '../../core/database/prod_database_helper.dart';
import '../../core/logger/app_logger.dart';
import '../../features/evaluator/data/evaluator_local_datasource.dart';
import '../../seeders/seed_runner.dart';
import '../auth/data/auth_local_datasource.dart';
import '../auth/data/auth_repository_impl.dart';
import '../../providers/providers.dart';

class SplashScreen extends HookConsumerWidget {
  const SplashScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    Future.microtask(() async {
      if (!context.mounted) return; // üîê Ensure still mounted before async logic
      await _initializeApp(context, ref);
    });

    return NavigationView(
      content: ScaffoldPage(
        content: Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: const [
              ProgressRing(),
              SizedBox(height: 16),
              Text(
                'Inicializando o aplicativo...',
                style: TextStyle(fontSize: 16),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Future<void> _initializeApp(BuildContext context, WidgetRef ref) async {
    try {
      AppLogger.seed('[SPLASH] Starting database seeding...');
      final db = await ProdDatabaseHelper.instance.database;
      await SeedRunner().run(db: db);

      final evaluatorDataSource = EvaluatorLocalDataSource(db);
      final auth = AuthLocalDataSource(db);
      final repository = AuthRepositoryImpl(auth);

      final currentUser = await repository.fetchCurrentUserOrNull();

      if (!context.mounted) return; // ‚úÖ Prevent context usage after unmount

      if (currentUser != null) {
        AppLogger.seed('[SPLASH] Auto-login success: ${currentUser.email}');
        ref.read(currentUserProvider.notifier).setUser(currentUser);
        context.go('/home');
        return;
      }

      final anyEvaluator = await evaluatorDataSource.getFirstEvaluator();

      if (!context.mounted) return;

      if (anyEvaluator != null) {
        AppLogger.seed('[SPLASH] Evaluator exists ‚Üí go to login');
        context.go('/login');
      } else {
        AppLogger.seed('[SPLASH] No evaluator found ‚Üí go to registration');
        context.go('/register');
      }
    } catch (e, s) {
      AppLogger.error('[SPLASH] Error during initialization', e, s);
      if (context.mounted) {
        _showErrorDialog(context, e.toString());
      }
    }
  }

  void _showErrorDialog(BuildContext context, String message) {
    showDialog(
      context: context,
      builder: (_) => ContentDialog(
        title: const Text('Erro ao iniciar'),
        content: Text(message),
        actions: [
          Button(
            child: const Text('Fechar'),
            onPressed: () => Navigator.pop(context),
          ),
        ],
      ),
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task\data\task_constants.dart ===
import '../../../core/constants/database_constants.dart';

class TaskFields {
  static const id = 'task_id';
  static const moduleId = 'module_id';
  static const title = 'title';
  static const transcript = 'transcript';
  static const mode = 'mode';
  static const position = 'position';
  static const imagePath = 'image_path';
  static const timeForCompletion = 'time_for_completion';
  static const mayRepeatPrompt = 'may_repeat_prompt';
  static const testOnly = 'test_only';

  static const values = [
    id,
    moduleId,
    title,
    transcript,
    mode,
    position,
    imagePath,
    timeForCompletion,
    mayRepeatPrompt,
    testOnly,
  ];
}

const scriptCreateTableTasks = '''
CREATE TABLE ${Tables.tasks} (
  ${TaskFields.id} INTEGER PRIMARY KEY AUTOINCREMENT,
  ${TaskFields.moduleId} INTEGER NOT NULL,
  ${TaskFields.title} TEXT NOT NULL,
  ${TaskFields.transcript} TEXT,
  ${TaskFields.mode} INTEGER NOT NULL,
  ${TaskFields.position} INTEGER NOT NULL,
  ${TaskFields.imagePath} TEXT NOT NULL,
  ${TaskFields.mayRepeatPrompt} INTEGER NOT NULL,
  ${TaskFields.testOnly} INTEGER NOT NULL,
  ${TaskFields.timeForCompletion} INTEGER NOT NULL,
  FOREIGN KEY (${TaskFields.moduleId}) REFERENCES ${Tables.modules}(${TaskFields.id}),
  CHECK(${TaskFields.mode} >= 0 AND ${TaskFields.mode} <= 1),
  CHECK(${TaskFields.mayRepeatPrompt} >= 0 AND ${TaskFields.mayRepeatPrompt} <= 1)
)
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task\data\task_local_datasource.dart ===
import 'package:sqflite_common/sqlite_api.dart';
import '../../../core/database/base_database_helper.dart';
import '../../../core/logger/app_logger.dart';
import '../../../core/constants/database_constants.dart';
import 'task_constants.dart';
import 'task_model.dart';

class TaskLocalDataSource {
  final BaseDatabaseHelper dbHelper;
  TaskLocalDataSource({required this.dbHelper});

  Future<Database> get _db async => dbHelper.database;
  Future<int?> insertTask(TaskModel task) async {
    AppLogger.db('Inserting task: ${task.title}');
    try {
      final db = await _db;
      final id = await db.insert(
        Tables.tasks,
        task.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
      AppLogger.db('Task inserted successfully (id=$id)');
      return id;
    } catch (e, s) {
      AppLogger.error('Error inserting task: ${task.title}', e, s);
      return null;
    }
  }

  Future<TaskModel?> getTaskById(int id) async {
    AppLogger.db('Fetching task by ID=$id');
    try {
      final db = await _db;
      final result = await db.query(
        Tables.tasks,
        where: '${TaskFields.id} = ?',
        whereArgs: [id],
      );
      if (result.isNotEmpty) {
        AppLogger.db('Task found (ID=$id)');
        return TaskModel.fromMap(result.first);
      }
      AppLogger.db('No task found (ID=$id)');
      return null;
    } catch (e, s) {
      AppLogger.error('Error fetching task by ID=$id', e, s);
      return null;
    }
  }

  Future<List<TaskModel>> getAllTasks() async {
    AppLogger.db('Fetching all tasks');
    try {
      final db = await _db;
      final maps = await db.query(Tables.tasks);
      AppLogger.db('Fetched ${maps.length} tasks');
      return maps.map(TaskModel.fromMap).toList();
    } catch (e, s) {
      AppLogger.error('Error fetching all tasks', e, s);
      return [];
    }
  }

  Future<List<TaskModel>> getTasksByModuleId(int moduleId) async {
    AppLogger.db('Fetching tasks for moduleId=$moduleId');
    try {
      final db = await _db;
      final maps = await db.query(
        Tables.tasks,
        where: '${TaskFields.moduleId} = ?',
        whereArgs: [moduleId],
      );
      AppLogger.db('Fetched ${maps.length} tasks for moduleId=$moduleId');
      return maps.map(TaskModel.fromMap).toList();
    } catch (e, s) {
      AppLogger.error('Error fetching tasks for moduleId=$moduleId', e, s);
      return [];
    }
  }

  Future<int> updateTask(TaskModel task) async {
    AppLogger.db('Updating task ID=${task.taskID}');
    try {
      final db = await _db;
      final rows = await db.update(
        Tables.tasks,
        task.toMap(),
        where: '${TaskFields.id} = ?',
        whereArgs: [task.taskID],
      );
      AppLogger.db('Updated $rows task(s) for ID=${task.taskID}');
      return rows;
    } catch (e, s) {
      AppLogger.error('Error updating task ID=${task.taskID}', e, s);
      return 0;
    }
  }

  Future<int> deleteTask(int id) async {
    AppLogger.db('Deleting task ID=$id');
    try {
      final db = await _db;
      final count = await db.delete(
        Tables.tasks,
        where: '${TaskFields.id} = ?',
        whereArgs: [id],
      );
      AppLogger.db('Deleted $count task(s)');
      return count;
    } catch (e, s) {
      AppLogger.error('Error deleting task ID=$id', e, s);
      return 0;
    }
  }

  Future<bool> exists(String taskId) async {
    final db = await _db;
    final result = await db.query(
      Tables.tasks,
      where: '${TaskFields.id} = ?',
      whereArgs: [taskId],
      limit: 1,
    );
    return result.isNotEmpty;
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task\data\task_model.dart ===
import '../../../core/constants/enums/task_mode.dart';
import '../../task/domain/task_entity.dart';
import '../../task/data/task_constants.dart';

class TaskModel extends TaskEntity {
  const TaskModel({
    super.taskID,
    required super.moduleID,
    required super.title,
    required super.taskMode,
    required super.position,
    super.imagePath = 'no_image',
    super.timeForCompletion = 60,
    super.mayRepeatPrompt = true,
    super.testOnly = false,
    super.transcript,
  });

  factory TaskModel.fromMap(Map<String, dynamic> map) {
    return TaskModel(
      taskID: map[TaskFields.id] as int?,
      moduleID: map[TaskFields.moduleId] as int,
      title: map[TaskFields.title] as String,
      transcript: map[TaskFields.transcript] as String?,
      taskMode: TaskMode.fromValue(map[TaskFields.mode] as int),
      position: map[TaskFields.position] as int,
      imagePath: map[TaskFields.imagePath] as String? ?? 'no_image',
      timeForCompletion: map[TaskFields.timeForCompletion] as int? ?? 60,
      mayRepeatPrompt: (map[TaskFields.mayRepeatPrompt] as int) == 1,
      testOnly: (map[TaskFields.testOnly] as int) == 1,
    );
  }

  Map<String, dynamic> toMap() => {
    TaskFields.id: taskID,
    TaskFields.moduleId: moduleID,
    TaskFields.title: title,
    TaskFields.transcript: transcript,
    TaskFields.mode: taskMode.numericValue,
    TaskFields.position: position,
    TaskFields.imagePath: imagePath,
    TaskFields.timeForCompletion: timeForCompletion,
    TaskFields.mayRepeatPrompt: mayRepeatPrompt ? 1 : 0,
    TaskFields.testOnly: testOnly ? 1 : 0,
  };

  factory TaskModel.fromEntity(TaskEntity entity) => TaskModel(
    taskID: entity.taskID,
    moduleID: entity.moduleID,
    title: entity.title,
    transcript: entity.transcript,
    taskMode: entity.taskMode,
    position: entity.position,
    imagePath: entity.imagePath,
    timeForCompletion: entity.timeForCompletion,
    mayRepeatPrompt: entity.mayRepeatPrompt,
    testOnly: entity.testOnly,
  );

  TaskEntity toEntity() => TaskEntity(
    taskID: taskID,
    moduleID: moduleID,
    title: title,
    transcript: transcript,
    taskMode: taskMode,
    position: position,
    imagePath: imagePath,
    timeForCompletion: timeForCompletion,
    mayRepeatPrompt: mayRepeatPrompt,
    testOnly: testOnly,
  );
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task\data\task_repository_impl.dart ===
import '../domain/task_repository.dart';
import '../domain/task_entity.dart';
import 'task_local_datasource.dart';
import 'task_model.dart';

class TaskRepositoryImpl implements TaskRepository {
  final TaskLocalDataSource localDataSource;

  TaskRepositoryImpl({required this.localDataSource});

  @override
  Future<int?> insertTask(TaskEntity task) async {
    final model = TaskModel.fromEntity(task);
    return await localDataSource.insertTask(model);
  }

  @override
  Future<TaskEntity?> getTaskById(int id) async {
    final model = await localDataSource.getTaskById(id);
    return model?.toEntity();
  }

  @override
  Future<List<TaskEntity>> getAllTasks() async {
    final models = await localDataSource.getAllTasks();
    return models.map((m) => m.toEntity()).toList();
  }

  @override
  Future<List<TaskEntity>> getTasksByModuleId(int moduleId) async {
    final models = await localDataSource.getTasksByModuleId(moduleId);
    return models.map((m) => m.toEntity()).toList();
  }

  @override
  Future<int> updateTask(TaskEntity task) async {
    final model = TaskModel.fromEntity(task);
    return await localDataSource.updateTask(model);
  }

  @override
  Future<int> deleteTask(int id) async {
    return await localDataSource.deleteTask(id);
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task\domain\task_entity.dart ===
import '../../../core/constants/enums/task_mode.dart';
import '../data/task_constants.dart';

class TaskEntity {
  final int? taskID;
  final int moduleID;
  final String title;
  final String? transcript;
  final TaskMode taskMode;
  final int position;
  final String imagePath;
  final int timeForCompletion;
  final bool mayRepeatPrompt;
  final bool testOnly;

  const TaskEntity({
    this.taskID,
    required this.moduleID,
    required this.title,
    required this.taskMode,
    required this.position,
    this.transcript,
    this.imagePath = 'no_image',
    this.timeForCompletion = 60,
    this.mayRepeatPrompt = true,
    this.testOnly = false,
  });

  Map<String, dynamic> toMap() => {
    TaskFields.id: taskID,
    TaskFields.moduleId: moduleID,
    TaskFields.title: title,
    TaskFields.transcript: transcript,
    TaskFields.mode: taskMode.index,
    TaskFields.position: position,
    TaskFields.imagePath: imagePath,
    TaskFields.timeForCompletion: timeForCompletion,
    TaskFields.mayRepeatPrompt: mayRepeatPrompt ? 1 : 0,
    TaskFields.testOnly: testOnly ? 1 : 0,
  };

  factory TaskEntity.fromMap(Map<String, dynamic> map) => TaskEntity(
    taskID: map[TaskFields.id] as int?,
    moduleID: map[TaskFields.moduleId] as int,
    title: map[TaskFields.title] as String,
    transcript: map[TaskFields.transcript] as String?,
    taskMode: TaskMode.values[map[TaskFields.mode] as int],
    position: map[TaskFields.position] as int,
    imagePath: map[TaskFields.imagePath] as String,
    timeForCompletion: map[TaskFields.timeForCompletion] as int,
    mayRepeatPrompt: (map[TaskFields.mayRepeatPrompt] as int) == 1,
    testOnly: (map[TaskFields.testOnly] as int) == 1,
  );

  TaskEntity copyWith({
    int? taskID,
    int? moduleID,
    String? title,
    String? transcript,
    TaskMode? taskMode,
    int? position,
    String? imagePath,
    int? timeForCompletion,
    bool? mayRepeatPrompt,
    bool? testOnly,
  }) {
    return TaskEntity(
      taskID: taskID ?? this.taskID,
      moduleID: moduleID ?? this.moduleID,
      title: title ?? this.title,
      transcript: transcript ?? this.transcript,
      taskMode: taskMode ?? this.taskMode,
      position: position ?? this.position,
      imagePath: imagePath ?? this.imagePath,
      timeForCompletion: timeForCompletion ?? this.timeForCompletion,
      mayRepeatPrompt: mayRepeatPrompt ?? this.mayRepeatPrompt,
      testOnly: testOnly ?? this.testOnly,
    );
  }

  @override
  String toString() =>
      'TaskEntity(id: $taskID, title: $title, mode: $taskMode, moduleId: $moduleID, pos: $position)';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task\domain\task_repository.dart ===
import 'task_entity.dart';

abstract class TaskRepository {
  Future<int?> insertTask(TaskEntity task);
  Future<TaskEntity?> getTaskById(int id);
  Future<List<TaskEntity>> getAllTasks();
  Future<List<TaskEntity>> getTasksByModuleId(int moduleId);
  Future<int> updateTask(TaskEntity task);
  Future<int> deleteTask(int id);
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_instance\data\task_instance_constants.dart ===
import '../../../core/constants/database_constants.dart';
import '../../module_instance/data/module_instance_constants.dart';
import '../../task/data/task_constants.dart';

class TaskInstanceFields {
  static const id = 'task_inst_id';
  static const taskId = TaskFields.id;
  static const moduleInstanceId = ModuleInstanceFields.id;
  static const status = 'status';
  static const completingTime = 'task_completing_time';

  static const values = [id, taskId, moduleInstanceId, status, completingTime];
}

final scriptCreateTableTaskInstances = '''
CREATE TABLE ${Tables.taskInstances} (
  ${TaskInstanceFields.id} INTEGER PRIMARY KEY AUTOINCREMENT,
  ${TaskInstanceFields.taskId} INTEGER NOT NULL,
  ${TaskInstanceFields.moduleInstanceId} INTEGER NOT NULL,
  ${TaskInstanceFields.status} INT NOT NULL CHECK(${TaskInstanceFields.status} IN (0, 1)),
  ${TaskInstanceFields.completingTime} TEXT,
  FOREIGN KEY (${TaskInstanceFields.taskId}) REFERENCES ${Tables.tasks}(${TaskFields.id}),
  FOREIGN KEY (${TaskInstanceFields.moduleInstanceId}) REFERENCES ${Tables.moduleInstances}(${ModuleInstanceFields.id})
)
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_instance\data\task_instance_local_datasource.dart ===
import 'package:sqflite_common/sqlite_api.dart';

import '../../../core/constants/database_constants.dart';
import '../../../core/constants/enums/progress_status.dart';
import '../../../core/database/base_database_helper.dart';
import '../../../core/logger/app_logger.dart';
import '../../task/data/task_constants.dart';
import '../../task_instance/data/task_instance_constants.dart';
import '../../task_instance/data/task_instance_model.dart';

class TaskInstanceLocalDataSource {
  final BaseDatabaseHelper dbHelper;

  TaskInstanceLocalDataSource({required this.dbHelper});

  Future<Database> get _db async => dbHelper.database;

  Future<int?> create(TaskInstanceModel model) async {
    AppLogger.db('Creating task instance for taskId=${model.taskId}');
    try {
      final db = await _db;
      final id = await db.insert(
        Tables.taskInstances,
        model.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
      AppLogger.db('Task instance created successfully (id=$id)');
      return id;
    } catch (e, s) {
      AppLogger.error('Error creating task instance', e, s);
      return null;
    }
  }

  Future<TaskInstanceModel?> getTaskInstance(int id) async {
    AppLogger.db('Fetching task instance ID=$id');
    try {
      final db = await _db;
      final maps = await db.query(
        Tables.taskInstances,
        where: '${TaskInstanceFields.id} = ?',
        whereArgs: [id],
      );
      if (maps.isNotEmpty) {
        AppLogger.db('Task instance found (ID=$id)');
        return TaskInstanceModel.fromMap(maps.first);
      }
      AppLogger.db('No task instance found (ID=$id)');
      return null;
    } catch (e, s) {
      AppLogger.error('Error fetching task instance ID=$id', e, s);
      return null;
    }
  }

  Future<int> updateTaskInstance(TaskInstanceModel model) async {
    AppLogger.db('Updating task instance ID=${model.id}');
    try {
      final db = await _db;
      final rows = await db.update(
        Tables.taskInstances,
        model.toMap(),
        where: '${TaskInstanceFields.id} = ?',
        whereArgs: [model.id],
      );
      AppLogger.db('Updated $rows task instance(s)');
      return rows;
    } catch (e, s) {
      AppLogger.error('Error updating task instance ID=${model.id}', e, s);
      return 0;
    }
  }

  Future<int> deleteTaskInstance(int id) async {
    AppLogger.db('Deleting task instance ID=$id');
    try {
      final db = await _db;
      final count = await db.delete(
        Tables.taskInstances,
        where: '${TaskInstanceFields.id} = ?',
        whereArgs: [id],
      );
      AppLogger.db('Deleted $count task instance(s)');
      return count;
    } catch (e, s) {
      AppLogger.error('Error deleting task instance ID=$id', e, s);
      return 0;
    }
  }

  Future<List<TaskInstanceModel>> getAllTaskInstances() async {
    AppLogger.db('Fetching all task instances');
    try {
      final db = await _db;
      final maps = await db.query(Tables.taskInstances);
      AppLogger.db('Fetched ${maps.length} task instances');
      return maps.map(TaskInstanceModel.fromMap).toList();
    } catch (e, s) {
      AppLogger.error('Error fetching all task instances', e, s);
      return [];
    }
  }

  Future<List<TaskInstanceModel>> getTaskInstancesForModuleInstance(
      int moduleInstanceId) async {
    AppLogger.db(
        'Fetching task instances for moduleInstanceId=$moduleInstanceId');
    try {
      final db = await _db;
      final maps = await db.query(
        Tables.taskInstances,
        where: '${TaskInstanceFields.moduleInstanceId} = ?',
        whereArgs: [moduleInstanceId],
      );
      AppLogger.db(
          'Fetched ${maps.length} task instances for moduleInstanceId=$moduleInstanceId');
      return maps.map(TaskInstanceModel.fromMap).toList();
    } catch (e, s) {
      AppLogger.error(
          'Error fetching task instances for moduleInstanceId=$moduleInstanceId',
          e,
          s);
      return [];
    }
  }

  Future<int?> getNumberOfTaskInstances() async {
    AppLogger.db('Counting task instances');
    try {
      final db = await _db;
      final result = await db
          .rawQuery('SELECT COUNT(*) as count FROM ${Tables.taskInstances}');
      final count = result.first['count'] as int?;
      AppLogger.db('Task instance count: $count');
      return count;
    } catch (e, s) {
      AppLogger.error('Error counting task instances', e, s);
      return null;
    }
  }

  Future<TaskInstanceModel?> getFirstPendingTaskInstance() async {
    AppLogger.db('Fetching first pending task instance');
    try {
      final db = await _db;
      final result = await db.rawQuery('''
        SELECT ti.* FROM ${Tables.taskInstances} ti
        INNER JOIN ${Tables.tasks} t ON ti.${TaskInstanceFields.taskId} = t.${TaskFields.id}
        WHERE ti.${TaskInstanceFields.status} = 0
        ORDER BY t.${TaskFields.position} ASC
        LIMIT 1
      ''');
      if (result.isNotEmpty) {
        AppLogger.db(
            'Found pending task instance ID=${result.first[TaskInstanceFields.id]}');
        return TaskInstanceModel.fromMap(result.first);
      }
      AppLogger.db('No pending task instance found');
      return null;
    } catch (e, s) {
      AppLogger.error('Error fetching first pending task instance', e, s);
      return null;
    }
  }

  Future<int> markAsCompleted(int id, {String? duration}) async {
    AppLogger.db('Marking task instance ID=$id as completed');
    try {
      final db = await _db;
      final map = {
        TaskInstanceFields.status: TaskStatus.completed.numericValue,
        if (duration != null) TaskInstanceFields.completingTime: duration,
      };
      final rows = await db.update(
        Tables.taskInstances,
        map,
        where: '${TaskInstanceFields.id} = ?',
        whereArgs: [id],
      );
      AppLogger.db(
          'Task instance ID=$id marked as completed ($rows row(s) affected)');
      return rows;
    } catch (e, s) {
      AppLogger.error(
          'Error marking task instance ID=$id as completed', e, s);
      return 0;
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_instance\data\task_instance_model.dart ===
import '../../task_instance/domain/task_instance_entity.dart';
import '../../task_instance/data/task_instance_constants.dart';
import '../../../core/constants/enums/progress_status.dart';

class TaskInstanceModel extends TaskInstanceEntity {
  const TaskInstanceModel({
    super.id,
    required super.taskId,
    required super.moduleInstanceId,
    required super.status,
    super.completingTime,
    super.task,
  });

  factory TaskInstanceModel.fromMap(Map<String, dynamic> map) {
    return TaskInstanceModel(
      id: map[TaskInstanceFields.id] as int?,
      taskId: map[TaskInstanceFields.taskId] as int,
      moduleInstanceId: map[TaskInstanceFields.moduleInstanceId] as int,
      status: TaskStatus.fromValue(map[TaskInstanceFields.status] as int),
      completingTime: map[TaskInstanceFields.completingTime] as String?,
    );
  }

  Map<String, dynamic> toMap() => {
    TaskInstanceFields.id: id,
    TaskInstanceFields.taskId: taskId,
    TaskInstanceFields.moduleInstanceId: moduleInstanceId,
    TaskInstanceFields.status: status.numericValue,
    TaskInstanceFields.completingTime: completingTime,
  };

  factory TaskInstanceModel.fromEntity(TaskInstanceEntity entity) {
    return TaskInstanceModel(
      id: entity.id,
      taskId: entity.taskId,
      moduleInstanceId: entity.moduleInstanceId,
      status: entity.status,
      completingTime: entity.completingTime,
      task: entity.task,
    );
  }

  TaskInstanceEntity toEntity() {
    return TaskInstanceEntity(
      id: id,
      taskId: taskId,
      moduleInstanceId: moduleInstanceId,
      status: status,
      completingTime: completingTime,
      task: task,
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_instance\data\task_instance_repository_impl.dart ===
import '../../task_instance/domain/task_instance_entity.dart';
import '../../task_instance/domain/task_instance_repository.dart';
import 'task_instance_local_datasource.dart';
import 'task_instance_model.dart';

class TaskInstanceRepositoryImpl implements TaskInstanceRepository {
  final TaskInstanceLocalDataSource localDataSource;

  TaskInstanceRepositoryImpl({required this.localDataSource});

  @override
  Future<int?> insert(TaskInstanceEntity entity) async {
    final model = TaskInstanceModel.fromEntity(entity);
    return await localDataSource.create(model);
  }

  @override
  Future<TaskInstanceEntity?> getById(int id) async {
    final model = await localDataSource.getTaskInstance(id);
    return model?.toEntity();
  }

  @override
  Future<List<TaskInstanceEntity>> getAll() async {
    final models = await localDataSource.getAllTaskInstances();
    return models.map((m) => m.toEntity()).toList();
  }

  @override
  Future<int> update(TaskInstanceEntity entity) async {
    final model = TaskInstanceModel.fromEntity(entity);
    return await localDataSource.updateTaskInstance(model);
  }

  @override
  Future<int> delete(int id) async {
    return await localDataSource.deleteTaskInstance(id);
  }

  @override
  Future<List<TaskInstanceEntity>> getByModuleInstance(int moduleInstanceId) async {
    final models = await localDataSource.getTaskInstancesForModuleInstance(moduleInstanceId);
    return models.map((m) => m.toEntity()).toList();
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_instance\domain\task_instance_entity.dart ===
import '../../task/domain/task_entity.dart';
import '../../../core/constants/enums/progress_status.dart';

class TaskInstanceEntity {
  final int? id;
  final int taskId;
  final int moduleInstanceId;
  final TaskStatus status;
  final String? completingTime;
  final TaskEntity? task;

  const TaskInstanceEntity({
    this.id,
    required this.taskId,
    required this.moduleInstanceId,
    this.status = TaskStatus.pending,
    this.completingTime,
    this.task,
  });

  TaskInstanceEntity copyWith({
    int? id,
    int? taskId,
    int? moduleInstanceId,
    TaskStatus? status,
    String? completingTime,
    TaskEntity? task,
  }) {
    return TaskInstanceEntity(
      id: id ?? this.id,
      taskId: taskId ?? this.taskId,
      moduleInstanceId: moduleInstanceId ?? this.moduleInstanceId,
      status: status ?? this.status,
      completingTime: completingTime ?? this.completingTime,
      task: task ?? this.task,
    );
  }

  @override
  String toString() =>
      'TaskInstanceEntity(id: $id, taskId: $taskId, moduleInstanceId: $moduleInstanceId, status: $status, completingTime: $completingTime)';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_instance\domain\task_instance_repository.dart ===
import 'task_instance_entity.dart';

abstract class TaskInstanceRepository {
  Future<int?> insert(TaskInstanceEntity entity);
  Future<TaskInstanceEntity?> getById(int id);
  Future<List<TaskInstanceEntity>> getAll();
  Future<int> update(TaskInstanceEntity entity);
  Future<int> delete(int id);
  Future<List<TaskInstanceEntity>> getByModuleInstance(int moduleInstanceId);
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_prompt\data\task_prompt_constants.dart ===
import '../../../core/constants/database_constants.dart';
import '../../task/data/task_constants.dart';

class TaskPromptFields {
  static const promptID = 'prompt_id';
  static const taskID = TaskFields.id;
  static const filePath = 'file_path';
  static const transcription = 'transcription';

  static const values = [promptID, taskID, filePath, transcription];
}

final scriptCreateTableTaskPrompts = '''
CREATE TABLE ${Tables.taskPrompts} (
  ${TaskPromptFields.promptID} INTEGER PRIMARY KEY AUTOINCREMENT,
  ${TaskPromptFields.taskID} INTEGER UNIQUE NOT NULL,
  ${TaskPromptFields.filePath} TEXT NOT NULL,
  ${TaskPromptFields.transcription} TEXT,
  FOREIGN KEY (${TaskPromptFields.taskID}) REFERENCES ${Tables.tasks}(${TaskFields.id})
)
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_prompt\data\task_prompt_local_datasource.dart ===
import 'package:sqflite_common/sqlite_api.dart';
import '../../../core/database/prod_database_helper.dart';
import '../../../core/logger/app_logger.dart';
import '../../../core/constants/database_constants.dart';
import '../../task_prompt/data/task_prompt_constants.dart';
import '../../task_prompt/data/task_prompt_model.dart';

class TaskPromptLocalDataSource {
  static final TaskPromptLocalDataSource _instance =
  TaskPromptLocalDataSource._internal();

  factory TaskPromptLocalDataSource() => _instance;

  TaskPromptLocalDataSource._internal();

  Future<Database> get _db async => await ProdDatabaseHelper.instance.database;

  Future<int?> insert(TaskPromptModel model) async {
    AppLogger.db('Inserting TaskPrompt for taskId=${model.taskID}');
    try {
      final db = await _db;
      final id = await db.insert(
        Tables.taskPrompts,
        model.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
      AppLogger.db('TaskPrompt inserted (id=$id)');
      return id;
    } catch (e, s) {
      AppLogger.error('Error inserting TaskPrompt', e, s);
      return null;
    }
  }

  Future<TaskPromptModel?> getById(int id) async {
    AppLogger.db('Fetching TaskPrompt by ID=$id');
    try {
      final db = await _db;
      final result = await db.query(
        Tables.taskPrompts,
        where: '${TaskPromptFields.promptID} = ?',
        whereArgs: [id],
      );
      return result.isNotEmpty ? TaskPromptModel.fromMap(result.first) : null;
    } catch (e, s) {
      AppLogger.error('Error fetching TaskPrompt by ID=$id', e, s);
      return null;
    }
  }

  Future<TaskPromptModel?> getByTaskId(int taskId) async {
    AppLogger.db('Fetching TaskPrompt by taskId=$taskId');
    try {
      final db = await _db;
      final result = await db.query(
        Tables.taskPrompts,
        where: '${TaskPromptFields.taskID} = ?',
        whereArgs: [taskId],
      );
      return result.isNotEmpty ? TaskPromptModel.fromMap(result.first) : null;
    } catch (e, s) {
      AppLogger.error('Error fetching TaskPrompt by taskId=$taskId', e, s);
      return null;
    }
  }

  Future<List<TaskPromptModel>> getAll() async {
    AppLogger.db('Fetching all TaskPrompts');
    try {
      final db = await _db;
      final result = await db.query(Tables.taskPrompts);
      AppLogger.db('Fetched ${result.length} TaskPrompts');
      return result.map(TaskPromptModel.fromMap).toList();
    } catch (e, s) {
      AppLogger.error('Error fetching all TaskPrompts', e, s);
      return [];
    }
  }

  Future<int> update(TaskPromptModel model) async {
    AppLogger.db('Updating TaskPrompt ID=${model.promptID}');
    try {
      final db = await _db;
      final rows = await db.update(
        Tables.taskPrompts,
        model.toMap(),
        where: '${TaskPromptFields.promptID} = ?',
        whereArgs: [model.promptID],
      );
      AppLogger.db('Updated $rows TaskPrompt(s)');
      return rows;
    } catch (e, s) {
      AppLogger.error('Error updating TaskPrompt ID=${model.promptID}', e, s);
      return 0;
    }
  }

  Future<int> delete(int id) async {
    AppLogger.db('Deleting TaskPrompt ID=$id');
    try {
      final db = await _db;
      final count = await db.delete(
        Tables.taskPrompts,
        where: '${TaskPromptFields.promptID} = ?',
        whereArgs: [id],
      );
      AppLogger.db('Deleted $count TaskPrompt(s)');
      return count;
    } catch (e, s) {
      AppLogger.error('Error deleting TaskPrompt ID=$id', e, s);
      return 0;
    }
  }

  Future<bool> exists(String promptId) async {
    final db = await _db;
    final result = await db.query(
      Tables.taskPrompts,
      where: '${TaskPromptFields.promptID} = ?',
      whereArgs: [promptId],
      limit: 1,
    );
    return result.isNotEmpty;
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_prompt\data\task_prompt_model.dart ===
import '../../task_prompt/domain/task_prompt_entity.dart';
import 'task_prompt_constants.dart';

class TaskPromptModel extends TaskPromptEntity {
  const TaskPromptModel({
    super.promptID,
    required super.taskID,
    required super.filePath,
    super.transcription,
  });

  factory TaskPromptModel.fromMap(Map<String, dynamic> map) {
    return TaskPromptModel(
      promptID: map[TaskPromptFields.promptID] as int?,
      taskID: map[TaskPromptFields.taskID] as int, //
      filePath: map[TaskPromptFields.filePath] as String,
      transcription: map[TaskPromptFields.transcription] as String?,
    );
  }

  Map<String, dynamic> toMap() => {
    TaskPromptFields.promptID: promptID,
    TaskPromptFields.taskID: taskID,
    TaskPromptFields.filePath: filePath,
    TaskPromptFields.transcription: transcription,
  };

  factory TaskPromptModel.fromEntity(TaskPromptEntity entity) =>
      TaskPromptModel(
        promptID: entity.promptID,
        taskID: entity.taskID,
        filePath: entity.filePath,
        transcription: entity.transcription,
      );

  TaskPromptEntity toEntity() => TaskPromptEntity(
    promptID: promptID,
    taskID: taskID,
    filePath: filePath,
    transcription: transcription,
  );
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_prompt\data\task_prompt_repository_impl.dart ===
import '../../task_prompt/domain/task_prompt_entity.dart';
import '../../task_prompt/domain/task_prompt_repository.dart';
import '../../task_prompt/data/task_prompt_local_datasource.dart';
import '../../task_prompt/data/task_prompt_model.dart';

class TaskPromptRepositoryImpl implements TaskPromptRepository {
  final TaskPromptLocalDataSource localDataSource;

  TaskPromptRepositoryImpl({required this.localDataSource});

  @override
  Future<int?> insert(TaskPromptEntity entity) async {
    final model = TaskPromptModel.fromEntity(entity);
    return await localDataSource.insert(model);
  }

  @override
  Future<TaskPromptEntity?> getById(int id) async {
    final model = await localDataSource.getById(id);
    return model?.toEntity();
  }

  @override
  Future<TaskPromptEntity?> getByTaskId(int taskId) async {
    final model = await localDataSource.getByTaskId(taskId);
    return model?.toEntity();
  }

  @override
  Future<List<TaskPromptEntity>> getAll() async {
    final models = await localDataSource.getAll();
    return models.map((m) => m.toEntity()).toList();
  }

  @override
  Future<int> update(TaskPromptEntity entity) async {
    final model = TaskPromptModel.fromEntity(entity);
    return await localDataSource.update(model);
  }

  @override
  Future<int> delete(int id) async {
    return await localDataSource.delete(id);
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_prompt\domain\task_prompt_entity.dart ===
class TaskPromptEntity {
  final int? promptID;
  final int taskID;
  final String filePath;
  final String? transcription;

  const TaskPromptEntity({
    this.promptID,
    required this.taskID,
    required this.filePath,
    this.transcription,
  });

  TaskPromptEntity copyWith({
    int? promptID,
    int? taskId,
    String? filePath,
    String? transcription,
  }) {
    return TaskPromptEntity(
      promptID: promptID ?? this.promptID,
      taskID: taskId ?? this.taskID,
      filePath: filePath ?? this.filePath,
      transcription: transcription ?? this.transcription,
    );
  }

  @override
  String toString() =>
      'TaskPromptEntity(id: $promptID, taskId: $taskID, filePath: $filePath, transcription: $transcription)';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_prompt\domain\task_prompt_repository.dart ===
import 'task_prompt_entity.dart';

abstract class TaskPromptRepository {
  Future<int?> insert(TaskPromptEntity entity);
  Future<TaskPromptEntity?> getById(int id);
  Future<TaskPromptEntity?> getByTaskId(int taskId);
  Future<List<TaskPromptEntity>> getAll();
  Future<int> update(TaskPromptEntity entity);
  Future<int> delete(int id);
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\main.dart ===
import 'dart:ui';

import 'package:fluent_ui/fluent_ui.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:sqflite_common_ffi/sqflite_ffi.dart';

import 'core/router.dart';
import 'core/theme/app_theme.dart';
import 'core/logger/app_logger.dart';
import 'shared/encryption/deterministic_encryption_helper.dart';

Future<void> initDatabaseFactory() async {
  AppLogger.info('Initializing database factory...');
  sqfliteFfiInit();
  databaseFactory = databaseFactoryFfi;
  AppLogger.info('‚úÖ Database factory initialized using FFI');
}

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  AppLogger.info('Flutter bindings initialized');
  // üîó Connect helper to Flutter logger (debug-only inside AppLogger)
  DeterministicEncryptionHelper.configureLogger(
    info: AppLogger.info,
    error: AppLogger.error,
  );

  // üî• Register Flutter logger for encryption helper
  DeterministicEncryptionHelper.configureLogger(
    info: AppLogger.info,
    error: AppLogger.error,
  );

  await initDatabaseFactory();

  FlutterError.onError = (FlutterErrorDetails details) {
    AppLogger.error('Flutter framework error', details.exception, details.stack);
  };

  PlatformDispatcher.instance.onError = (error, stack) {
    AppLogger.error('Uncaught async error', error, stack);
    return true;
  };

  AppLogger.info('üöÄ Application starting...');
  runApp(const ProviderScope(child: StartupApp()));
}

class StartupApp extends StatelessWidget {
  const StartupApp({super.key});

  @override
  Widget build(BuildContext context) {
    AppLogger.info('üèóÔ∏è Building StartupApp widget tree');
    return FluentApp.router(
      title: 'Novo Cogni',
      debugShowCheckedModeBanner: false,
      themeMode: ThemeMode.system,
      theme: AppTheme.light,
      darkTheme: AppTheme.dark,
      routerConfig: router,
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\providers\auth_providers.dart ===
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../features/auth/application/login_notifier.dart';
import '../features/auth/data/auth_local_datasource.dart';
import '../features/auth/data/auth_repository_impl.dart';
import '../features/auth/domain/auth_repository.dart';
import 'database_provider.dart'; // ‚úÖ FIX

final authRepositoryProvider = FutureProvider<AuthRepository>((ref) async {
  final dbHelper = ref.watch(databaseProvider);
  final db = await dbHelper.database;
  return AuthRepositoryImpl(AuthLocalDataSource(db));
});


final loginProvider = AsyncNotifierProvider.autoDispose<LoginNotifier, bool>(
      () => LoginNotifier(),
);


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\providers\database_provider.dart ===
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../core/database/prod_database_helper.dart';

final databaseProvider = Provider((_) => ProdDatabaseHelper.instance);


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\providers\environment_provider.dart ===
import 'package:hooks_riverpod/hooks_riverpod.dart';
import '../core/environment.dart';


final environmentProvider = Provider<AppEnv>((ref) {
  return AppEnv.local;
});


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\providers\evaluator_providers.dart ===
import 'package:hooks_riverpod/hooks_riverpod.dart';
import '../../features/evaluator/data/evaluator_model.dart';

final currentUserProvider =
NotifierProvider<CurrentUserNotifier, EvaluatorModel?>(
  CurrentUserNotifier.new,
);

class CurrentUserNotifier extends Notifier<EvaluatorModel?> {
  @override
  EvaluatorModel? build() => null;

  void setUser(EvaluatorModel? user) => state = user;
  void clearUser() => state = null;
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\providers\participant_providers.dart ===
import 'package:hooks_riverpod/hooks_riverpod.dart';

import '../core/database/base_database_helper.dart';
import '../core/database/prod_database_helper.dart';
import '../core/logger/app_logger.dart';
import '../features/participant/domain/participant_entity.dart';
import '../features/participant/presentation/create_participant_evaluation_notifier.dart';

/// DB Provider for participants (used in production)
final participantDbHelperProvider = Provider<BaseDatabaseHelper>((ref) {
  AppLogger.db('Providing ProdDatabaseHelper.instance (participant_providers)');
  return ProdDatabaseHelper.instance;
});

/// Notifier to create participant + evaluation hierarchy
final createParticipantEvaluationProvider =
AsyncNotifierProvider<CreateParticipantEvaluationNotifier, ParticipantEntity?>
(
      () {
    AppLogger.info(
      'Initializing CreateParticipantEvaluationNotifier via createParticipantEvaluationProvider',
    );
    return CreateParticipantEvaluationNotifier();
  },
);


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\providers\providers.dart ===
export 'auth_providers.dart';
export 'evaluator_providers.dart';
export 'participant_providers.dart';
export 'startup_provider.dart';
export 'environment_provider.dart';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\providers\startup_provider.dart ===
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/logger/app_logger.dart';
import '../../features/evaluator/data/evaluator_local_datasource.dart';
import '../core/database/prod_database_helper.dart';

enum StartupState { ready }

final startupProvider =
FutureProvider<StartupState>((ref) async {
  AppLogger.info('[STARTUP] Checking evaluator presence...');
  final db = await ProdDatabaseHelper.instance.database;
  final evaluatorDS = EvaluatorLocalDataSource(db);

  final evaluators = await evaluatorDS.getAll();

  if (evaluators.isEmpty) {
    AppLogger.warning(
        '[STARTUP] No evaluators found ‚Äî seeder might not have run yet');
  } else {
    AppLogger.info(
        '[STARTUP] Found ${evaluators.length} evaluator(s), proceeding to login');
  }

  return StartupState.ready;
});


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\evaluators\evaluator_seed.dart ===
import 'package:sqflite_common/sqlite_api.dart';
import '../../core/logger/app_logger.dart';
import '../../core/constants/database_constants.dart';
import '../../features/evaluator/application/evaluator_secure_service.dart';
import '../../features/evaluator/data/evaluator_model.dart';
import '../../features/evaluator/data/evaluator_model_extensions.dart';

Future<void> seedDummyEvaluator(DatabaseExecutor db) async {
  AppLogger.seed('[DUMMY] Seeding dummy evaluator...');

  final evaluator = EvaluatorModel(
    evaluatorId: 1,
    name: 'Demo',
    surname: 'User',
    email: 'demo@example.com',
    birthDate: '1998-07-14',
    specialty: 'Psicologia',
    cpfOrNif: '03240120010',
    username: 'demo',
    password: '0000', // will be hashed
    firstLogin: true,
  );

  final secured = EvaluatorSecureService.encrypt(evaluator);

  await db.insert(
    Tables.evaluators,
    secured.toMap(),
    conflictAlgorithm: ConflictAlgorithm.replace,
  );

  AppLogger.seed('[DUMMY] ‚úÖ Dummy evaluator inserted (secured).');
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\modules\modules_seeds.dart ===
library module_seeds;

import 'package:sqflite_common_ffi/sqflite_ffi.dart';

import '../../core/constants/database_constants.dart';
import '../../core/logger/app_logger.dart';

import '../../features/module/data/module_constants.dart';
import '../../features/module/data/module_model.dart';
import '../../features/module/domain/module_entity.dart';

part 'modules_seeds_constants.dart';

final ModuleEntity sociodemographicInfoModule = ModuleEntity(
  moduleID: sociodemographicInfoId,
  title: sociodemographicInfo,
);

final ModuleEntity cognitiveFunctionsModule = ModuleEntity(
  moduleID: cognitiveFunctionsId,
  title: cognitiveFunctions,
);

final ModuleEntity functionalityModule = ModuleEntity(
  moduleID: functionalityId,
  title: functionality,
);

final ModuleEntity depressionSymptomsModule = ModuleEntity(
  moduleID: depressionSymptomsId,
  title: depressionSymptoms,
);

/// Optional module for internal tests/validation
final ModuleEntity testsModule = ModuleEntity(
  moduleID: testsModuleId,
  title: testsModuleTitle,
);

final List<ModuleEntity> modulesList = [
  sociodemographicInfoModule,
  cognitiveFunctionsModule,
  functionalityModule,
  depressionSymptomsModule,
  testsModule,
];

/// --- mapping ---

extension ModuleEntityMapper on ModuleEntity {
  ModuleModel toModel() {
    return ModuleModel(
      moduleID: moduleID,
      title: title,
      // adapt if ModuleModel has more fields, e.g.:
      // testOnly: moduleID == testsModuleId,
    );
  }
}

/// --- seeder ---

final List<Map<String, dynamic>> modulesSeedData = modulesList
    .map((e) => e.toModel().toMap())
    .toList();


Future<void> seedModules(DatabaseExecutor db) async {
  AppLogger.seed('[MODULES] Seeding modules...');

  for (final module in modulesSeedData) {
    await db.insert(
      Tables.modules,
      module,
      conflictAlgorithm: ConflictAlgorithm.ignore,
    );
    AppLogger.seed('[MODULES] Seeded module: ${module['name']} (id=${module['module_id']})');
  }

  AppLogger.seed('[MODULES] Done seeding modules.');
}
void printModules() {
  for (var i = 0; i < modulesList.length; i++) {
    AppLogger.seed('Module ${modulesList[i].moduleID}: ${modulesList[i].title}');
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\modules\modules_seeds_constants.dart ===
part of module_seeds;

const int sociodemographicInfoId = 1;
const String sociodemographicInfo = 'Dados Pessoais';

const int cognitiveFunctionsId = 2;
const String cognitiveFunctions = 'Fun√ß√µes Cognitivas';

const int functionalityId = 3;
const String functionality = 'Funcionalidade';

const int depressionSymptomsId = 4;
const String depressionSymptoms = 'Sintomas de Depress√£o';

// M√≥dulo t√©cnico para valida√ß√£o / testes internos
const int testsModuleId = 9001;
const String testsModuleTitle = 'Teste de √Åudio e Grava√ß√£o';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\prompts\prompts_seed.dart ===
library prompts_seeds;

import 'package:sqflite_common_ffi/sqflite_ffi.dart';

import '../../core/constants/database_constants.dart';
import '../../core/logger/app_logger.dart';
import '../../features/task_prompt/data/task_prompt_constants.dart';
import '../../features/task_prompt/data/task_prompt_model.dart';
import '../../features/task_prompt/domain/task_prompt_entity.dart';
import '../../core/constants/audio_file_paths.dart';

import '../tasks/task_seeds.dart';

part 'prompts_seeds_constants.dart';
part 'prompts_seeds_list.dart';

extension TaskPromptEntityMapper on TaskPromptEntity {
  TaskPromptModel toModel() {
    return TaskPromptModel(
      promptID: promptID,
      taskID: taskID,
      filePath: filePath,
      transcription: transcription,
    );
  }
}

Future<void> seedPrompts(DatabaseExecutor  db) async {
  AppLogger.seed('[PROMPTS] Seeding prompts...');

  for (final prompt in tasksPromptsList) {
    final result = await db.query(
      Tables.taskPrompts,
      where: '${TaskPromptFields.promptID} = ?',
      whereArgs: [prompt.promptID],
    );

    if (result.isEmpty) {
      await db.insert(Tables.taskPrompts, prompt.toModel().toMap());
      AppLogger.seed(
        '[PROMPTS] Seeded prompt: ${prompt.promptID} ‚Üí ${prompt.filePath}',
      );
    } else {
      AppLogger.debug(
        '[PROMPTS] Skipped existing prompt: ${prompt.promptID}',
      );
    }
  }

  AppLogger.seed('[PROMPTS] Done seeding prompts.');
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\prompts\prompts_seeds_constants.dart ===
part of prompts_seeds;

// 1‚Äì56: main protocol
const int helloHowAreYouTaskPromptID = 1;
const int whatsYourNameTaskPromptID = 2;
const int whatsYourDOBTaskPromptID = 3;
const int whatsYourEducationLevelTaskPromptID = 4;
const int whatWasYourProfessionTaskPromptID = 5;

const int whoDoYouLiveWithTaskPromptID = 6;
const int doYouExerciseFrequentlyTaskPromptID = 7;
const int doYouReadFrequentlyTaskPromptID = 8;
const int doYouPlayPuzzlesOrVideoGamesFrequentlyTaskPromptID = 9;
const int doYouHaveAnyDiseaseTaskPromptID = 10;

const int payCloseAttentionTaskPromptID = 11;
const int subtracting3AndAgainTaskPromptID = 12;
const int whatYearAreWeInTaskPromptID = 13;
const int whatMonthAreWeInTaskPromptID = 14;
const int whatDayOfTheMonthIsItTaskPromptID = 15;

const int whatDayOfTheWeekIsItTaskPromptID = 16;
const int howOldAreYouTaskPromptID = 17;
const int whereAreWeNowTaskPromptID = 18;
const int currentPresidentOfBrazilTaskPromptID = 19;
const int formerPresidentOfBrazilTaskPromptID = 20;

const int repeatWordsAfterListeningFirstTimeTaskPromptID = 21;
const int recallWordsFromListFirstTimeTaskPromptID = 22;
const int repeatWordsAfterListeningSecondTimeTaskPromptID = 23;
const int recallWordsFromListSecondTimeTaskPromptID = 24;
const int repeatWordsAfterListeningThirdTimeTaskPromptID = 25;

const int recallWordsFromListThirdTimeTaskPromptID = 26;
const int whatDidYouDoYesterdayTaskPromptID = 27;
const int favoriteChildhoodGameTaskPromptID = 28;
const int retellWordsHeardBeforeTaskPromptID = 29;
const int payCloseAttentionToTheStoryTaskPromptID = 30;

const int anasCatStoryTaskPromptID = 31;
const int howManyAnimalsCanYouThinkOfTaskPromptID = 32;
const int wordsStartingWithFTaskPromptID = 33;
const int wordsStartingWithATaskPromptID = 34;
const int wordsStartingWithSTaskPromptID = 35;

const int describeWhatYouSeeTaskPromptID = 36;
const int retellStoryTaskPromptID = 37;
const int yesOrNoQuestionsTaskPromptID = 38;
const int canYouBatheAloneTaskPromptID = 39;
const int canYouDressAloneTaskPromptID = 40;

const int canYouUseToiletAloneTaskPromptID = 41;
const int canYouUsePhoneAloneTaskPromptID = 42;
const int canYouShopAloneTaskPromptID = 43;
const int canYouHandleMoneyAloneTaskPromptID = 44;
const int canYouManageMedicationAloneTaskPromptID = 45;

const int canYouUseTransportAloneTaskPromptID = 46;
const int feelingsInPastTwoWeeksTaskPromptID = 47;
const int feelingSadFrequentlyTaskPromptID = 48;
const int feelingTiredOrLackingEnergyTaskPromptID = 49;
const int troubleSleepingTaskPromptID = 50;

const int preferringToStayHomeTaskPromptID = 51;
const int feelingUselessOrGuiltyTaskPromptID = 52;
const int lostInterestInActivitiesTaskPromptID = 53;
const int hopefulAboutFutureTaskPromptID = 54;
const int feelingLifeIsWorthLivingTaskPromptID = 55;

const int thankingForParticipationTaskPromptID = 56;

// 9001+ : technical / validation prompts
const int aPressaEhInimigaTaskPromptId = 9001;
const int conteAte5taskPromptID = 9004;


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\prompts\prompts_seeds_list.dart ===
part of prompts_seeds;

final helloHowAreYouPrompt = TaskPromptEntity(
  promptID: helloHowAreYouTaskPromptID,
  taskID: helloHowAreYouTask.taskID!,
  filePath: AudioFilePaths.hello_how_are_you,
  transcription:
  "Ol√°, tudo bem! Agora vou fazer algumas perguntas para conhecer voc√™ melhor.",
);

final whatsYourNamePrompt = TaskPromptEntity(
  promptID: whatsYourNameTaskPromptID,
  taskID: whatsYourNameTask.taskID!,
  filePath: AudioFilePaths.whats_your_name,
  transcription: "Qual o seu nome?",
);

// ...continue the same pattern for ALL prompts 3‚Äì56...

final thankingForParticipationPrompt = TaskPromptEntity(
  promptID: thankingForParticipationTaskPromptID,
  taskID: thankingForParticipationTask.taskID!,
  filePath: AudioFilePaths.thanking_for_participation,
  transcription: "Obrigado pela sua participa√ß√£o.",
);

// Validation / test-only
final aPressaEhInimigaTaskPrompt = TaskPromptEntity(
  promptID: aPressaEhInimigaTaskPromptId,
  taskID: pressaInimigaTask.taskID!,
  filePath: AudioFilePaths.aPressaEhInimiga,
  transcription: "",
);

final conteAteh5TaskPrompt = TaskPromptEntity(
  promptID: conteAte5taskPromptID,
  taskID: conteAte5Task.taskID!,
  filePath: AudioFilePaths.conteAte5,
  transcription: "",
);

List<TaskPromptEntity> tasksPromptsList = [
  // main protocol (1‚Äì56) in exact ID order:
  helloHowAreYouPrompt,
  whatsYourNamePrompt,
  // ...
  thankingForParticipationPrompt,

  // test / validation prompts at the end:
  aPressaEhInimigaTaskPrompt,
  conteAteh5TaskPrompt,
];


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\seed_runner.dart ===
import 'package:sqflite_common/sqlite_api.dart'; // <-- to access DatabaseExecutor
import '../core/logger/app_logger.dart';
import 'modules/modules_seeds.dart';
import 'tasks/task_seeds.dart';
import 'prompts/prompts_seed.dart';
import 'evaluators/evaluator_seed.dart';

class SeedRunner {
  /// Runs all database seeders using the given database executor.
  Future<void> run({required DatabaseExecutor db}) async {
    AppLogger.seed('Starting database seeding...');

    try {
      await seedModules(db);
      await seedTasks(db);
      await seedPrompts(db);
      await seedDummyEvaluator(db);

      AppLogger.seed('‚úÖ Database seeding complete.');
    } catch (e, s) {
      AppLogger.error('‚ùå Database seeding failed', e, s);
      rethrow;
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\tasks\task_seeds.dart ===
library task_seeds;

import 'package:sqflite_common_ffi/sqflite_ffi.dart';

import '../../core/constants/database_constants.dart';
import '../../core/logger/app_logger.dart';
import '../../core/constants/enums/task_mode.dart';
import '../../features/task/data/task_constants.dart';
import '../../features/task/data/task_model.dart';
import '../../features/task/domain/task_entity.dart';
import '../modules/modules_seeds.dart';

part 'task_seeds_constants.dart';
part 'task_seeds_list.dart';

Future<void> seedTasks(DatabaseExecutor  db) async {
  AppLogger.seed('[TASKS] Seeding tasks...');

  for (final task in tasksList) {
    final result = await db.query(
      Tables.tasks,
      where: '${TaskFields.id} = ?',
      whereArgs: [task.taskID],
    );

    if (result.isEmpty) {
      await db.insert(Tables.tasks, task.toModel().toMap());
      AppLogger.seed(
        '[TASKS] Seeded task: ${task.title} (module ${task.moduleID})',
      );
    } else {
      AppLogger.debug('[TASKS] Skipped existing task: ${task.title}');
    }
  }

  AppLogger.seed('[TASKS] Done seeding tasks.');
}

extension TaskEntityMapper on TaskEntity {
  TaskModel toModel() {
    return TaskModel(
      taskID: taskID,
      moduleID: moduleID,
      title: title,
      transcript: transcript,
      taskMode: taskMode,
      position: position,
      imagePath: imagePath,
      timeForCompletion: timeForCompletion,
      mayRepeatPrompt: mayRepeatPrompt,
      testOnly: testOnly,
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\tasks\task_seeds_constants.dart ===
part of task_seeds;

/// IDs & titles for all tasks.
/// Keep these in sync with prompts and audio files.

// Sociodemographic
const int helloHowAreYouTaskID = 1;
const String helloHowAreYouTaskTitle = 'Seja bem-vindo';

const int whatsYourNameTaskID = 2;
const String whatsYourNameTaskTitle = 'Dados pessoais - nome';

const int whatsYourDOBTaskID = 3;
const String whatsYourDOBTaskTitle = 'Dados pessoais - nascimento';

const int whatsYourEducationLevelTaskID = 4;
const String whatsYourEducationLevelTaskTitle = 'Escolaridade';

const int whatWasYourProfessionTaskID = 5;
const String whatWasYourProfessionTaskTitle = 'Profiss√£o';

const int whoDoYouLiveWithTaskID = 6;
const String whoDoYouLiveWithTaskTitle = 'Com quem mora';

const int doYouExerciseFrequentlyTaskID = 7;
const String doYouExerciseFrequentlyTaskTitle = 'Exerc√≠cios f√≠sicos';

const int doYouReadFrequentlyTaskID = 8;
const String doYouReadFrequentlyTaskTitle = 'Leitura';

const int doYouPlayPuzzlesOrVideoGamesFrequentlyTaskID = 9;
const String doYouPlayPuzzlesOrVideoGamesFrequentlyTaskTitle =
    'Jogos e passatempos';

const int doYouHaveAnyDiseasesTaskID = 10;
const String doYouHaveAnyDiseasesTaskTitle = 'Doen√ßas diagnosticadas';

// Cognitive functions
const int payCloseAttentionTaskID = 11;
const String payCloseAttentionTaskTitle = 'Preste bastante aten√ß√£o';

const int subtracting3AndAgainTaskID = 12;
const String subtracting3AndAgainTaskTitle = 'C√°lculo seriado';

const int whatYearAreWeInTaskID = 13;
const String whatYearAreWeInTaskTitle = 'Em que ano estamos?';

const int whatMonthAreWeInTaskID = 14;
const String whatMonthAreWeInTaskTitle = 'Em que m√™s estamos?';

const int whatDayOfTheMonthIsItTaskID = 15;
const String whatDayOfTheMonthIsItTaskTitle = 'Que dia do m√™s √© hoje?';

const int whatDayOfTheWeekIsItTaskID = 16;
const String whatDayOfTheWeekIsItTaskTitle = 'Que dia da semana √© hoje?';

const int howOldAreYouTaskID = 17;
const String howOldAreYouTaskTitle = 'Qual a sua idade?';

const int whereAreWeNowTaskID = 18;
const String whereAreWeNowTaskTitle = 'Onde estamos agora?';

const int currentPresidentOfBrazilTaskID = 19;
const String currentPresidentOfBrazilTaskTitle =
    'Quem √© o atual presidente do Brasil?';

const int formerPresidentOfBrazilTaskID = 20;
const String formerPresidentOfBrazilTaskTitle =
    'Quem foi o presidente anterior?';

const int repeatWordsAfterListeningFirstTimeTaskID = 21;
const String repeatWordsAfterListeningFirstTimeTaskTitle =
    'Repetir palavras (1¬™ vez)';

const int recallWordsFromListFirstTimeTaskID = 22;
const String recallWordsFromListFirstTimeTaskTitle =
    'Recordar palavras (1¬™ vez)';

const int repeatWordsAfterListeningSecondTimeTaskID = 23;
const String repeatWordsAfterListeningSecondTimeTaskTitle =
    'Repetir palavras (2¬™ vez)';

const int recallWordsFromListSecondTimeTaskID = 24;
const String recallWordsFromListSecondTimeTaskTitle =
    'Recordar palavras (2¬™ vez)';

const int repeatWordsAfterListeningThirdTimeTaskID = 25;
const String repeatWordsAfterListeningThirdTimeTaskTitle =
    'Repetir palavras (3¬™ vez)';

const int recallWordsFromListThirdTimeTaskID = 26;
const String recallWordsFromListThirdTimeTaskTitle =
    'Recordar palavras (3¬™ vez)';

const int whatDidYouDoYesterdayTaskID = 27;
const String whatDidYouDoYesterdayTaskTitle =
    'O que voc√™ fez ontem?';

const int favoriteChildhoodGameTaskID = 28;
const String favoriteChildhoodGameTaskTitle =
    'Brincadeira favorita na inf√¢ncia';

const int retellWordsHeardBeforeTaskID = 29;
const String retellWordsHeardBeforeTaskTitle =
    'Repetir palavras ouvidas anteriormente';

const int payCloseAttentionToTheStoryTaskID = 30;
const String payCloseAttentionToTheStoryTaskTitle =
    'Preste aten√ß√£o na hist√≥ria';

const int anasCatStoryTaskID = 31;
const String anasCatStoryTaskTitle = 'Hist√≥ria do gato da Ana';

const int howManyAnimalsCanYouThinkOfTaskID = 32;
const String howManyAnimalsCanYouThinkOfTaskTitle =
    'Quantos animais voc√™ consegue dizer?';

const int wordsStartingWithFTaskID = 33;
const String wordsStartingWithFTaskTitle =
    'Palavras iniciadas com a letra F';

const int wordsStartingWithATaskID = 34;
const String wordsStartingWithATaskTitle =
    'Palavras iniciadas com a letra A';

const int wordsStartingWithSTaskID = 35;
const String wordsStartingWithSTaskTitle =
    'Palavras iniciadas com a letra S';

const int describeWhatYouSeeTaskID = 36;
const String describeWhatYouSeeTaskTitle =
    'Descreva o que voc√™ v√™';

const int retellStoryTaskID = 37;
const String retellStoryTaskTitle = 'Conte a hist√≥ria novamente';

// Functionality
const int yesOrNoQuestionsTaskID = 38;
const String yesOrNoQuestionsTaskTitle =
    'Perguntas de sim ou n√£o';

const int canYouBatheAloneTaskID = 39;
const String canYouBatheAloneTaskTitle = 'Banho sozinho';

const int canYouDressAloneTaskID = 40;
const String canYouDressAloneTaskTitle = 'Vestir-se sozinho';

const int canYouUseToiletAloneTaskID = 41;
const String canYouUseToiletAloneTaskTitle = 'Usar o banheiro sozinho';

const int canYouUsePhoneAloneTaskID = 42;
const String canYouUsePhoneAloneTaskTitle = 'Usar o telefone';

const int canYouShopAloneTaskID = 43;
const String canYouShopAloneTaskTitle = 'Fazer compras';

const int canYouHandleMoneyAloneTaskID = 44;
const String canYouHandleMoneyAloneTaskTitle = 'Lidar com dinheiro';

const int canYouManageMedicationAloneTaskID = 45;
const String canYouManageMedicationAloneTaskTitle = 'Medicamentos';

const int canYouUseTransportAloneTaskID = 46;
const String canYouUseTransportAloneTaskTitle = 'Transporte';

// Depression symptoms
const int feelingsInPastTwoWeeksTaskID = 47;
const String feelingsInPastTwoWeeksTaskTitle =
    'Sentimentos nas √∫ltimas duas semanas';

const int feelingSadFrequentlyTaskID = 48;
const String feelingSadFrequentlyTaskTitle = 'Triste frequentemente';

const int feelingTiredOrLackingEnergyTaskID = 49;
const String feelingTiredOrLackingEnergyTaskTitle =
    'Cansa√ßo / falta de energia';

const int troubleSleepingTaskID = 50;
const String troubleSleepingTaskTitle = 'Dificuldade para dormir';

const int preferringToStayHomeTaskID = 51;
const String preferringToStayHomeTaskTitle =
    'Prefer√™ncia por ficar em casa';

const int feelingUselessOrGuiltyTaskID = 52;
const String feelingUselessOrGuiltyTaskTitle =
    'Sentir-se in√∫til ou culpado';

const int lostInterestInActivitiesTaskID = 53;
const String lostInterestInActivitiesTaskTitle =
    'Perda de interesse em atividades';

const int hopefulAboutFutureTaskID = 54;
const String hopefulAboutFutureTaskTitle =
    'Esperan√ßa em rela√ß√£o ao futuro';

const int feelingLifeIsWorthLivingTaskID = 55;
const String feelingLifeIsWorthLivingTaskTitle =
    'Sentir que a vida vale a pena';

const int thankingForParticipationTaskID = 56;
const String thankingForParticipationTaskTitle =
    'Agradecimento pela participa√ß√£o';

// Test / verification
const int pressaInimigaTaskID = 9001;
const String pressaInimigaTaskTitle = 'A pressa √© inimiga da perfei√ß√£o';

const int conteAte5TaskID = 9002;
const String conteAte5TaskTitle = 'Conte at√© 5';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\tasks\task_seeds_list.dart ===
part of task_seeds;

// Helper: default transcript = '' unless specified.

/// --- Sociodemographic Info ---

final helloHowAreYouTask = TaskEntity(
  taskID: helloHowAreYouTaskID,
  moduleID: sociodemographicInfoId,
  title: helloHowAreYouTaskTitle,
  transcript:
  'Ol√°, tudo bem! Agora vou fazer algumas perguntas para conhecer voc√™ melhor.',
  taskMode: TaskMode.play,
  position: 1,
);

final whatsYourNameTask = TaskEntity(
  taskID: whatsYourNameTaskID,
  moduleID: sociodemographicInfoId,
  title: whatsYourNameTaskTitle,
  taskMode: TaskMode.record,
  position: 2,
);

final whatsYourDOBTask = TaskEntity(
  taskID: whatsYourDOBTaskID,
  moduleID: sociodemographicInfoId,
  title: whatsYourDOBTaskTitle,
  taskMode: TaskMode.record,
  position: 3,
);

final whatsYourEducationLevelTask = TaskEntity(
  taskID: whatsYourEducationLevelTaskID,
  moduleID: sociodemographicInfoId,
  title: whatsYourEducationLevelTaskTitle,
  taskMode: TaskMode.record,
  position: 4,
);

final whatWasYourProfessionTask = TaskEntity(
  taskID: whatWasYourProfessionTaskID,
  moduleID: sociodemographicInfoId,
  title: whatWasYourProfessionTaskTitle,
  taskMode: TaskMode.record,
  position: 5,
);

final whoDoYouLiveWithTask = TaskEntity(
  taskID: whoDoYouLiveWithTaskID,
  moduleID: sociodemographicInfoId,
  title: whoDoYouLiveWithTaskTitle,
  taskMode: TaskMode.record,
  position: 6,
);

final doYouExerciseFrequentlyTask = TaskEntity(
  taskID: doYouExerciseFrequentlyTaskID,
  moduleID: sociodemographicInfoId,
  title: doYouExerciseFrequentlyTaskTitle,
  taskMode: TaskMode.record,
  position: 7,
);

final doYouReadFrequentlyTask = TaskEntity(
  taskID: doYouReadFrequentlyTaskID,
  moduleID: sociodemographicInfoId,
  title: doYouReadFrequentlyTaskTitle,
  taskMode: TaskMode.record,
  position: 8,
);

final doYouPlayPuzzlesOrVideoGamesFrequentlyTask = TaskEntity(
  taskID: doYouPlayPuzzlesOrVideoGamesFrequentlyTaskID,
  moduleID: sociodemographicInfoId,
  title: doYouPlayPuzzlesOrVideoGamesFrequentlyTaskTitle,
  taskMode: TaskMode.record,
  position: 9,
);

final doYouHaveAnyDiseasesTask = TaskEntity(
  taskID: doYouHaveAnyDiseasesTaskID,
  moduleID: sociodemographicInfoId,
  title: doYouHaveAnyDiseasesTaskTitle,
  taskMode: TaskMode.record,
  position: 10,
);

/// --- Cognitive Functions ---

final payCloseAttentionTask = TaskEntity(
  taskID: payCloseAttentionTaskID,
  moduleID: cognitiveFunctionsId,
  title: payCloseAttentionTaskTitle,
  taskMode: TaskMode.play,
  mayRepeatPrompt: true,
  position: 1,
);

final subtracting3AndAgainTask = TaskEntity(
  taskID: subtracting3AndAgainTaskID,
  moduleID: cognitiveFunctionsId,
  title: subtracting3AndAgainTaskTitle,
  taskMode: TaskMode.record,
  position: 2,
);

final whatYearAreWeInTask = TaskEntity(
  taskID: whatYearAreWeInTaskID,
  moduleID: cognitiveFunctionsId,
  title: whatYearAreWeInTaskTitle,
  taskMode: TaskMode.record,
  position: 3,
);

final whatMonthAreWeInTask = TaskEntity(
  taskID: whatMonthAreWeInTaskID,
  moduleID: cognitiveFunctionsId,
  title: whatMonthAreWeInTaskTitle,
  taskMode: TaskMode.record,
  position: 4,
);

final whatDayOfTheMonthIsItTask = TaskEntity(
  taskID: whatDayOfTheMonthIsItTaskID,
  moduleID: cognitiveFunctionsId,
  title: whatDayOfTheMonthIsItTaskTitle,
  taskMode: TaskMode.record,
  position: 5,
);

final whatDayOfTheWeekIsItTask = TaskEntity(
  taskID: whatDayOfTheWeekIsItTaskID,
  moduleID: cognitiveFunctionsId,
  title: whatDayOfTheWeekIsItTaskTitle,
  taskMode: TaskMode.record,
  position: 6,
);

final howOldAreYouTask = TaskEntity(
  taskID: howOldAreYouTaskID,
  moduleID: cognitiveFunctionsId,
  title: howOldAreYouTaskTitle,
  taskMode: TaskMode.record,
  position: 7,
);

final whereAreWeNowTask = TaskEntity(
  taskID: whereAreWeNowTaskID,
  moduleID: cognitiveFunctionsId,
  title: whereAreWeNowTaskTitle,
  taskMode: TaskMode.record,
  position: 8,
);

final currentPresidentOfBrazilTask = TaskEntity(
  taskID: currentPresidentOfBrazilTaskID,
  moduleID: cognitiveFunctionsId,
  title: currentPresidentOfBrazilTaskTitle,
  taskMode: TaskMode.record,
  position: 9,
);

final formerPresidentOfBrazilTask = TaskEntity(
  taskID: formerPresidentOfBrazilTaskID,
  moduleID: cognitiveFunctionsId,
  title: formerPresidentOfBrazilTaskTitle,
  taskMode: TaskMode.record,
  position: 10,
);

final repeatWordsAfterListeningFirstTimeTask = TaskEntity(
  taskID: repeatWordsAfterListeningFirstTimeTaskID,
  moduleID: cognitiveFunctionsId,
  title: repeatWordsAfterListeningFirstTimeTaskTitle,
  taskMode: TaskMode.play,
  mayRepeatPrompt: true,
  position: 11,
);

final recallWordsFromListFirstTimeTask = TaskEntity(
  taskID: recallWordsFromListFirstTimeTaskID,
  moduleID: cognitiveFunctionsId,
  title: recallWordsFromListFirstTimeTaskTitle,
  taskMode: TaskMode.record,
  position: 12,
);

final repeatWordsAfterListeningSecondTimeTask = TaskEntity(
  taskID: repeatWordsAfterListeningSecondTimeTaskID,
  moduleID: cognitiveFunctionsId,
  title: repeatWordsAfterListeningSecondTimeTaskTitle,
  taskMode: TaskMode.play,
  mayRepeatPrompt: true,
  position: 13,
);

final recallWordsFromListSecondTimeTask = TaskEntity(
  taskID: recallWordsFromListSecondTimeTaskID,
  moduleID: cognitiveFunctionsId,
  title: recallWordsFromListSecondTimeTaskTitle,
  taskMode: TaskMode.record,
  position: 14,
);

final repeatWordsAfterListeningThirdTimeTask = TaskEntity(
  taskID: repeatWordsAfterListeningThirdTimeTaskID,
  moduleID: cognitiveFunctionsId,
  title: repeatWordsAfterListeningThirdTimeTaskTitle,
  taskMode: TaskMode.play,
  mayRepeatPrompt: true,
  position: 15,
);

final recallWordsFromListThirdTimeTask = TaskEntity(
  taskID: recallWordsFromListThirdTimeTaskID,
  moduleID: cognitiveFunctionsId,
  title: recallWordsFromListThirdTimeTaskTitle,
  taskMode: TaskMode.record,
  position: 16,
);

final whatDidYouDoYesterdayTask = TaskEntity(
  taskID: whatDidYouDoYesterdayTaskID,
  moduleID: cognitiveFunctionsId,
  title: whatDidYouDoYesterdayTaskTitle,
  taskMode: TaskMode.record,
  position: 17,
);

final favoriteChildhoodGameTask = TaskEntity(
  taskID: favoriteChildhoodGameTaskID,
  moduleID: cognitiveFunctionsId,
  title: favoriteChildhoodGameTaskTitle,
  taskMode: TaskMode.record,
  position: 18,
);

final retellWordsHeardBeforeTask = TaskEntity(
  taskID: retellWordsHeardBeforeTaskID,
  moduleID: cognitiveFunctionsId,
  title: retellWordsHeardBeforeTaskTitle,
  taskMode: TaskMode.record,
  position: 19,
);

final payCloseAttentionToTheStoryTask = TaskEntity(
  taskID: payCloseAttentionToTheStoryTaskID,
  moduleID: cognitiveFunctionsId,
  title: payCloseAttentionToTheStoryTaskTitle,
  taskMode: TaskMode.play,
  mayRepeatPrompt: true,
  position: 20,
);

final anasCatStoryTask = TaskEntity(
  taskID: anasCatStoryTaskID,
  moduleID: cognitiveFunctionsId,
  title: anasCatStoryTaskTitle,
  taskMode: TaskMode.record,
  position: 21,
);

final howManyAnimalsCanYouThinkOfTask = TaskEntity(
  taskID: howManyAnimalsCanYouThinkOfTaskID,
  moduleID: cognitiveFunctionsId,
  title: howManyAnimalsCanYouThinkOfTaskTitle,
  taskMode: TaskMode.record,
  position: 22,
);

final wordsStartingWithFTask = TaskEntity(
  taskID: wordsStartingWithFTaskID,
  moduleID: cognitiveFunctionsId,
  title: wordsStartingWithFTaskTitle,
  taskMode: TaskMode.record,
  position: 23,
);

final wordsStartingWithATask = TaskEntity(
  taskID: wordsStartingWithATaskID,
  moduleID: cognitiveFunctionsId,
  title: wordsStartingWithATaskTitle,
  taskMode: TaskMode.record,
  position: 24,
);

final wordsStartingWithSTask = TaskEntity(
  taskID: wordsStartingWithSTaskID,
  moduleID: cognitiveFunctionsId,
  title: wordsStartingWithSTaskTitle,
  taskMode: TaskMode.record,
  position: 25,
);

final describeWhatYouSeeTask = TaskEntity(
  taskID: describeWhatYouSeeTaskID,
  moduleID: cognitiveFunctionsId,
  title: describeWhatYouSeeTaskTitle,
  taskMode: TaskMode.record,
  position: 26,
);

final retellStoryTask = TaskEntity(
  taskID: retellStoryTaskID,
  moduleID: cognitiveFunctionsId,
  title: retellStoryTaskTitle,
  taskMode: TaskMode.record,
  position: 27,
);

/// --- Functionality ---

final yesOrNoQuestionsTask = TaskEntity(
  taskID: yesOrNoQuestionsTaskID,
  moduleID: functionalityId,
  title: yesOrNoQuestionsTaskTitle,
  taskMode: TaskMode.play,
  position: 1,
);

final canYouBatheAloneTask = TaskEntity(
  taskID: canYouBatheAloneTaskID,
  moduleID: functionalityId,
  title: canYouBatheAloneTaskTitle,
  taskMode: TaskMode.record,
  position: 2,
);

final canYouDressAloneTask = TaskEntity(
  taskID: canYouDressAloneTaskID,
  moduleID: functionalityId,
  title: canYouDressAloneTaskTitle,
  taskMode: TaskMode.record,
  position: 3,
);

final canYouUseToiletAloneTask = TaskEntity(
  taskID: canYouUseToiletAloneTaskID,
  moduleID: functionalityId,
  title: canYouUseToiletAloneTaskTitle,
  taskMode: TaskMode.record,
  position: 4,
);

final canYouUsePhoneAloneTask = TaskEntity(
  taskID: canYouUsePhoneAloneTaskID,
  moduleID: functionalityId,
  title: canYouUsePhoneAloneTaskTitle,
  taskMode: TaskMode.record,
  position: 5,
);

final canYouShopAloneTask = TaskEntity(
  taskID: canYouShopAloneTaskID,
  moduleID: functionalityId,
  title: canYouShopAloneTaskTitle,
  taskMode: TaskMode.record,
  position: 6,
);

final canYouHandleMoneyAloneTask = TaskEntity(
  taskID: canYouHandleMoneyAloneTaskID,
  moduleID: functionalityId,
  title: canYouHandleMoneyAloneTaskTitle,
  taskMode: TaskMode.record,
  position: 7,
);

final canYouManageMedicationAloneTask = TaskEntity(
  taskID: canYouManageMedicationAloneTaskID,
  moduleID: functionalityId,
  title: canYouManageMedicationAloneTaskTitle,
  taskMode: TaskMode.record,
  position: 8,
);

final canYouUseTransportAloneTask = TaskEntity(
  taskID: canYouUseTransportAloneTaskID,
  moduleID: functionalityId,
  title: canYouUseTransportAloneTaskTitle,
  taskMode: TaskMode.record,
  position: 9,
);

/// --- Depression Symptoms ---

final feelingsInPastTwoWeeksTask = TaskEntity(
  taskID: feelingsInPastTwoWeeksTaskID,
  moduleID: depressionSymptomsId,
  title: feelingsInPastTwoWeeksTaskTitle,
  taskMode: TaskMode.play,
  position: 1,
);

final feelingSadFrequentlyTask = TaskEntity(
  taskID: feelingSadFrequentlyTaskID,
  moduleID: depressionSymptomsId,
  title: feelingSadFrequentlyTaskTitle,
  taskMode: TaskMode.record,
  position: 2,
);

final feelingTiredOrLackingEnergyTask = TaskEntity(
  taskID: feelingTiredOrLackingEnergyTaskID,
  moduleID: depressionSymptomsId,
  title: feelingTiredOrLackingEnergyTaskTitle,
  taskMode: TaskMode.record,
  position: 3,
);

final troubleSleepingTask = TaskEntity(
  taskID: troubleSleepingTaskID,
  moduleID: depressionSymptomsId,
  title: troubleSleepingTaskTitle,
  taskMode: TaskMode.record,
  position: 4,
);

final preferringToStayHomeTask = TaskEntity(
  taskID: preferringToStayHomeTaskID,
  moduleID: depressionSymptomsId,
  title: preferringToStayHomeTaskTitle,
  taskMode: TaskMode.record,
  position: 5,
);

final feelingUselessOrGuiltyTask = TaskEntity(
  taskID: feelingUselessOrGuiltyTaskID,
  moduleID: depressionSymptomsId,
  title: feelingUselessOrGuiltyTaskTitle,
  taskMode: TaskMode.record,
  position: 6,
);

final lostInterestInActivitiesTask = TaskEntity(
  taskID: lostInterestInActivitiesTaskID,
  moduleID: depressionSymptomsId,
  title: lostInterestInActivitiesTaskTitle,
  taskMode: TaskMode.record,
  position: 7,
);

final hopefulAboutFutureTask = TaskEntity(
  taskID: hopefulAboutFutureTaskID,
  moduleID: depressionSymptomsId,
  title: hopefulAboutFutureTaskTitle,
  taskMode: TaskMode.record,
  position: 8,
);

final feelingLifeIsWorthLivingTask = TaskEntity(
  taskID: feelingLifeIsWorthLivingTaskID,
  moduleID: depressionSymptomsId,
  title: feelingLifeIsWorthLivingTaskTitle,
  taskMode: TaskMode.record,
  position: 9,
);

final thankingForParticipationTask = TaskEntity(
  taskID: thankingForParticipationTaskID,
  moduleID: depressionSymptomsId,
  title: thankingForParticipationTaskTitle,
  taskMode: TaskMode.play,
  position: 10,
);

/// --- Test / Verification ---

final pressaInimigaTask = TaskEntity(
  taskID: pressaInimigaTaskID,
  moduleID: testsModuleId,
  title: pressaInimigaTaskTitle,
  taskMode: TaskMode.play,
  testOnly: true,
  position: 1,
);

final conteAte5Task = TaskEntity(
  taskID: conteAte5TaskID,
  moduleID: testsModuleId,
  title: conteAte5TaskTitle,
  taskMode: TaskMode.record,
  testOnly: true,
  position: 2,
);

/// Master list used by the seeder.

final List<TaskEntity> tasksList = [
  helloHowAreYouTask,
  whatsYourNameTask,
  whatsYourDOBTask,
  whatsYourEducationLevelTask,
  whatWasYourProfessionTask,
  whoDoYouLiveWithTask,
  doYouExerciseFrequentlyTask,
  doYouReadFrequentlyTask,
  doYouPlayPuzzlesOrVideoGamesFrequentlyTask,
  doYouHaveAnyDiseasesTask,
  payCloseAttentionTask,
  subtracting3AndAgainTask,
  whatYearAreWeInTask,
  whatMonthAreWeInTask,
  whatDayOfTheMonthIsItTask,
  whatDayOfTheWeekIsItTask,
  howOldAreYouTask,
  whereAreWeNowTask,
  currentPresidentOfBrazilTask,
  formerPresidentOfBrazilTask,
  repeatWordsAfterListeningFirstTimeTask,
  recallWordsFromListFirstTimeTask,
  repeatWordsAfterListeningSecondTimeTask,
  recallWordsFromListSecondTimeTask,
  repeatWordsAfterListeningThirdTimeTask,
  recallWordsFromListThirdTimeTask,
  whatDidYouDoYesterdayTask,
  favoriteChildhoodGameTask,
  retellWordsHeardBeforeTask,
  payCloseAttentionToTheStoryTask,
  anasCatStoryTask,
  howManyAnimalsCanYouThinkOfTask,
  wordsStartingWithFTask,
  wordsStartingWithATask,
  wordsStartingWithSTask,
  describeWhatYouSeeTask,
  retellStoryTask,
  yesOrNoQuestionsTask,
  canYouBatheAloneTask,
  canYouDressAloneTask,
  canYouUseToiletAloneTask,
  canYouUsePhoneAloneTask,
  canYouShopAloneTask,
  canYouHandleMoneyAloneTask,
  canYouManageMedicationAloneTask,
  canYouUseTransportAloneTask,
  feelingsInPastTwoWeeksTask,
  feelingSadFrequentlyTask,
  feelingTiredOrLackingEnergyTask,
  troubleSleepingTask,
  preferringToStayHomeTask,
  feelingUselessOrGuiltyTask,
  lostInterestInActivitiesTask,
  hopefulAboutFutureTask,
  feelingLifeIsWorthLivingTask,
  thankingForParticipationTask,
  pressaInimigaTask,
  conteAte5Task,
];


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\shared\encryption\deterministic_encryption_helper.dart ===
import 'dart:convert';
import 'dart:typed_data';
import 'package:crypto/crypto.dart';
import 'package:encrypt/encrypt.dart' as encrypt;

class DeterministicEncryptionHelper {
  static final _key = encrypt.Key.fromUtf8('my32lengthsupersecretnooneknows1');
  static final _fixedIV = encrypt.IV.fromUtf8('myfixediv1234567');

  // ---- Logger hooks (set by Flutter app or CLI seed) ----
  static void Function(String message)? _logInfo;
  static void Function(String message, [Object? error, StackTrace? stack])?
  _logError;

  static void configureLogger({
    void Function(String message)? info,
    void Function(String message, [Object? error, StackTrace? stack])? error,
  }) {
    _logInfo = info;
    _logError = error;
  }

  static void _info(String msg) {
    _logInfo?.call(msg);
  }

  static void _error(String msg, [Object? e, StackTrace? st]) {
    _logError?.call(msg, e, st);
  }

  static String encryptText(String plainText) {
    if (plainText.isEmpty) return '';
    final encrypter = encrypt.Encrypter(encrypt.AES(_key));
    final encrypted = encrypter.encrypt(plainText, iv: _fixedIV);
    final encoded = base64Encode(encrypted.bytes);
    _info('[Encrypt] üîì $plainText ‚Üí $encoded');
    return encoded;
  }

  static String decryptText(String encryptedText) {
    if (encryptedText.isEmpty) return '';
    try {
      final bytes = base64Decode(encryptedText);
      final encrypter = encrypt.Encrypter(encrypt.AES(_key));
      final decrypted = encrypter.decrypt(
        encrypt.Encrypted(Uint8List.fromList(bytes)),
        iv: _fixedIV,
      );
      _info('[Decrypt] üîê $encryptedText ‚Üí üîì $decrypted');
      return decrypted;
    } catch (e, s) {
      _error('[Decrypt] FAILED for: $encryptedText', e, s);
      return '[DECRYPTION_FAILED]';
    }
  }

  static String hashPassword(String input) {
    return sha256.convert(utf8.encode(input)).toString();
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\core\database\test_database_helper_test.dart ===
import 'package:flutter_test/flutter_test.dart';
import 'package:segundo_cogni/core/constants/database_constants.dart';
import 'package:segundo_cogni/core/database/test_database_helper.dart';
import 'package:segundo_cogni/core/database/database_schema.dart';

void main() {
  late TestDatabaseHelper dbHelper;

  setUp(() async {
    dbHelper = TestDatabaseHelper.instance;
    await dbHelper.initDb(); // ‚úÖ Ensures schema creation
  });

  tearDown(() async {
    await dbHelper.close(); // ‚úÖ Ensures clean reset between tests
  });

  test('creates all expected tables', () async {
    final db = await dbHelper.database;

    final result = await db.rawQuery(
      "SELECT name FROM sqlite_master WHERE type='table';",
    );
    final names = result.map((e) => e['name'] as String).toSet();

    for (final table in [
      Tables.evaluators,
      Tables.participants,
      Tables.evaluations,
      Tables.modules,
      Tables.tasks,
      Tables.taskPrompts,
      Tables.moduleInstances,
      Tables.taskInstances,
      Tables.recordings,
    ]) {
      expect(names.contains(table), true, reason: 'Missing table: $table');
    }
  }, timeout: Timeout(Duration(seconds: 5))); // ‚úÖ Prevents hanging

  test('dropAll removes tables', () async {
    final db = await dbHelper.database;

    await DatabaseSchema.dropAll(db);
    final result = await db.rawQuery(
      "SELECT name FROM sqlite_master WHERE type='table';",
    );
    final names = result.map((e) => e['name'] as String).toSet();

    for (final table in ['evaluators', 'participants', 'evaluations']) {
      expect(names.contains(table), false);
    }
  }, timeout: Timeout(Duration(seconds: 5))); // ‚úÖ Prevents hanging
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\core\utils\validation_helper_test.dart ===
import 'package:flutter_test/flutter_test.dart';
import 'package:segundo_cogni/core/utils/validation_helper.dart';

void main() {
  test('valid email format passes', () {
    expect(ValidationHelper.isValidEmail('a@b.com'), true);
  });

  test('invalid email format fails', () {
    expect(ValidationHelper.isValidEmail('not-email'), false);
    expect(ValidationHelper.isValidEmail('a@b'), false);
    expect(ValidationHelper.isValidEmail('@b.com'), false);
  });

  test('password at least 8 chars', () {
    expect(ValidationHelper.isValidPassword('12345678'), true);
    expect(ValidationHelper.isValidPassword('abc12345'), true);
    expect(ValidationHelper.isValidPassword('abc12'), false);
    expect(ValidationHelper.isValidPassword(''), false);
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\db_all_foreign_keys_valid_test.dart ===
import 'package:flutter_test/flutter_test.dart';

import 'package:segundo_cogni/core/database/test_database_helper.dart';
import 'package:segundo_cogni/seeders/seed_runner.dart';

void main() {
  late TestDatabaseHelper dbHelper;
  late SeedRunner seedRunner;

  setUp(() async {
    dbHelper = TestDatabaseHelper.instance;
    await dbHelper.initDb();
    seedRunner = SeedRunner();
    await seedRunner.run(db: await dbHelper.database);
  });

  tearDown(() async {
    await dbHelper.close();
  });

  test('All foreign keys reference existing rows', () async {
    final db = await dbHelper.database;

    // Get all user tables
    final tables = (await db.rawQuery('''
      SELECT name FROM sqlite_master
      WHERE type = 'table'
        AND name NOT LIKE 'sqlite_%'
    ''')).map((r) => r['name'] as String).toList();

    for (final table in tables) {
      // Introspect foreign keys for this table
      final fkRows = await db.rawQuery('PRAGMA foreign_key_list($table)');
      if (fkRows.isEmpty) continue;

      for (final fk in fkRows) {
        final parentTable = fk['table'] as String; // referenced table
        final fromCol = fk['from'] as String;      // child column
        final toCol = fk['to'] as String;          // parent column

        // Build parent set
        final parentRows = await db.query(
          parentTable,
          columns: [toCol],
        );

        final parentValues = parentRows
            .map((r) => r[toCol])
            .where((v) => v != null)
            .toSet();

        // Validate each child row
        final childRows = await db.query(
          table,
          columns: [fromCol, 'rowid'],
        );

        for (final row in childRows) {
          final value = row[fromCol];
          // Null allowed (depends on schema); we only assert when non-null
          if (value == null) continue;

          expect(
            parentValues.contains(value),
            true,
            reason:
            'FK violation: $table.$fromCol -> $parentTable.$toCol; '
                'rowid=${row['rowid']} has value=$value not found in $parentTable.$toCol',
          );
        }
      }
    }
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\db_schema_matches_constants_test.dart ===
import 'package:flutter_test/flutter_test.dart';
import 'package:segundo_cogni/features/evaluator/data/current_user_constants.dart';
import 'package:segundo_cogni/features/module/data/module_constants.dart';
import 'package:segundo_cogni/features/module_instance/data/module_instance_constants.dart';
import 'package:segundo_cogni/features/recording_file/data/recording_file_constants.dart';
import 'package:segundo_cogni/features/task/data/task_constants.dart';
import 'package:segundo_cogni/features/task_instance/data/task_instance_constants.dart';
import 'package:segundo_cogni/features/task_prompt/data/task_prompt_constants.dart';
import 'package:sqflite_common/sqlite_api.dart';

import 'package:segundo_cogni/core/constants/database_constants.dart';
import 'package:segundo_cogni/core/database/test_database_helper.dart';

import 'package:segundo_cogni/features/evaluator/data/evaluator_constants.dart';
import 'package:segundo_cogni/features/participant/data/participant_constants.dart';
import 'package:segundo_cogni/features/evaluation/data/evaluation_constants.dart';

void main() {
  late TestDatabaseHelper dbHelper;

  setUp(() async {
    dbHelper = TestDatabaseHelper.instance;
    await dbHelper.initDb(); // this creates schema
  });

  tearDown(() async {
    await dbHelper.close();
  });

  test('Tables have columns matching their *Fields.values', () async {
    final db = await dbHelper.database;

    final Map<String, List<String>> expected = {
      Tables.evaluators: EvaluatorFields.values,
      Tables.participants: ParticipantFields.values,
      Tables.evaluations: EvaluationFields.values,
      Tables.modules: ModuleFields.values,
      Tables.tasks: TaskFields.values,
      Tables.taskPrompts: TaskPromptFields.values,
      Tables.moduleInstances: ModuleInstanceFields.values,
      Tables.taskInstances: TaskInstanceFields.values,
      Tables.recordings: RecordingFileFields.values,
      Tables.currentUser: CurrentUserFields.values,
    };

    for (final entry in expected.entries) {
      final table = entry.key;
      final expectedCols = entry.value.toSet();

      final pragma = await db.rawQuery('PRAGMA table_info($table)');
      final actualCols = pragma.map((c) => c['name'] as String).toSet();

      // 1) Every expected column exists
      expect(
        actualCols.containsAll(expectedCols),
        true,
        reason:
        'Table $table is missing columns from *Fields.values. '
            'Expected at least: $expectedCols, actual: $actualCols',
      );

      // 2) No unexpected columns
      expect(
        expectedCols.containsAll(actualCols),
        true,
        reason:
        'Table $table has extra columns not in *Fields.values. '
            'Expected only: $expectedCols, actual: $actualCols',
      );
    }
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\features\auth\auth_repository_test.dart ===
import 'package:flutter_test/flutter_test.dart';
import 'package:segundo_cogni/core/database/test_database_helper.dart';
import 'package:segundo_cogni/features/auth/data/auth_local_datasource.dart';
import 'package:segundo_cogni/features/auth/data/auth_repository_impl.dart';
import 'package:segundo_cogni/features/evaluator/data/evaluator_model.dart';

void main() {
  late TestDatabaseHelper dbHelper;
  late AuthLocalDataSource authDataSource;
  late AuthRepositoryImpl authRepository;

  final dummyUser = EvaluatorModel(
    evaluatorId: null,
    name: 'Edu',
    surname: 'Fapro',
    email: 'edu@gmail.com',
    birthDate: '1990-01-01',
    cpfOrNif: '12345678900',
    username: 'edufapro',
    password: 'password123',
    specialty: 'Neuro',
  );

  Future<void> seedUser() async {
    await authDataSource.saveCurrentUser(dummyUser);
  }

  setUp(() async {
    await TestDatabaseHelper.delete();
    dbHelper = TestDatabaseHelper.instance;
    final db = await dbHelper.database;
    authDataSource = AuthLocalDataSource(db);
    authRepository = AuthRepositoryImpl(authDataSource);
  });

  tearDown(() async {
    await dbHelper.close();
  });

  test('üö™ Logout clears current user from DB', () async {
    await seedUser();
    expect(await authDataSource.getCachedUser(), isNotNull);

    await authRepository.signOut();
    expect(await authDataSource.getCachedUser(), isNull);
  });

  test('üß† Evaluator is encrypted before storage', () {
    final encrypted = dummyUser.encryptedAndHashed();

    expect(encrypted.name, isNot(dummyUser.name));
    expect(encrypted.email, isNot(dummyUser.email));
    expect(encrypted.password.length, 64); // SHA-256
  });

  test('üõ°Ô∏è Raw DB data is encrypted', () async {
    await seedUser();

    final raw = await dbHelper.database.then((db) => db.query('current_user'));
    expect(raw.first['email'], isNot(dummyUser.email));
    expect(raw.first['name'], isNot(dummyUser.name));
  });

  test('‚ùå fetchCurrentUserOrNull returns null when DB is empty', () async {
    final user = await authRepository.fetchCurrentUserOrNull();
    expect(user, isNull);
  });

  test('üöÄ Auto-login returns correct decrypted user from DB', () async {
    await seedUser();
    final user = await authRepository.fetchCurrentUserOrNull();

    expect(user, isNotNull);
    expect(user!.email, dummyUser.email);
    expect(user.name, dummyUser.name);
    expect(user.username, dummyUser.username);
  });

  test('üîê Login returns user on correct credentials', () async {
    await seedUser();
    final user = await authRepository.login(
      dummyUser.email,
      dummyUser.password,
    );
    expect(user, isNotNull);
    expect(user!.email, dummyUser.email);
  });

  test('‚ùå Login returns null on wrong password', () async {
    await seedUser();
    final user = await authRepository.login(dummyUser.email, 'wrongpassword');
    expect(user, isNull);
  });

  test('‚ùå Login returns null on non-existent user', () async {
    final user = await authRepository.login(
      'nonexistent@example.com',
      'password',
    );
    expect(user, isNull);
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\features\auth\login_notifier_test.dart ===
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:segundo_cogni/providers/auth_providers.dart';

import '../../mocks/fake_auth_repository.dart';

void main() {
  late ProviderContainer container;

  setUp(() {
    container = ProviderContainer(overrides: [
      authRepositoryProvider.overrideWith((ref) => FakeAuthRepository()),
    ]);
  });

  tearDown(() => container.dispose());

  test('login succeeds with correct credentials', () async {
    final notifier = container.read(loginProvider.notifier);
    await notifier.login('john@example.com', 'correctPassword');

    final state = container.read(loginProvider);
    expect(state, isA<AsyncData<bool>>());
    expect((state as AsyncData).value, true);
  });

  test('login fails with wrong password', () async {
    final notifier = container.read(loginProvider.notifier);
    await notifier.login('john@example.com', 'wrongPassword');

    final state = container.read(loginProvider);
    expect(state.hasError, true);
  });

  test('auto-login loads from current_user table', () async {
    final notifier = container.read(loginProvider.notifier);
    final result = await notifier.build();
    expect(result, false); // assuming no user is saved in the fake initially
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\features\evaluation\create_participant_evaluation_usecase_test.dart ===
import 'package:flutter_test/flutter_test.dart';
import 'package:segundo_cogni/core/database/test_database_helper.dart';
import 'package:segundo_cogni/features/evaluation/data/evaluation_local_datasource.dart';
import 'package:segundo_cogni/features/evaluation/domain/usecases/create_participant_evaluation_usecase.dart';
import 'package:segundo_cogni/features/participant/data/participant_local_datasource.dart';
import 'package:segundo_cogni/features/participant/domain/participant_entity.dart';
import 'package:segundo_cogni/features/task/data/task_local_datasource.dart';
import 'package:segundo_cogni/features/module/domain/module_repository.dart';
import 'package:segundo_cogni/features/module_instance/domain/module_instance_repository.dart';
import 'package:segundo_cogni/features/task_instance/domain/task_instance_repository.dart';
import 'package:segundo_cogni/features/module/domain/module_entity.dart';
import 'package:segundo_cogni/features/task/domain/task_entity.dart';
import 'package:segundo_cogni/features/module_instance/domain/module_instance_entity.dart';
import 'package:segundo_cogni/features/task_instance/domain/task_instance_entity.dart';
import 'package:segundo_cogni/core/constants/enums/person_enums.dart';
import 'package:segundo_cogni/core/constants/enums/laterality_enums.dart';

// Mocks
class MockModuleRepository implements ModuleRepository {
  @override
  Future<List<ModuleEntity>> getAllModules() async {
    return [
      ModuleEntity(moduleID: 1, title: 'Module 1', description: 'Desc 1'),
      ModuleEntity(moduleID: 2, title: 'Module 2', description: 'Desc 2'),
    ];
  }

  @override
  Future<ModuleEntity?> getModuleById(int id) async => null;
}

class MockModuleInstanceRepository implements ModuleInstanceRepository {
  @override
  Future<ModuleInstanceEntity?> createModuleInstance(
    ModuleInstanceEntity instance,
  ) async {
    return instance.copyWith(id: 100 + instance.moduleId);
  }

  @override
  Future<List<ModuleInstanceEntity>> getByEvaluationId(
    int evaluationId,
  ) async => [];

  @override
  Future<void> updateStatus(int id, dynamic status) async {}
}

class MockTaskInstanceRepository implements TaskInstanceRepository {
  @override
  Future<int> insert(TaskInstanceEntity instance) async {
    return 200 + instance.taskId;
  }

  @override
  Future<List<TaskInstanceEntity>> getByModuleInstanceId(
    int moduleInstanceId,
  ) async => [];

  @override
  Future<void> updateStatus(int id, dynamic status) async {}

  @override
  Future<void> updateResponse(int id, String response) async {}
}

void main() {
  late TestDatabaseHelper dbHelper;
  late CreateParticipantEvaluationUseCase useCase;
  late ParticipantLocalDataSource participantDataSource;
  late EvaluationLocalDataSource evaluationDataSource;
  late TaskLocalDataSource taskDataSource;

  setUp(() async {
    await TestDatabaseHelper.delete();
    dbHelper = TestDatabaseHelper.instance;
    final db = await dbHelper.database;

    participantDataSource = ParticipantLocalDataSource(db);
    evaluationDataSource = EvaluationLocalDataSource(db);
    taskDataSource = TaskLocalDataSource(db);

    // Seed a task for Module 1
    await db.insert('tasks', {
      'task_id': 1,
      'module_id': 1,
      'title': 'Task 1',
      'description': 'Task Desc',
      'command': 'Do this',
      'response_type': 'text',
      'media_type': 'none',
      'task_order': 1,
    });

    useCase = CreateParticipantEvaluationUseCase(
      participantDataSource: participantDataSource,
      evaluationDataSource: evaluationDataSource,
      moduleRepository: MockModuleRepository(),
      moduleInstanceRepository: MockModuleInstanceRepository(),
      taskDataSource: taskDataSource,
      taskInstanceRepository: MockTaskInstanceRepository(),
      db: db,
    );
  });

  tearDown(() async {
    await dbHelper.close();
  });

  test('‚úÖ execute creates participant, evaluation, and instances', () async {
    final participant = ParticipantEntity(
      name: 'Test',
      surname: 'User',
      birthDate: DateTime(2000, 1, 1),
      sex: Sex.male,
      educationLevel: EducationLevel.completeHighSchool,
      laterality: Laterality.right,
    );

    final created = await useCase.execute(
      participant: participant,
      evaluatorId: 1,
      selectedModuleIds: [1],
    );

    expect(created.participantID, isNotNull);

    // Verify Participant in DB
    final db = await dbHelper.database;
    final savedParticipant = await db.query(
      'participants',
      where: 'participant_id = ?',
      whereArgs: [created.participantID],
    );
    expect(savedParticipant, isNotEmpty);
    expect(savedParticipant.first['name'], isNot('Test')); // Should be hashed

    // Verify Evaluation in DB
    final savedEvaluation = await db.query(
      'evaluations',
      where: 'participant_id = ?',
      whereArgs: [created.participantID],
    );
    expect(savedEvaluation, isNotEmpty);
    expect(savedEvaluation.first['evaluator_id'], 1);

    // Verify Module/Task Instances (Mocked repos don't save to DB, but we verify the flow completed without error)
    // In a real integration test with full DB repos, we would query those tables too.
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\features\evaluator\evaluator_local_datasource_test.dart ===
// import 'package:flutter_test/flutter_test.dart';
// import 'package:segundo_cogni/core/database/test_database_helper.dart';
// import 'package:segundo_cogni/features/evaluator/application/evaluator_secure_service.dart';
// import 'package:segundo_cogni/features/evaluator/data/evaluator_local_datasource.dart';
// import 'package:segundo_cogni/features/evaluator/data/evaluator_model.dart';
// import 'package:segundo_cogni/features/evaluator/data/evaluator_model_extensions.dart';
// import 'package:segundo_cogni/core/utils/encryption_helper.dart';
//
// void main() {
//   late TestDatabaseHelper dbHelper;
//   late EvaluatorLocalDataSource ds;
//
//   setUp(() async {
//     await TestDatabaseHelper.delete(); // ‚úÖ clean start
//     dbHelper = TestDatabaseHelper.instance;
//     await dbHelper.database;
//     ds = EvaluatorLocalDataSource(await dbHelper.database);
//   });
//
//
//   tearDown(() async {
//     await dbHelper.close();
//   });
//
//   test('‚úÖ Create evaluator and verify encrypted storage', () async {
//     final evaluator = EvaluatorModel(
//       evaluatorId: null,
//       name: 'John',
//       surname: 'Doe',
//       email: 'john.doe@example.com',
//       birthDate: '1990-01-01',
//       cpfOrNif: '12345678900',
//       username: 'johndoe',
//       password: 'securePass123',
//       specialty: 'Neurologist',
//     ).encryptedAndHashed();
//
//     await ds.insert(evaluator);
//     final fetched = await ds.getFirstEvaluator();
//
//     expect(fetched, isNotNull);
//
//     // Decrypt to validate correctness
//     expect(EncryptionHelper.decryptText(fetched!.email), equals('john.doe@example.com'));
//     expect(fetched.password.length, 64); // SHA256 hash
//   });
//
//   test('‚úÖ Insert and fetch evaluator works with encryption', () async {
//     final evaluator = EvaluatorModel(
//       evaluatorId: null,
//       name: 'Jane',
//       surname: 'Doe',
//       email: 'jane@example.com',
//       birthDate: '1990-01-01',
//       cpfOrNif: '12312312312',
//       username: 'janedoe',
//       password: 'superSecret!',
//       specialty: 'Psychologist',
//     ).encryptedAndHashed();
//
//     await ds.insert(evaluator);
//
//     final fetched = await ds.getFirstEvaluator();
//
//     expect(fetched, isNotNull);
//     expect(EncryptionHelper.decryptText(fetched!.email), equals('jane@example.com'));
//   });
//
//
//   test('‚úÖ Create evaluator and verify encrypted storage + decrypted values', () async {
//     const email = 'john.doe@example.com';
//     const name = 'John';
//     const surname = 'Doe';
//
//     final evaluator = EvaluatorModel(
//       evaluatorId: null,
//       name: name,
//       surname: surname,
//       email: email,
//       birthDate: '1990-01-01',
//       cpfOrNif: '12345678900',
//       username: 'johndoe',
//       password: 'securePass123',
//       specialty: 'Neurologist',
//     ).encryptedAndHashed();
//
//     await ds.insert(evaluator);
//     final fetched = await ds.getFirstEvaluator();
//
//     expect(fetched, isNotNull);
//
//     // ‚úÖ Validate decrypted fields match user input
//     expect(EncryptionHelper.decryptText(fetched!.name), equals(name));
//     expect(EncryptionHelper.decryptText(fetched.surname), equals(surname));
//     expect(EncryptionHelper.decryptText(fetched.email), equals(email));
//   });
//
//
//   test('üîí Login fails with wrong password', () async {
//     const username = 'userfail';
//     const correctPassword = 'rightPassword123';
//     const wrongPassword = 'wrongPassword456';
//
//     final evaluator = EvaluatorModel(
//       evaluatorId: null,
//       name: 'Fail',
//       surname: 'Tester',
//       email: 'fail@test.com',
//       birthDate: '1995-01-01',
//       cpfOrNif: '99988877766',
//       username: username,
//       password: correctPassword,
//       specialty: 'Psychiatrist',
//     ).encryptedAndHashed();
//
//     await ds.insert(evaluator);
//
//     final loggedIn = await ds.login(username, wrongPassword);
//     expect(loggedIn, isNull); // ‚úÖ Should not log in
//   });
//
//   test('üîí Login fails with wrong username', () async {
//     const correctUsername = 'realuser';
//     const wrongUsername = 'wronguser';
//     const password = 'correctPassword';
//
//     final evaluator = EvaluatorModel(
//       evaluatorId: null,
//       name: 'Real',
//       surname: 'User',
//       email: 'real@user.com',
//       birthDate: '1993-05-10',
//       cpfOrNif: '12312312312',
//       username: correctUsername,
//       password: password,
//       specialty: 'Neurologist',
//     ).encryptedAndHashed();
//
//     await ds.insert(evaluator);
//
//     final loggedIn = await ds.login(wrongUsername, password);
//     expect(loggedIn, isNull); // ‚úÖ Should not log in
//   });
//
//   test('‚ùå Login fails with wrong password', () async {
//     final evaluator = EvaluatorSecureService.encrypt(
//       EvaluatorModel(
//         evaluatorId: null,
//         name: 'Jane',
//         surname: 'Smith',
//         email: 'jane.smith@example.com',
//         birthDate: '1985-12-05',
//         cpfOrNif: '11122233344',
//         username: 'janesmith',
//         password: 'securePass123',
//         specialty: 'Psychologist',
//       ),
//     );
//
//     await ds.insert(evaluator);
//
//     final result = await ds.login('janesmith', 'wrongpass');
//     expect(result, isNull);
//   });
//
//   test('‚ùå Login fails with wrong username', () async {
//     final evaluator = EvaluatorSecureService.encrypt(
//       EvaluatorModel(
//         evaluatorId: null,
//         name: 'Jane',
//         surname: 'Smith',
//         email: 'jane.smith@example.com',
//         birthDate: '1985-12-05',
//         cpfOrNif: '11122233344',
//         username: 'janesmith',
//         password: 'securePass123',
//         specialty: 'Psychologist',
//       ),
//     );
//
//     await ds.insert(evaluator);
//
//     final result = await ds.login('notjanesmith', 'securePass123');
//     expect(result, isNull);
//   });
//
// }


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\features\evaluator\evaluator_repository_test.dart ===
import 'package:flutter_test/flutter_test.dart';
import 'package:segundo_cogni/core/database/test_database_helper.dart';
import 'package:segundo_cogni/features/evaluator/data/evaluator_local_datasource.dart';
import 'package:segundo_cogni/features/evaluator/data/evaluator_repository_impl.dart';
import 'package:segundo_cogni/features/evaluator/domain/evaluator_registration_data.dart';

void main() {
  late TestDatabaseHelper dbHelper;
  late EvaluatorLocalDataSource localDataSource;
  late EvaluatorRepositoryImpl repository;

  setUp(() async {
    await TestDatabaseHelper.delete();
    dbHelper = TestDatabaseHelper.instance;
    final db = await dbHelper.database;
    localDataSource = EvaluatorLocalDataSource(db);
    repository = EvaluatorRepositoryImpl(
      localDataSource,
      null,
    ); // Remote DS is null for now
  });

  tearDown(() async {
    await dbHelper.close();
  });

  test('üìù insertEvaluator saves evaluator to DB', () async {
    final data = EvaluatorRegistrationData(
      name: 'John',
      surname: 'Doe',
      email: 'john.doe@example.com',
      username: 'johndoe',
      password: 'password123',
      birthDate: DateTime(1990, 1, 1),
      specialty: 'Psychology',
      cpf: '12345678900',
    );

    await repository.insertEvaluator(data);

    final evaluator = await localDataSource.getEvaluatorByEmail(data.email);
    expect(evaluator, isNotNull);
    expect(evaluator!.name, data.name);
    expect(evaluator.username, data.username);
    // Password should be hashed or at least stored
    expect(evaluator.password, isNotEmpty);
  });

  test('üëÆ hasAnyEvaluatorAdmin returns false when DB is empty', () async {
    final hasAdmin = await repository.hasAnyEvaluatorAdmin();
    expect(hasAdmin, isFalse);
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\features\participant\participant_local_datasource_test.dart ===
import 'package:flutter_test/flutter_test.dart';
import 'package:segundo_cogni/core/constants/enums/laterality_enums.dart';
import 'package:segundo_cogni/core/logger/app_logger.dart';
import 'package:segundo_cogni/features/participant/data/participant_constants.dart';
import 'package:segundo_cogni/features/participant/data/participant_local_datasource.dart';
import 'package:segundo_cogni/core/database/test_database_helper.dart';

void main() {
  late ParticipantLocalDataSource dataSource;

  setUp(() async {
    final dbHelper = TestDatabaseHelper.instance;
    await dbHelper.initDb();
    dataSource = ParticipantLocalDataSource(dbHelper: dbHelper);
  });

  test('insert and retrieve participant', () async {
    final db = await TestDatabaseHelper.instance.database;

    final id = await dataSource.insertParticipant(db, {
      ParticipantFields.name: 'Test User',
      ParticipantFields.surname: 'User',
      ParticipantFields.birthDate: '2000-01-01',       // must match schema
      ParticipantFields.sex: 1,                         // assuming numeric enum value
      ParticipantFields.educationLevel: 3,            // assuming numeric enum value
      ParticipantFields.laterality: Laterality.ambidextrous,
    });


    AppLogger.info('Test inserted participant with id=$id');
    expect(id, isNotNull);

    final participant = await dataSource.getById(id!);
    expect(participant?.name, equals('Test User'));
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\features\recording_file\recording_file_local_datasource_test.dart ===
import 'package:flutter_test/flutter_test.dart';
import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import 'package:segundo_cogni/core/database/test_database_helper.dart';
import 'package:segundo_cogni/features/recording_file/data/recording_file_local_datasource.dart';
import 'package:segundo_cogni/features/recording_file/data/recording_file_model.dart';

void main() {
  // ‚úÖ Initialize FFI before tests
  sqfliteFfiInit();
  databaseFactory = databaseFactoryFfi;

  late TestDatabaseHelper dbHelper;
  late RecordingFileLocalDataSource ds;

  setUp(() async {
    dbHelper = TestDatabaseHelper.instance;
    await dbHelper.deleteDb();
    await dbHelper.initDb();
    ds = RecordingFileLocalDataSource(dbHelper: dbHelper);
  });

  tearDown(() async {
    await dbHelper.close();
  });

  test('insert and getById', () async {
    final model = RecordingFileModel(
      id: null,
      taskInstanceId: 1,
      filePath: 'test_audio.wav',
    );

    final id = await ds.insert(model);
    expect(id, isNotNull);

    final fetched = await ds.getById(id!);
    expect(fetched, isNotNull);
    expect(fetched!.filePath, equals(model.filePath));
    expect(fetched.taskInstanceId, equals(model.taskInstanceId));
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\features\task\task_local_datasource_test.dart ===
// test/features/task/task_local_datasource_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:segundo_cogni/core/constants/enums/task_mode.dart';
import 'package:segundo_cogni/core/database/test_database_helper.dart';
import 'package:segundo_cogni/features/task/data/task_local_datasource.dart';
import 'package:segundo_cogni/features/task/data/task_model.dart';

void main() {
  late TestDatabaseHelper dbHelper;
  late TaskLocalDataSource ds;

  setUp(() async {
    dbHelper = TestDatabaseHelper.instance;
    ds = TaskLocalDataSource(dbHelper: dbHelper);
    await dbHelper.database;
  });

  tearDown(() async {
    await dbHelper.close();
  });

  test('insertTask and getTaskById', () async {
    final task = TaskModel(
      taskID: null,
      moduleID: 1,
      title: 'Task A',
      transcript: 'Desc',
      position: 1,
      taskMode: TaskMode.play,
    );

    final id = await ds.insertTask(task);
    expect(id, isNotNull);

    final fetched = await ds.getTaskById(id!);
    expect(fetched, isNotNull);
    expect(fetched!.title, 'Task A');
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\features\task_prompt\task_prompt_local_datasource_test.dart ===
import 'package:flutter_test/flutter_test.dart';
import 'package:segundo_cogni/core/database/test_database_helper.dart';
import 'package:segundo_cogni/features/task_prompt/data/task_prompt_local_datasource.dart';
import 'package:segundo_cogni/features/task_prompt/data/task_prompt_model.dart';

void main() {
  late TestDatabaseHelper dbHelper;
  late TaskPromptLocalDataSource ds;

  setUp(() async {
    dbHelper = TestDatabaseHelper.instance;
    ds = TaskPromptLocalDataSource();
    await dbHelper.database;
  });

  tearDown(() async {
    await dbHelper.close();
  });

  test('insert and getByTaskId', () async {
    final model = TaskPromptModel(
      promptID: null,
      taskID: 1,
      transcription: 'Say your name', filePath: '',
      // other fields if required
    );

    final id = await ds.insert(model);
    expect(id, isNotNull);

    final fetched = await ds.getByTaskId(1);
    expect(fetched, isNotNull);
    expect(fetched!.transcription, 'Say your name');
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\mocks\fake_auth_repository.dart ===
import 'package:segundo_cogni/features/auth/domain/auth_repository.dart';
import 'package:segundo_cogni/features/evaluator/data/evaluator_model.dart';

class FakeAuthRepository implements AuthRepository {
  EvaluatorModel? _cachedUser;

  @override
  Future<EvaluatorModel?> login(String email, String password) async {
    if (email == 'john@example.com' && password == 'correctPassword') {
      final user = EvaluatorModel(
        name: 'John',
        surname: 'Doe',
        email: email,
        birthDate: '1990-01-01',
        specialty: 'Psychology',
        cpfOrNif: '12345678900',
        username: 'johndoe',
        password: 'hashed_password',
      );
      _cachedUser = user;
      return user;
    }
    return null;
  }

  @override
  Future<void> saveCurrentUserToDB(EvaluatorModel user) async {
    _cachedUser = user;
  }

  @override
  Future<EvaluatorModel?> getCachedUser() async => _cachedUser;

  @override
  Future<void> clearCurrentUser() async {
    _cachedUser = null;
  }

  @override
  Future<void> clearCurrentUserFromDB() async {
    _cachedUser = null;
  }

  @override
  Future<void> cacheUser(EvaluatorModel user) async {
    _cachedUser = user;
  }

  @override
  Future<void> clearCachedUser() async {
    _cachedUser = null;
  }

  @override
  Future<EvaluatorModel?> fetchCurrentUserOrNull() async => _cachedUser;

  @override
  Future<void> signOut() async {
    _cachedUser = null;
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\seeders\evaluator_seed_test.dart ===
import 'package:flutter_test/flutter_test.dart';
import 'package:segundo_cogni/core/database/test_database_helper.dart';
import 'package:segundo_cogni/seeders/evaluators/evaluator_seed.dart';

void main() {
  late TestDatabaseHelper dbHelper;

  setUp(() async {
    dbHelper = TestDatabaseHelper.instance;
    await dbHelper.initDb();
  });

  tearDown(() async {
    await dbHelper.close();
  });

  test('seedDummyEvaluator inserts at least one evaluator', () async {
    final db = await dbHelper.database;

    await seedDummyEvaluator( db);

    final evaluators = await db.query('evaluators');
    expect(evaluators.isNotEmpty, true, reason: 'No evaluator was seeded');
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\seeders\modules_seeds_test.dart ===
import 'package:flutter_test/flutter_test.dart';
import 'package:segundo_cogni/core/constants/database_constants.dart';
import 'package:segundo_cogni/core/database/test_database_helper.dart';
import 'package:segundo_cogni/features/module/data/module_constants.dart';
import 'package:segundo_cogni/seeders/modules/modules_seeds.dart';

void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  late TestDatabaseHelper dbHelper;

  setUp(() async {
    dbHelper = TestDatabaseHelper.instance;
    await dbHelper.initDb(); // in-memory schema ready
  });

  tearDown(() async {
    await TestDatabaseHelper.delete(); // clean reset between tests
  });

  group('seedModules', () {
    test('inserts all expected modules', () async {
      final db = await dbHelper.database;

      await seedModules(db);

      final rows = await db.query(Tables.modules);

      expect(rows.isNotEmpty, true,
          reason: 'No modules were seeded into ${Tables.modules}');
      expect(
        rows.length,
        modulesList.length,
        reason:
        'Expected ${modulesList.length} modules, but found ${rows.length}',
      );
    });

    test('is idempotent (no duplicates on second run)', () async {
      final db = await dbHelper.database;

      await seedModules(db);
      final first = await db.query(Tables.modules);

      await seedModules(db);
      final second = await db.query(Tables.modules);

      expect(
        second.length,
        first.length,
        reason: 'Modules were duplicated after running seedModules twice',
      );
    });

    test('module IDs are unique', () async {
      final db = await dbHelper.database;

      await seedModules(db);
      final rows = await db.query(Tables.modules);

      final ids = rows
          .map((m) => m[ModuleFields.id] as int)
          .toList();
      final uniqueIds = ids.toSet();

      expect(
        uniqueIds.length,
        ids.length,
        reason: 'Duplicate module IDs found in ${Tables.modules}',
      );
    });
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\seeders\prompts_seeds_test.dart ===
import 'package:flutter_test/flutter_test.dart';
import 'package:segundo_cogni/core/database/test_database_helper.dart';
import 'package:segundo_cogni/core/constants/database_constants.dart';
import 'package:segundo_cogni/features/task/data/task_constants.dart';
import 'package:segundo_cogni/features/task_prompt/data/task_prompt_constants.dart';
import 'package:segundo_cogni/seeders/tasks/task_seeds.dart';
import 'package:segundo_cogni/seeders/prompts/prompts_seed.dart';
import 'package:segundo_cogni/seeders/modules/modules_seeds.dart';

void main() {
  late TestDatabaseHelper dbHelper;

  setUp(() async {
    dbHelper = TestDatabaseHelper.instance;
    await dbHelper.initDb();
  });

  tearDown(() async {
    await dbHelper.close();
  });

  test('seedPrompts inserts prompts and links to tasks', () async {
    final db = await dbHelper.database;

    await seedModules(db);
    await seedTasks(db);
    await seedPrompts(db);

    final prompts = await db.query(Tables.taskPrompts);
    expect(prompts.isNotEmpty, true);

    final tasks = await db.query(Tables.tasks);
    final taskIds =
    tasks.map((t) => t[TaskFields.id] as int).toSet(); // ‚úÖ correct key

    for (final p in prompts) {
      final tid = p[TaskPromptFields.taskID] as int?;
      expect(
        taskIds.contains(tid),
        true,
        reason: 'Prompt ${p[TaskPromptFields.promptID]} has invalid task_id=$tid',
      );
    }
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\seeders\seeds_relations_test.dart ===
import 'package:flutter_test/flutter_test.dart';
import 'package:segundo_cogni/core/database/test_database_helper.dart';
import 'package:segundo_cogni/core/constants/database_constants.dart';
import 'package:segundo_cogni/features/module/data/module_constants.dart';
import 'package:segundo_cogni/features/task/data/task_constants.dart';
import 'package:segundo_cogni/features/task_prompt/data/task_prompt_constants.dart';
import 'package:segundo_cogni/seeders/seed_runner.dart';

void main() {
  late TestDatabaseHelper dbHelper;
  late SeedRunner seedRunner;

  setUp(() async {
    dbHelper = TestDatabaseHelper.instance;
    await dbHelper.initDb();
    seedRunner = SeedRunner();
    await seedRunner.run(db: await dbHelper.database);
  });

  tearDown(() async {
    await dbHelper.close();
  });

  group('Seed relations', () {
    test('Every task.module_id points to an existing module', () async {
      final db = await dbHelper.database;

      final modules = await db.query(Tables.modules);
      final tasks = await db.query(Tables.tasks);

      final moduleIds =
      modules.map((m) => m[ModuleFields.id] as int).toSet();

      for (final t in tasks) {
        final mid = t[TaskFields.moduleId] as int?;
        expect(
          mid != null && moduleIds.contains(mid),
          true,
          reason:
          'Task ${t[TaskFields.id]} has invalid module_id=$mid (not found in ${Tables.modules})',
        );
      }
    });

    test('Every prompt.task_id points to an existing task', () async {
      final db = await dbHelper.database;

      final tasks = await db.query(Tables.tasks);
      final prompts = await db.query(Tables.taskPrompts);

      final taskIds =
      tasks.map((t) => t[TaskFields.id] as int).toSet();

      for (final p in prompts) {
        final tid = p[TaskPromptFields.taskID] as int?;
        expect(
          tid != null && taskIds.contains(tid),
          true,
          reason:
          'Prompt ${p[TaskPromptFields.promptID]} has invalid task_id=$tid (not found in ${Tables.tasks})',
        );
      }
    });
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\seeders\seed_runner_atomicity_test.dart ===
import 'package:flutter_test/flutter_test.dart';
import 'package:sqflite_common/sqlite_api.dart';

import 'package:segundo_cogni/core/database/test_database_helper.dart';
import 'package:segundo_cogni/seeders/seed_runner.dart';
import 'package:segundo_cogni/core/constants/database_constants.dart';

void main() {
  late TestDatabaseHelper dbHelper;

  setUp(() async {
    dbHelper = TestDatabaseHelper.instance;
    await dbHelper.initDb();
  });

  tearDown(() async {
    await dbHelper.close();
  });

  Future<Map<String, int>> _rowCounts(DatabaseExecutor db) async {
    final tables = <String>[
      Tables.evaluators,
      Tables.participants,
      Tables.modules,
      Tables.tasks,
      Tables.taskPrompts,
      Tables.evaluations,
      Tables.moduleInstances,
      Tables.taskInstances,
      Tables.recordings,
      Tables.currentUser,
    ];

    final result = <String, int>{};
    for (final t in tables) {
      final countRes = await db.rawQuery('SELECT COUNT(*) AS c FROM $t');
      result[t] = (countRes.first['c'] as int?) ?? 0;
    }
    return result;
  }

  test('SeedRunner.run is atomic when wrapped in a transaction', () async {
    final db = await dbHelper.database;

    // Snapshot BEFORE
    final before = await _rowCounts(db);

    // Try seeding inside a transaction but force a failure.
    try {
      await db.transaction((txn) async {
        // Run your real seeds here
        final runner = SeedRunner();
        await runner.run(db: txn); // requires db: DatabaseExecutor

        // Force an error AFTER some inserts
        throw Exception('Forced failure to test rollback');
      });
    } catch (_) {
      // expected
    }

    // Snapshot AFTER: should be identical if everything is atomic
    final after = await _rowCounts(db);

    expect(
      after,
      equals(before),
      reason:
      'SeedRunner.run is not atomic. '
          'Row counts changed despite transaction failure.\n'
          'Before: $before\nAfter:  $after',
    );
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\seeders\seed_runner_test.dart ===
import 'package:flutter_test/flutter_test.dart';
import 'package:segundo_cogni/core/constants/database_constants.dart';
import 'package:segundo_cogni/core/database/test_database_helper.dart';
import 'package:segundo_cogni/seeders/seed_runner.dart';

void main() {
  // Needed when using any Flutter bindings or sqflite FFI in tests
  TestWidgetsFlutterBinding.ensureInitialized();

  late TestDatabaseHelper dbHelper;
  late SeedRunner seedRunner;

  setUp(() async {
    dbHelper = TestDatabaseHelper.instance;
    await dbHelper.initDb(); // ‚úÖ ensures schema exists (in-memory)
    seedRunner = SeedRunner();
  });

  tearDown(() async {
    // ‚úÖ resets the in-memory DB between tests
    await TestDatabaseHelper.delete();
  });

  group('SeedRunner', () {
    test('seeds modules, tasks, prompts and evaluator', () async {
      final db = await dbHelper.database;

      await seedRunner.run(db: db);

      final modules = await db.query(Tables.modules);
      final tasks = await db.query(Tables.tasks);
      final prompts = await db.query(Tables.taskPrompts);
      final evaluators = await db.query(Tables.evaluators);

      expect(modules.isNotEmpty, true, reason: 'No modules were seeded');
      expect(tasks.isNotEmpty, true, reason: 'No tasks were seeded');
      expect(prompts.isNotEmpty, true, reason: 'No prompts were seeded');
      expect(evaluators.isNotEmpty, true, reason: 'No evaluator was seeded');
    });

    test('is idempotent (no duplicates on second run)', () async {
      final db = await dbHelper.database;

      await seedRunner.run(db: db);
      final firstModules = await db.query(Tables.modules);
      final firstTasks = await db.query(Tables.tasks);
      final firstPrompts = await db.query(Tables.taskPrompts);
      final firstEvaluators = await db.query(Tables.evaluators);

      await seedRunner.run(db: db);
      final secondModules = await db.query(Tables.modules);
      final secondTasks = await db.query(Tables.tasks);
      final secondPrompts = await db.query(Tables.taskPrompts);
      final secondEvaluators = await db.query(Tables.evaluators);

      expect(secondModules.length, firstModules.length,
          reason: 'Modules duplicated after second seeding');
      expect(secondTasks.length, firstTasks.length,
          reason: 'Tasks duplicated after second seeding');
      expect(secondPrompts.length, firstPrompts.length,
          reason: 'Prompts duplicated after second seeding');
      expect(secondEvaluators.length, firstEvaluators.length,
          reason: 'Evaluators duplicated after second seeding');
    });
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\seeders\tasks_seeds_test.dart ===
import 'package:flutter_test/flutter_test.dart';
import 'package:segundo_cogni/core/database/test_database_helper.dart';
import 'package:segundo_cogni/seeders/tasks/task_seeds.dart';
import 'package:segundo_cogni/seeders/modules/modules_seeds.dart';

void main() {
  late TestDatabaseHelper dbHelper;

  setUp(() async {
    dbHelper = TestDatabaseHelper.instance;
    await dbHelper.initDb();
  });

  tearDown(() async {
    await dbHelper.close();
  });

  test('seedTasks inserts tasks and links to modules', () async {
    final db = await dbHelper.database;

    await seedModules(db);
    await seedTasks(db);

    final tasks = await db.query('tasks');
    expect(tasks.isNotEmpty, true);

    final modules = await db.query('modules');
    final moduleIds =
    modules.map((m) => m['module_id'] as int).toSet(); // adjust if needed

    for (final t in tasks) {
      final mid = t['module_id'] as int?;
      expect(moduleIds.contains(mid), true,
          reason: 'Task ${t['id']} has invalid module_id=$mid');
    }
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\seeders\task_seeds_test.dart ===
import 'package:flutter_test/flutter_test.dart';
import 'package:segundo_cogni/core/database/test_database_helper.dart';
import 'package:segundo_cogni/core/constants/database_constants.dart';
import 'package:segundo_cogni/seeders/modules/modules_seeds.dart';
import 'package:segundo_cogni/seeders/tasks/task_seeds.dart';

void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  late TestDatabaseHelper dbHelper;

  setUp(() async {
    dbHelper = TestDatabaseHelper.instance;
    await dbHelper.initDb();
  });

  tearDown(() async {
    await TestDatabaseHelper.delete();
  });

  group('seedTasks', () {
    test('inserts all tasks after modules', () async {
      final db = await dbHelper.database;

      await seedModules(db);
      await seedTasks(db);

      final rows = await db.query(Tables.tasks);
      expect(rows.isNotEmpty, true);
      expect(rows.length, tasksList.length);
    });

    test('is idempotent', () async {
      final db = await dbHelper.database;

      await seedModules(db);
      await seedTasks(db);
      final first = await db.query(Tables.tasks);

      await seedTasks(db);
      final second = await db.query(Tables.tasks);

      expect(second.length, first.length);
    });
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\widget_test.dart ===
import 'package:flutter_test/flutter_test.dart';

void main() {
  testWidgets('dummy widget test', (tester) async {
    expect(1, 1);
  });
}


