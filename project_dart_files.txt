=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\config\environment.dart ===


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\constants\audio_file_paths.dart ===
class AudioFilePaths {

  static String get hello_how_are_you => 'assets/task_prompts/audio_01.wav';
  static String get whats_your_name => 'assets/task_prompts/audio_02.wav';
  static String get whats_your_dob => 'assets/task_prompts/audio_03.wav';
  static String get whats_your_education_level => 'assets/task_prompts/audio_04.wav';
  static String get what_was_your_profession => 'assets/task_prompts/audio_05.wav';

  static String get who_do_you_live_with => 'assets/task_prompts/audio_06.wav';
  static String get do_you_exercise_frequently => 'assets/task_prompts/audio_07.wav';
  static String get do_you_read_frequently => 'assets/task_prompts/audio_08.wav';
  static String get do_you_play_puzzles_or_video_games_frequently => 'assets/task_prompts/audio_09.wav';
  static String get do_you_have_any_diseases => 'assets/task_prompts/audio_10.wav';

  static String get pay_close_attention => 'assets/task_prompts/audio_11.wav';
  static String get subtracting_3_and_again => 'assets/task_prompts/audio_12.wav';
  static String get what_year_are_we_in => 'assets/task_prompts/audio_13.wav';
  static String get what_month_are_we_in => 'assets/task_prompts/audio_14.wav';
  static String get what_day_of_the_month_is_it => 'assets/task_prompts/audio_15.wav';

  static String get what_day_of_the_week_is_it => 'assets/task_prompts/audio_16.wav';
  static String get how_old_are_you => 'assets/task_prompts/audio_17.wav';
  static String get where_are_we_now => 'assets/task_prompts/audio_18.wav';
  static String get current_president_of_brazil => 'assets/task_prompts/audio_19.wav';
  static String get former_president_of_brazil => 'assets/task_prompts/audio_20.wav';

  static String get repeat_words_after_listening_first_time => 'assets/task_prompts/audio_21.wav';
  static String get recall_words_from_list_first_time => 'assets/task_prompts/audio_22.wav';
  static String get repeat_words_after_listening_second_time => 'assets/task_prompts/audio_23.wav';
  static String get recall_words_from_list_second_time => 'assets/task_prompts/audio_24.wav';
  static String get repeat_words_after_listening_third_time => 'assets/task_prompts/audio_25.wav';

  static String get recall_words_from_list_third_time => 'assets/task_prompts/audio_26.wav';
  static String get what_did_you_do_yesterday => 'assets/task_prompts/audio_27.wav';
  static String get favorite_childhood_game => 'assets/task_prompts/audio_28.wav';
  static String get retell_words_heard_before => 'assets/task_prompts/audio_29.wav';
  static String get pay_close_attention_to_the_story => 'assets/task_prompts/audio_30.wav';

  static String get anas_cat_story => 'assets/task_prompts/audio_31.wav';
  static String get how_many_animals_can_you_think_of => 'assets/task_prompts/audio_32.wav';
  static String get words_starting_with_f => 'assets/task_prompts/audio_33.wav';
  static String get words_starting_with_a => 'assets/task_prompts/audio_34.wav';
  static String get words_starting_with_s => 'assets/task_prompts/audio_35.wav';

  static String get describe_what_you_see => 'assets/task_prompts/audio_36.wav';
  static String get retell_story => 'assets/task_prompts/audio_37.wav';
  static String get yes_or_no_questions => 'assets/task_prompts/audio_38.wav';
  static String get can_you_bathe_alone => 'assets/task_prompts/audio_39.wav';
  static String get can_you_dress_alone => 'assets/task_prompts/audio_40.wav';

  static String get can_you_use_toilet_alone => 'assets/task_prompts/audio_41.wav';
  static String get can_you_use_phone_alone => 'assets/task_prompts/audio_42.wav';
  static String get can_you_shop_alone => 'assets/task_prompts/audio_43.wav';
  static String get can_you_handle_money_alone => 'assets/task_prompts/audio_44.wav';
  static String get can_you_manage_medication_alone => 'assets/task_prompts/audio_45.wav';

  static String get can_you_use_transport_alone => 'assets/task_prompts/audio_46.wav';
  static String get feelings_in_past_two_weeks => 'assets/task_prompts/audio_47.wav';
  static String get feeling_sad_frequently => 'assets/task_prompts/audio_48.wav';
  static String get feeling_tired_or_lacking_energy => 'assets/task_prompts/audio_49.wav';
  static String get trouble_sleeping => 'assets/task_prompts/audio_50.wav';

  static String get preferring_to_stay_home => 'assets/task_prompts/audio_51.wav';
  static String get feeling_useless_or_guilty => 'assets/task_prompts/audio_52.wav';
  static String get lost_interest_in_activities => 'assets/task_prompts/audio_53.wav';
  static String get hopeful_about_future => 'assets/task_prompts/audio_54.wav';
  static String get feeling_life_is_worth_living => 'assets/task_prompts/audio_55.wav';
  static String get thanking_for_participation => 'assets/task_prompts/audio_56.wav';

  static String get audioPlaceholder => 'assets/audio/audio_placeholder.mp3';

  static String get aPressaEhInimiga => 'assets/test_prompts/a_pressa_eh_inimiga_da_perfeicao.mp3';
  static String get ehMelhorUmPassaro => 'assets/test_prompts/eh_melhor_um_passaro_na_mao.mp3';
  static String get nemTudoQueReluz => 'assets/test_prompts/nem_tudo_que_reluz_eh_ouro.mp3';

  static String get conteAte5 => 'assets/test_prompts/conte_ateh_5.mp3';
  static String get digaDoisAnimais => 'assets/test_prompts/diga_dois_animais_4_patas.mp3';
  static String get repitaAFrase => 'assets/test_prompts/repita_a_frase.mp3';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\constants\database_constants.dart ===
class DatabaseConfig {
  static const name = "cognivoice_db.db";
  static const version = 1;
}

class Tables {
  static const evaluators = "evaluators";
  static const participants = "participants";
  static const evaluations = "evaluations";
  static const modules = "modules";
  static const tasks = "tasks";
  static const evaluationModules = "evaluation_modules";
  static const taskInstances = "task_instances";
  static const moduleInstances = "module_instances";
  static const taskPrompts = "task_prompts";
  static const recordings = "recordings";
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\constants\enums\person_enums.dart ===
enum EducationLevel {
  incompleteElementary(1, "Incomplete Elementary"),
  completeElementary(2, "Complete Elementary"),
  incompleteHighSchool(3, "Incomplete High School"),
  completeHighSchool(4, "Complete High School"),
  incompleteCollege(5, "Incomplete College"),
  completeCollege(6, "Complete College"),
  postgraduate(7, "Postgraduate");

  final int numericValue;
  final String description;

  const EducationLevel(this.numericValue, this.description);

  static EducationLevel fromValue(int value) {
    return EducationLevel.values.firstWhere(
          (level) => level.numericValue == value,
      orElse: () => EducationLevel.completeElementary,
    );
  }
}

enum Sex {
  male(1, "Male"),
  female(2, "Female"),
  other(3, "Other");

  final int numericValue;
  final String description;

  const Sex(this.numericValue, this.description);

  static Sex fromValue(int value) {
    return Sex.values.firstWhere(
          (s) => s.numericValue == value,
      orElse: () => Sex.other,
    );
  }

  static Sex fromString(String str) {
    switch (str.toLowerCase()) {
      case 'male':
        return Sex.male;
      case 'female':
        return Sex.female;
      case 'other':
      default:
        return Sex.other;
    }
  }
}



=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\constants\enums\progress_status.dart ===
enum ProgressStatus {
  pending(1, "Pending"),
  inProgress(2, "In Progress"),
  completed(3, "Completed");

  final int numericValue;
  final String description;

  const ProgressStatus(this.numericValue, this.description);

  static ProgressStatus fromValue(int value) {
    return ProgressStatus.values.firstWhere(
          (s) => s.numericValue == value,
      orElse: () => ProgressStatus.pending,
    );
  }
}

/// Type aliases for semantic clarity
typedef EvaluationStatus = ProgressStatus;
typedef ModuleStatus = ProgressStatus;
typedef TaskStatus = ProgressStatus;

=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\constants\enums\task_mode.dart ===
enum TaskMode {
  play(0, "Play"),
  record(1, "Record");

  final int numericValue;
  final String description;

  const TaskMode(this.numericValue, this.description);

  static TaskMode fromValue(int value) {
    return TaskMode.values.firstWhere(
          (mode) => mode.numericValue == value,
      orElse: () => TaskMode.play,
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\database\base_database_helper.dart ===
import 'package:path/path.dart' as p;
import 'package:sqflite_common/sqlite_api.dart';
import 'package:segundo_cogni/core/logger/app_logger.dart';
import 'package:sqflite_common_ffi/sqflite_ffi.dart';

abstract class BaseDatabaseHelper {
  BaseDatabaseHelper(this.dbName);

  final String dbName;
  Database? _db;

  int get dbVersion => 1;

  Future<void> onCreate(Database db, int version);
  Future<void> onUpgrade(Database db, int oldVersion, int newVersion) async {}

  Future<Database> get database async {
    if (_db != null && _db!.isOpen) {
      AppLogger.db('Database already initialized.');
      return _db!;
    }
    _db = await _initDB();
    return _db!;
  }

  Future<Database> _initDB() async {
    AppLogger.db('Initializing database: $dbName');
    final dbPath = await databaseFactory.getDatabasesPath();
    final path = p.join(dbPath, dbName);

    final db = await databaseFactory.openDatabase(
      path,
      options: OpenDatabaseOptions(
        version: dbVersion,
        onCreate: (db, version) async {
          AppLogger.db('Creating database schema.');
          await onCreate(db, version);
        },
        onUpgrade: (db, oldV, newV) async {
          AppLogger.db('Upgrading database from $oldV to $newV.');
          await onUpgrade(db, oldV, newV);
        },
      ),
    );

    AppLogger.db('Database opened successfully.');
    return db;
  }

  Future<void> close() async {
    if (_db != null) {
      await _db!.close();
      _db = null;
      AppLogger.db('Database closed.');
    }
  }

  Future<void> deleteDb() async {
    final dbPath = await databaseFactory.getDatabasesPath();
    final path = p.join(dbPath, dbName);
    await databaseFactory.deleteDatabase(path);
    _db = null;
    AppLogger.db('Database deleted: $dbName');
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\database\database_schema.dart ===
import 'package:sqflite_common/sqlite_api.dart';
import '../constants/database_constants.dart';
import 'package:segundo_cogni/core/logger/app_logger.dart';

// Import table scripts
import '../../features/evaluator/data/evaluator_constants.dart';
import '../../features/module/data/module_constants.dart';
import '../../features/module_instance/data/module_instance_constants.dart';
import '../../features/participant/data/participant_constants.dart';
import '../../features/evaluation/data/evaluation_constants.dart';
import '../../features/recording_file/data/recording_file_constants.dart';
import '../../features/task/data/task_constants.dart';
import '../../features/task_instance/data/task_instance_constants.dart';
import '../../features/task_prompt/data/task_prompt_constants.dart';

class DatabaseSchema {
  static final List<String> _createScripts = [
    scriptCreateTableEvaluators,
    scriptCreateTableParticipants,
    scriptCreateTableModules,
    scriptCreateTableTasks,
    scriptCreateTableTaskPrompts,
    scriptCreateTableEvaluations,
    scriptCreateTableModuleInstances,
    scriptCreateTableTaskInstances,
    scriptCreateTableRecordings,
  ];

  static final List<String> _tableNames = [
    Tables.evaluators,
    Tables.participants,
    Tables.modules,
    Tables.tasks,
    Tables.taskPrompts,
    Tables.evaluations,
    Tables.moduleInstances,
    Tables.taskInstances,
    Tables.recordings,
  ];

  /// Creates all tables and verifies that they were created successfully.
  static Future<void> createAll(Database db) async {
    for (int i = 0; i < _createScripts.length; i++) {
      final tableName = _tableNames[i];
      final script = _createScripts[i];
      try {
        await db.execute(script);
        AppLogger.db('‚úÖ Created table: $tableName');
      } catch (e) {
        AppLogger.db('‚ö†Ô∏è Skipping table "$tableName" ‚Äî possibly already exists: $e');
      }
    }
    await _verifySchema(db);
  }

  /// Drops all tables (for upgrades or tests).
  static Future<void> dropAll(Database db) async {
    for (final name in _tableNames.reversed) {
      try {
        await db.execute('DROP TABLE IF EXISTS $name');
        AppLogger.db('üóëÔ∏è Dropped table: $name');
      } catch (e) {
        AppLogger.db('‚ö†Ô∏è Failed to drop $name: $e');
      }
    }
  }

  /// Confirms that all expected tables exist in the DB.
  static Future<void> _verifySchema(Database db) async {
    final result = await db.rawQuery(
      "SELECT name FROM sqlite_master WHERE type='table';",
    );
    final existing = result.map((e) => e['name']).toSet();

    for (final expected in _tableNames) {
      if (existing.contains(expected)) {
        AppLogger.db('‚úÖ Verified: $expected');
      } else {
        AppLogger.error('‚ùå Missing table: $expected');
      }
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\database\prod_database_helper.dart ===
import 'package:segundo_cogni/core/database/database_schema.dart';
import 'package:sqflite_common/sqlite_api.dart';
import 'package:segundo_cogni/core/database/base_database_helper.dart';
import 'package:segundo_cogni/core/logger/app_logger.dart';

class ProdDatabaseHelper extends BaseDatabaseHelper {
  ProdDatabaseHelper._() : super('cognivoice_db.db');
  static final ProdDatabaseHelper instance = ProdDatabaseHelper._();

  @override
  Future<void> onCreate(Database db, int version) async {
    AppLogger.db('Creating production schema...');
    await DatabaseSchema.createAll(db);
  }

  @override
  Future<void> onUpgrade(Database db, int oldVersion, int newVersion) async {
    AppLogger.db('Upgrading DB $oldVersion ‚Üí $newVersion');
    await DatabaseSchema.dropAll(db);
    await DatabaseSchema.createAll(db);
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\database\test_database_helper.dart ===
import 'package:segundo_cogni/core/database/database_schema.dart';
import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import 'package:segundo_cogni/core/database/base_database_helper.dart';

import '../logger/app_logger.dart';

class TestDatabaseHelper extends BaseDatabaseHelper {
  TestDatabaseHelper._() : super('test_cognivoice_db.db');
  static final TestDatabaseHelper instance = TestDatabaseHelper._();

  @override
  Future<Database> _initDB() async {
    sqfliteFfiInit();
    databaseFactory = databaseFactoryFfi;

    AppLogger.db('Creating in-memory test database...');
    return await databaseFactory.openDatabase(
      inMemoryDatabasePath,
      options: OpenDatabaseOptions(
        version: dbVersion,
        onCreate: (db, version) async => await onCreate(db, version),
      ),
    );
  }

  @override
  Future<void> onCreate(Database db, int version) async {
    await DatabaseSchema.createAll(db);
  }

  @override
  Future<void> onUpgrade(Database db, int oldVersion, int newVersion) async {
    await DatabaseSchema.createAll(db);
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\database_helper.dart ===
import 'package:path/path.dart';
import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import '../features/evaluation/data/evaluation_constants.dart';
import '../features/evaluator/data/current_user_constants.dart';
import '../features/evaluator/data/evaluator_constants.dart';
import '../features/module/data/module_constants.dart';
import '../features/participant/data/participant_constants.dart';
import '../features/task/data/task_constants.dart';
import '../features/task_prompt/data/task_prompt_constants.dart';
import 'constants/database_constants.dart';
import 'logger/app_logger.dart';

class DatabaseHelper {
  static final DatabaseHelper instance = DatabaseHelper._init();
  static Database? _database;

  DatabaseHelper._init();

  Future<Database> get database async {
    if (_database != null) {
      AppLogger.db('Database already initialized.');
      return _database!;
    }
    _database = await _initDB(DatabaseConfig.name);
    return _database!;
  }

  Future<Database> _initDB(String filePath) async {
    AppLogger.db('Initializing database: $filePath');
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, filePath);

    AppLogger.db('Database path resolved: $path');
    final db = await openDatabase(
      path,
      version: 1,
      onCreate: _createDB,
      onOpen: (db) => AppLogger.db('Database opened successfully.'),
    );
    AppLogger.db('Database openDatabase() completed.');
    return db;
  }

  Future _createDB(Database db, int version) async {
    AppLogger.db('Creating database schema, version=$version');
    try {
      await db.execute(scriptCreateTableEvaluators);
      await db.execute(scriptCreateTableParticipants);
      await db.execute(scriptCreateTableEvaluations);
      await db.execute(scriptCreateTableModules);
      await db.execute(scriptCreateTableTasks);
      await db.execute(scriptCreateTableTaskPrompts);
      await db.execute(scriptCreateTableCurrentUser);
      AppLogger.db('‚úÖ Database schema created successfully.');
    } catch (e, s) {
      AppLogger.error('‚ùå Error creating DB schema', e, s);
    }
  }


  Future<int> insert(String table, Map<String, dynamic> values) async {
    final db = await instance.database;
    AppLogger.db('Inserting into $table: $values');
    try {
      final id = await db.insert(table, values);
      AppLogger.db('Insert success [$table]: id=$id');
      return id;
    } catch (e, s) {
      AppLogger.error('Insert failed [$table]', e, s);
      rethrow;
    }
  }

  Future<List<Map<String, dynamic>>> query(String table,
      {String? where, List<Object?>? whereArgs}) async {
    final db = await instance.database;
    AppLogger.db('Querying table=$table where=$where args=$whereArgs');
    try {
      final result = await db.query(table, where: where, whereArgs: whereArgs);
      AppLogger.db('Query success [$table]: ${result.length} rows');
      return result;
    } catch (e, s) {
      AppLogger.error('Query failed [$table]', e, s);
      rethrow;
    }
  }

  Future<int> update(String table, Map<String, dynamic> values,
      {String? where, List<Object?>? whereArgs}) async {
    final db = await instance.database;
    AppLogger.db('Updating $table set=$values where=$where');
    try {
      final count =
      await db.update(table, values, where: where, whereArgs: whereArgs);
      AppLogger.db('Update success [$table]: $count rows affected');
      return count;
    } catch (e, s) {
      AppLogger.error('Update failed [$table]', e, s);
      rethrow;
    }
  }

  Future<int> delete(String table,
      {String? where, List<Object?>? whereArgs}) async {
    final db = await instance.database;
    AppLogger.db('Deleting from $table where=$where');
    try {
      final count =
      await db.delete(table, where: where, whereArgs: whereArgs);
      AppLogger.db('Delete success [$table]: $count rows removed');
      return count;
    } catch (e, s) {
      AppLogger.error('Delete failed [$table]', e, s);
      rethrow;
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\logger\app_logger.dart ===
import 'package:flutter/foundation.dart';
import 'package:logger/logger.dart';

class AppLogger {
  static final bool _isRelease = kReleaseMode;

  static final Logger _logger = Logger(
    printer: PrettyPrinter(
      methodCount: 2,
      errorMethodCount: 5,
      lineLength: 100,
      colors: true,
      printEmojis: true,
      printTime: true,
    ),
  );

  static void info(String message) {
    if (_isRelease) return;
    _logger.i(message);
  }

  static void debug(String message) {
    if (_isRelease) return;
    _logger.d(message);
  }

  static void warning(String message) {
    if (_isRelease) return;
    _logger.w(message);
  }

  static void error(String message, [dynamic error, StackTrace? stack]) {
    if (_isRelease) return;
    _logger.e(
      message,
      error: error,
      stackTrace: stack,
    );
  }

  static void db(String message) {
    if (_isRelease) return;
    _logger.d('[DB] $message');
  }

  static void nav(String message) {
    if (_isRelease) return;
    _logger.i('[NAV] $message');
  }

  static void trace(String message) {
    if (_isRelease) return;
    _logger.t(message);
  }

  static void seed(String message) {
    if (_isRelease) return;
    _logger.i('[SEED] $message');
  }

}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\network.dart ===
import 'dart:convert';

import 'package:http/http.dart' as http;

import 'logger/app_logger.dart';

class NetworkService {
  final String baseUrl = 'https://api.example.com';

  Future<http.Response> get(String endpoint) async {
    final url = Uri.parse('$baseUrl$endpoint');
    AppLogger.info('HTTP GET ‚Üí $url');

    try {
      final response = await http.get(url);
      AppLogger.info('HTTP ${response.statusCode} ‚Üê $url');
      if (response.statusCode >= 400) {
        AppLogger.warning('HTTP error ${response.statusCode}: ${response.body}');
      }
      return response;
    } catch (e, s) {
      AppLogger.error('HTTP GET failed for $url', e, s);
      rethrow;
    }
  }

  Future<http.Response> post(String endpoint, Map<String, dynamic> body) async {
    final url = Uri.parse('$baseUrl$endpoint');
    AppLogger.info('HTTP POST ‚Üí $url body=$body');

    try {
      final response = await http.post(url,
          headers: {'Content-Type': 'application/json'},
          body: jsonEncode(body));
      AppLogger.info('HTTP ${response.statusCode} ‚Üê $url');
      if (response.statusCode >= 400) {
        AppLogger.warning('HTTP error ${response.statusCode}: ${response.body}');
      }
      return response;
    } catch (e, s) {
      AppLogger.error('HTTP POST failed for $url', e, s);
      rethrow;
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\router.dart ===
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';

import '../features/auth/presentation/login_screen.dart';
import '../features/evaluator/presentation/evaluator_registration_screen.dart';
import '../features/home/home_screen.dart';
import '../features/splash/splash_screen.dart';
import 'logger/app_logger.dart';

final router = GoRouter(
  initialLocation: '/',
  observers: [
    LoggingNavigatorObserver(),
  ],
  routes: [
    GoRoute(
      path: '/',
      name: 'splash',
      builder: (BuildContext context, GoRouterState state) =>
      const SplashScreen(),
    ),
    GoRoute(
      path: '/login',
      name: 'login',
      builder: (BuildContext context, GoRouterState state) =>
      const LoginScreen(),
    ),
    GoRoute(
      path: '/home',
      name: 'home',
      builder: (BuildContext context, GoRouterState state) =>
      const HomeScreen(),
    ),
    GoRoute(
      path: '/register',
      name: 'evaluator_registration',
      builder: (context, state) => const EvaluatorRegistrationScreen(),
    ),
  ],
);

class LoggingNavigatorObserver extends NavigatorObserver {
  @override
  void didPush(Route route, Route? previousRoute) {
    AppLogger.nav('PUSHED: ${route.settings.name}');
  }

  @override
  void didPop(Route route, Route? previousRoute) {
    AppLogger.nav('POPPED: ${route.settings.name}');
  }

  @override
  void didReplace({Route? newRoute, Route? oldRoute}) {
    AppLogger.nav(
        'REPLACED: ${oldRoute?.settings.name} ‚Üí ${newRoute?.settings.name}');
  }

  @override
  void didRemove(Route route, Route? previousRoute) {
    AppLogger.nav('REMOVED: ${route.settings.name}');
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\theme\app_colors.dart ===
import 'package:flutter/material.dart';

class AppColors {
  // Y2K Palette (already defined)
  static const Color lightCyan = Color(0xFFB3DDE5);
  static const Color aquaBlue = Color(0xFF02D3D2);
  static const Color chromeBlue = Color(0xFF4073A0);
  static const Color skyBlue = Color(0xFF7AC9F2);
  static const Color mistTeal = Color(0xFF5F9C9D);

  static const List<Color> y2kPalette = [
    lightCyan,
    aquaBlue,
    chromeBlue,
    skyBlue,
    mistTeal,
  ];

  // Neutrals
  static const Color pureWhite = Color(0xFFFFFFFF);
  static const Color softWhite = Color(0xFFF5F5F5);
  static const Color coolGray100 = Color(0xFFE5E7EB);
  static const Color coolGray500 = Color(0xFF6B7280);
  static const Color coolGray900 = Color(0xFF111827);
  static const Color trueBlack = Color(0xFF000000);

  // FluentUI Base
  static const Color primary = Color(0xFF0063B1); // azul Microsoft
  static const Color secondary = Color(0xFF107C10); // verde
  static const Color accent = Color(0xFFB4009E); // roxo
  static const Color neutralLight = Color(0xFFF3F2F1);
  static const Color neutralDark = Color(0xFF201F1E);

  // === New Dark Blue Shades ===
  static const Color midnightBlue = Color(0xFF0D1B2A);   // Very dark navy
  static const Color deepSeaBlue = Color(0xFF1B263B);    // Muted deep blue
  static const Color steelBlue = Color(0xFF2C3E50);      // Grayish blue
  static const Color indigoBlue = Color(0xFF283593);     // Rich indigo
  static const Color navyBlue = Color(0xFF001F54);       // Classic navy
  static const Color darkCyanBlue = Color(0xFF0A3D62);   // Cyan-tinted navy

  static const List<Color> darkBluePalette = [
    midnightBlue,
    deepSeaBlue,
    steelBlue,
    indigoBlue,
    navyBlue,
    darkCyanBlue,
  ];
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\theme\app_theme.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import 'app_colors.dart';

class AppTheme {
  static final AccentColor accent = AccentColor.swatch({
    'darkest': AppColors.chromeBlue,
    'darker': AppColors.primary,
    'dark': AppColors.skyBlue,
    'normal': AppColors.skyBlue,
    'light': AppColors.aquaBlue,
    'lighter': AppColors.lightCyan,
    'lightest': AppColors.softWhite,
    'secondary': AppColors.mistTeal,
    'tertiary': AppColors.accent,
    'transparent': const Color(0x00000000),
  });

  /// Light mode Fluent theme
  static final FluentThemeData light = FluentThemeData(
    brightness: Brightness.light,
    accentColor: accent,
    scaffoldBackgroundColor: AppColors.softWhite,
    cardColor: AppColors.pureWhite,
    menuColor: AppColors.lightCyan,
  );

  /// Dark mode Fluent theme
  static final FluentThemeData dark = FluentThemeData(
    brightness: Brightness.dark,
    accentColor: accent,
    scaffoldBackgroundColor: AppColors.coolGray900,
    cardColor: AppColors.coolGray500,
    menuColor: AppColors.neutralDark,
  );
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\auth\application\login_notifier.dart ===
import 'package:hooks_riverpod/hooks_riverpod.dart';
import '../../../core/database_helper.dart';
import '../../../core/logger/app_logger.dart';
import '../../../providers/providers.dart';
import '../data/auth_local_datasource.dart';
import '../data/auth_repository_impl.dart';
import '../domain/auth_repository.dart';

final loginProvider =
AsyncNotifierProvider<LoginNotifier, bool>(LoginNotifier.new);

class LoginNotifier extends AsyncNotifier<bool> {
  AuthRepository? _repository;

  @override
  Future<bool> build() async => false;

  Future<void> login(String email, String password) async {
    state = const AsyncLoading();
    AppLogger.info('Login attempt started for $email');

    if (email.isEmpty || password.isEmpty) {
      state = AsyncError('E-mail e senha s√£o obrigat√≥rios', StackTrace.current);
      return;
    }

    try {
      _repository ??= await _initAuthRepository();
      final user = await _repository!.login(email, password);

      if (user == null) {
        state = AsyncError('Credenciais inv√°lidas', StackTrace.current);
      } else {
        ref.read(currentUserProvider.notifier).setUser(user);
        state = const AsyncData(true);
      }
    } catch (e, st) {
      state = AsyncError(e, st);
    } finally {
      AppLogger.info('Login attempt finished for $email');
    }
  }

  Future<AuthRepository> _initAuthRepository() async {
    final db = await DatabaseHelper.instance.database;
    return AuthRepositoryImpl(AuthLocalDataSource(db));
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\auth\data\auth_local_datasource.dart ===
import 'package:sqflite_common/sqlite_api.dart';
import '../../../core/constants/database_constants.dart';
import '../../../core/logger/app_logger.dart';
import '../../evaluator/data/evaluator_model.dart';
import '../../evaluator/data/evaluator_constants.dart';

class AuthLocalDataSource {
  final Database _db;
  AuthLocalDataSource(this._db);

  Future<EvaluatorModel?> getEvaluatorByEmail(String email) async {
    AppLogger.db('Query evaluator by email: $email');
    final result = await _db.query(
      Tables.evaluators,
      where: '${EvaluatorFields.email} = ?',
      whereArgs: [email],
      limit: 1,
    );
    if (result.isEmpty) {
      AppLogger.db('No evaluator found for $email');
      return null;
    }
    AppLogger.db('Evaluator found for $email');
    return EvaluatorModel.fromMap(result.first);
  }

  Future<void> saveCurrentUser(EvaluatorModel user) async {
    AppLogger.db('Saving current user to DB');
    await _db.delete('current_user');
    await _db.insert('current_user', user.toMap());
  }

  Future<void> clearCurrentUser() async {
    AppLogger.db('Clearing current user from DB');
    await _db.delete('current_user');
  }

  Future<EvaluatorModel?> getCachedUser() async {
    AppLogger.db('Fetching cached user from DB');
    final result = await _db.query('current_user', limit: 1);
    if (result.isEmpty) return null;
    return EvaluatorModel.fromMap(result.first);
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\auth\data\auth_model.dart ===
class AuthModel {
  final int id;
  final String email;
  final String password;

  AuthModel({required this.id, required this.email, required this.password});

  factory AuthModel.fromMap(Map<String, dynamic> map) {
    return AuthModel(
      id: map['id'] as int,
      email: map['email'] as String,
      password: map['password'] as String,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'email': email,
      'password': password,
    };
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\auth\data\auth_repository_impl.dart ===
import 'dart:convert';
import 'dart:io';
import 'package:path_provider/path_provider.dart';

import '../../../core/logger/app_logger.dart';
import '../../auth/domain/auth_repository.dart';
import '../../evaluator/data/evaluator_model.dart';
import 'auth_local_datasource.dart';

class AuthRepositoryImpl implements AuthRepository {
  final AuthLocalDataSource _local;
  EvaluatorModel? _cachedUser;

  AuthRepositoryImpl(this._local);

  @override
  Future<EvaluatorModel?> login(String email, String password) async {
    AppLogger.info('Repository: login called for $email');
    final admin = await _local.getEvaluatorByEmail(email);

    if (admin != null && admin.password == password) {
      AppLogger.info('Password verified for $email');
      await cacheUser(admin);
      return admin;
    }

    AppLogger.warning('Login failed: wrong credentials for $email');
    return null;
  }

  Future<void> saveCurrentUser(EvaluatorModel user) async {
    final file = await _getUserFile();
    final content = jsonEncode(user.toMap());
    await file.writeAsString(content);
    AppLogger.db('Saved current user to file: ${file.path}');
  }

  Future<void> clearCachedUser() async {
    final file = await _getUserFile();
    if (await file.exists()) {
      await file.delete();
      AppLogger.db('Cleared cached user file');
    }
  }

  Future<EvaluatorModel?> getCachedUser() async {
    try {
      final file = await _getUserFile();
      if (!await file.exists()) return null;

      final content = await file.readAsString();
      final map = jsonDecode(content);
      AppLogger.db('Loaded cached user from file');
      return EvaluatorModel.fromMap(map);
    } catch (e, s) {
      AppLogger.error('Failed to read cached user file', e, s);
      return null;
    }
  }

  @override
  Future<void> cacheUser(EvaluatorModel user) async {
    _cachedUser = user;
    await saveCurrentUser(user);
    AppLogger.info('User cached in memory and disk');
  }

  @override
  Future<EvaluatorModel?> fetchCurrentUserOrNull() async {
    if (_cachedUser != null) {
      AppLogger.debug('Using in-memory cached user');
      return _cachedUser;
    }
    final user = await _local.getCachedUser();
    _cachedUser = user;
    AppLogger.debug('Fetched cached user from DB: ${user?.email}');
    return user;
  }

  @override
  Future<void> signOut() async {
    AppLogger.info('Signing out current user');
    await clearCachedUser();
  }

  Future<File> _getUserFile() async {
    final dir = await getApplicationSupportDirectory();
    return File('${dir.path}/current_user.json');
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\auth\domain\auth_repository.dart ===
import '../../evaluator/data/evaluator_model.dart';

abstract class AuthRepository {
  Future<EvaluatorModel?> login(String email, String password);
  Future<void> signOut();
  Future<void> cacheUser(EvaluatorModel user);
  Future<void> clearCachedUser();
  Future<EvaluatorModel?> getCachedUser();
  Future<EvaluatorModel?> fetchCurrentUserOrNull();
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\auth\presentation\login_form.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../core/logger/app_logger.dart';
import '../../../core/theme/app_colors.dart';
import '../application/login_notifier.dart';

class LoginForm extends HookConsumerWidget {
  const LoginForm({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final emailController = useTextEditingController();
    final passwordController = useTextEditingController();
    final showPassword = useState(false);

    final loginState = ref.watch(loginProvider);
    final showInfoBar = useState(false);
    final infoBarMsg = useState('');
    final isSuccess = useState(false);

    ref.listen<AsyncValue<bool>>(loginProvider, (previous, next) {
      next.when(
        data: (success) {
          if (success) {
            AppLogger.nav('Login successful ‚Üí navigating to /home');
            isSuccess.value = true;
            infoBarMsg.value = 'Login successful!';
            showInfoBar.value = true;
            Future.delayed(const Duration(seconds: 1), () {
              if (context.mounted) context.go('/home');
            });
          }
        },
        error: (err, _) {
          AppLogger.warning('Login error: $err');
          isSuccess.value = false;
          infoBarMsg.value = err.toString();
          showInfoBar.value = true;
        },
        loading: () {
          AppLogger.debug('Login loading...');
        },
      );
    });

    void onLoginPressed() {
      final email = emailController.text.trim();
      final password = passwordController.text;
      AppLogger.info('Login pressed: $email');
      ref.read(loginProvider.notifier).login(email, password);
    }

    return Center(
      child: Container(
        padding: const EdgeInsets.all(24),
        constraints: const BoxConstraints(maxWidth: 400),
        decoration: BoxDecoration(
          color: AppColors.coolGray900,
          borderRadius: BorderRadius.circular(16),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Text(
              "Login",
              style: TextStyle(
                fontSize: 28,
                fontWeight: FontWeight.bold,
                color: AppColors.softWhite,
              ),
            ),
            const SizedBox(height: 24),

            // Email
            InfoLabel(
              label: "Email",
              child: TextBox(
                placeholder: "email@exemplo.com",
                controller: emailController,
              ),
            ),
            const SizedBox(height: 16),

            // Password + visibility toggle
            InfoLabel(
              label: "Password",
              child: Stack(
                alignment: Alignment.centerRight,
                children: [
                  TextBox(
                    controller: passwordController,
                    obscureText: !showPassword.value,
                    placeholder: "Sua senha",
                  ),
                  IconButton(
                    icon: Icon(
                      showPassword.value ? FluentIcons.hide3 : FluentIcons.view,
                    ),
                    onPressed: () => showPassword.value = !showPassword.value,
                  ),
                ],
              ),
            ),
            const SizedBox(height: 16),

            Align(
              alignment: Alignment.centerLeft,
              child: Text(
                "Forgot password?",
                style: TextStyle(
                  color: AppColors.skyBlue,
                  decoration: TextDecoration.underline,
                ),
              ),
            ),
            const SizedBox(height: 16),

            // Login button with loading
            FilledButton(
              child: loginState.isLoading
                  ? const ProgressRing()
                  : const Text("Sign in"),
              onPressed: loginState.isLoading ? null : onLoginPressed,
            ),
            const SizedBox(height: 16),

            // Info bar
            if (showInfoBar.value)
              InfoBar(
                title: Text(isSuccess.value ? "Success" : "Error"),
                content: Text(infoBarMsg.value),
                severity: isSuccess.value
                    ? InfoBarSeverity.success
                    : InfoBarSeverity.error,
                isLong: true,
                onClose: () => showInfoBar.value = false,
              ),
          ],
        ),
      ),
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\auth\presentation\login_screen.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:go_router/go_router.dart';
import '../../../core/logger/app_logger.dart';
import '../../../core/theme/app_colors.dart';
import '../application/login_notifier.dart';
import 'login_form.dart';

class LoginScreen extends HookConsumerWidget {
  const LoginScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    AppLogger.nav('LoginScreen initialized');

    final showInfoBar = useState(false);
    final infoBarMsg = useState('');
    final isSuccess = useState(false);

    ref.listen<AsyncValue<bool>>(loginProvider, (previous, next) {
      next.when(
        data: (success) {
          if (success) {
            AppLogger.nav('Login successful ‚Üí navigating to /home');
            Future.delayed(const Duration(seconds: 1), () {
              if (context.mounted) context.go('/home');
            });
          }
        },
        error: (err, _) {
          AppLogger.warning('Login error displayed: $err');
          isSuccess.value = false;
          infoBarMsg.value = err.toString();
          showInfoBar.value = true;
        },
        loading: () => AppLogger.debug('Login process loading...'),
      );
    });

    return NavigationView(
      content: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [AppColors.aquaBlue, AppColors.skyBlue, AppColors.chromeBlue],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: const Center(child: LoginForm()),
      ),
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluation\data\evaluation_constants.dart ===
import '../../../core/constants/database_constants.dart';
import '../../evaluator/data/evaluator_constants.dart';
import '../../participant/data/participant_constants.dart';

class EvaluationFields {
    static const id = "evaluation_id";
    static const date = "evaluation_date";
    static const evaluatorId = "evaluator_id"; // FK
    static const participantId = "participant_id"; // FK
    static const status = "status";
    static const language = "language";

    static const values = [
        id,
        date,
        evaluatorId,
        participantId,
        status,
        language,
    ];
}

const scriptCreateTableEvaluations = '''
CREATE TABLE ${Tables.evaluations} (
  ${EvaluationFields.id} INTEGER PRIMARY KEY AUTOINCREMENT,
  ${EvaluationFields.date} TIMESTAMP NOT NULL,
  ${EvaluationFields.evaluatorId} INTEGER NOT NULL,
  ${EvaluationFields.participantId} INTEGER UNIQUE NOT NULL,
  ${EvaluationFields.status} INT CHECK(${EvaluationFields.status} >= 0 AND ${EvaluationFields.status} <= 3) NOT NULL,
  ${EvaluationFields.language} INT CHECK(${EvaluationFields.language} >= 1 AND ${EvaluationFields.language} <= 3),
  FOREIGN KEY (${EvaluationFields.evaluatorId}) REFERENCES ${Tables.evaluators}(${EvaluatorFields.id}),
  FOREIGN KEY (${EvaluationFields.participantId}) REFERENCES ${Tables.participants}(${ParticipantFields.id})
);
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluation\data\evaluation_local_datasource.dart ===
import 'package:sqflite_common/sqlite_api.dart';
import '../../../core/constants/database_constants.dart';
import '../../../core/database_helper.dart';
import '../../../core/logger/app_logger.dart';
import '../domain/evaluation_entity.dart';

class EvaluationLocalDataSource {
  final dbHelper = DatabaseHelper.instance;
  Future<Database> get _db async => dbHelper.database;

  Future<int?> insertEvaluation(DatabaseExecutor txn, Map<String, dynamic> data) async {
    AppLogger.db('Inserting evaluation for participantId=${data['participant_id']}');
    try {
      final id = await txn.insert(Tables.evaluations, data);
      AppLogger.db('Inserted evaluation with ID=$id');
      return id;
    } catch (e, s) {
      AppLogger.error('Error inserting evaluation', e, s);
      return null;
    }
  }

  Future<List<EvaluationEntity>> getAllEvaluations() async {
    final db = await _db;
    final maps = await db.query(Tables.evaluations);
    return maps.map(EvaluationEntity.fromMap).toList();
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluation\domain\evaluation_entity.dart ===
import 'dart:convert';

import '../../../core/constants/enums/progress_status.dart';
import '../data/evaluation_constants.dart';

class EvaluationEntity {
  final int? evaluationID;
  final int evaluatorID;
  final int participantID;
  final EvaluationStatus status;
  final DateTime evaluationDate;
  final int language;

  EvaluationEntity({
    this.evaluationID,
    DateTime? evaluationDate,
    this.status = EvaluationStatus.pending,
    required this.evaluatorID,
    required this.participantID,
    required this.language,
  }) : evaluationDate = evaluationDate ?? DateTime.now();

  Map<String, dynamic> toMap() => {
    EvaluationFields.id: evaluationID,
    EvaluationFields.date: evaluationDate.toIso8601String(),
    EvaluationFields.evaluatorId: evaluatorID,
    EvaluationFields.participantId: participantID,
    EvaluationFields.status: status.numericValue,
    EvaluationFields.language: language,
  };

  static EvaluationEntity fromMap(Map<String, dynamic> map) {
    return EvaluationEntity(
      evaluationID: map[EvaluationFields.id] as int?,
      evaluatorID: map[EvaluationFields.evaluatorId] as int,
      participantID: map[EvaluationFields.participantId] as int,
      language: map[EvaluationFields.language] as int,
      status: EvaluationStatus.fromValue(
        map[EvaluationFields.status] ?? 1,
      ),
      evaluationDate: map[EvaluationFields.date] != null
          ? DateTime.tryParse(map[EvaluationFields.date]) ?? DateTime.now()
          : DateTime.now(),
    );
  }

  String toJson() => jsonEncode(toMap());

  static EvaluationEntity fromJson(String jsonString) =>
      EvaluationEntity.fromMap(jsonDecode(jsonString));

  @override
  String toString() =>
      'EvaluationEntity(evaluationID: $evaluationID, evaluatorID: $evaluatorID, participantID: $participantID, status: ${status.description})';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluation\domain\usecases\create_participant_evaluation_usecase.dart ===
import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import '../../../../core/logger/app_logger.dart';
import '../../../../core/constants/enums/progress_status.dart';
import '../../../participant/domain/participant_entity.dart';
import '../../../participant/data/participant_local_datasource.dart';
import '../../../evaluation/data/evaluation_local_datasource.dart';
import '../../../evaluation/domain/evaluation_entity.dart';
import '../../../module/data/module_local_datasource.dart';
import '../../../module_instance/domain/module_instance_entity.dart';
import '../../../module_instance/domain/module_instance_repository.dart';
import '../../../task/data/task_local_datasource.dart';
import '../../../task_instance/domain/task_instance_entity.dart';
import '../../../task_instance/domain/task_instance_repository.dart';

class CreateParticipantEvaluationUseCase {
  final ParticipantLocalDataSource participantDataSource;
  final EvaluationLocalDataSource evaluationDataSource;
  final ModuleLocalDataSource moduleDataSource;
  final ModuleInstanceRepository moduleInstanceRepository;
  final TaskLocalDataSource taskDataSource;
  final TaskInstanceRepository taskInstanceRepository;
  final Database db;

  CreateParticipantEvaluationUseCase({
    required this.participantDataSource,
    required this.evaluationDataSource,
    required this.moduleDataSource,
    required this.moduleInstanceRepository,
    required this.taskDataSource,
    required this.taskInstanceRepository,
    required this.db,
  });

  Future<ParticipantEntity> execute({
    required ParticipantEntity participant,
    required int evaluatorId,
    int language = 1,
  }) async {
    AppLogger.info('[USECASE] Starting participant creation: ${participant.name}');

    late final ParticipantEntity createdParticipant;

    await db.transaction((txn) async {
      // 1Ô∏è‚É£ Create participant
      final participantId =
      await participantDataSource.insertParticipant(txn, participant.toMap());
      AppLogger.db('Participant inserted: id=$participantId');

      // 2Ô∏è‚É£ Create evaluation linking evaluator & participant
      final evaluation = EvaluationEntity(
        evaluatorID: evaluatorId,
        participantID: participantId!,
        status: EvaluationStatus.pending,
        language: language,
      );
      final evaluationId =
      await evaluationDataSource.insertEvaluation(txn, evaluation.toMap());
      AppLogger.db('Evaluation created: id=$evaluationId');

      // 3Ô∏è‚É£ Fetch modules and create module instances
      final modules = await moduleDataSource.getAllModules();
      for (final module in modules) {
        final moduleInstance = ModuleInstanceEntity(
          moduleId: module.moduleID!,
          evaluationId: evaluationId!,
          status: ModuleStatus.pending,
        );
        final moduleInstanceId = await moduleInstanceRepository
            .createModuleInstance(moduleInstance)
            .then((m) => m?.id);

        // 4Ô∏è‚É£ For each module, create task instances
        final tasks = await taskDataSource.getTasksByModuleId(module.moduleID!);
        for (final task in tasks) {
          final taskInstance = TaskInstanceEntity(
            taskId: task.taskID!,
            moduleInstanceId: moduleInstanceId!,
            status: TaskStatus.pending,
          );
          await taskInstanceRepository.insert(taskInstance);
        }
      }

      createdParticipant = participant.copyWith(participantID: participantId);
      AppLogger.info('[USECASE] ‚úÖ Participant + Evaluation hierarchy created.');
    });


    return createdParticipant;
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\application\evaluator_notifier.dart ===
import 'package:hooks_riverpod/hooks_riverpod.dart';
import '../../../core/database_helper.dart';
import '../../../core/logger/app_logger.dart';
import '../../../providers/providers.dart';
import '../data/evaluator_local_datasource.dart';
import '../data/evaluator_remote_datasource.dart';
import '../data/evaluator_repository_impl.dart';
import '../domain/evaluator_repository.dart';

class EvaluatorRepositoryNotifier extends AsyncNotifier<EvaluatorRepository> {
  @override
  Future<EvaluatorRepository> build() async {
    try {
      final env = ref.watch(environmentProvider);
      AppLogger.info('EvaluatorRepositoryNotifier started (env=$env)');

      if (env == AppEnv.local) {
        final db = await DatabaseHelper.instance.database;
        AppLogger.db('Initializing local EvaluatorRepository...');
        return EvaluatorRepositoryImpl.local(EvaluatorLocalDataSource(db));
      } else {
        AppLogger.info('Initializing remote EvaluatorRepository...');
        return EvaluatorRepositoryImpl.remote(EvaluatorRemoteDataSource());
      }
    } catch (e, s) {
      AppLogger.error('EvaluatorRepository initialization failed', e, s);
      rethrow;
    }
  }
}

final evaluatorRepositoryProvider =
AsyncNotifierProvider<EvaluatorRepositoryNotifier, EvaluatorRepository>(
  EvaluatorRepositoryNotifier.new,
);


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\data\current_user_constants.dart ===
const scriptCreateTableCurrentUser = '''
CREATE TABLE current_user (
  evaluator_id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  surname TEXT NOT NULL,
  email TEXT NOT NULL,
  birth_date TEXT,
  specialty TEXT,
  cpf_or_nif TEXT,
  username TEXT,
  password TEXT,
  first_login INTEGER NOT NULL DEFAULT 1,
  is_admin INTEGER NOT NULL DEFAULT 0
)
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\data\evaluator_constants.dart ===
import '../../../core/constants/database_constants.dart';

class EvaluatorFields {
  static const id = "evaluator_id";
  static const name = "name";
  static const surname = "surname";
  static const email = "email";
  static const birthDate = "birth_date";
  static const specialty = "specialty";
  static const cpf = "cpf";
  static const username = "username";
  static const password = "password";
  static const firstLogin = "first_login";
  static const isAdmin = "is_admin";

  static const all = [
    id,
    name,
    surname,
    email,
    birthDate,
    specialty,
    cpf,
    username,
    password,
    firstLogin,
    isAdmin,
  ];
}

const scriptCreateTableEvaluators = '''
CREATE TABLE ${Tables.evaluators} (
  ${EvaluatorFields.id} INTEGER PRIMARY KEY AUTOINCREMENT,
  ${EvaluatorFields.name} TEXT NOT NULL,
  ${EvaluatorFields.surname} TEXT NOT NULL,
  ${EvaluatorFields.email} TEXT NOT NULL,
  ${EvaluatorFields.birthDate} TIMESTAMP,
  ${EvaluatorFields.specialty} TEXT,
  ${EvaluatorFields.cpf} TEXT,
  ${EvaluatorFields.username} TEXT NOT NULL UNIQUE,
  ${EvaluatorFields.password} TEXT NOT NULL DEFAULT '0000',
  ${EvaluatorFields.firstLogin} INTEGER NOT NULL DEFAULT 0,
  ${EvaluatorFields.isAdmin} INTEGER NOT NULL DEFAULT 0
);
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\data\evaluator_local_datasource.dart ===
import 'package:sqflite_common/sqlite_api.dart';
import '../../../core/constants/database_constants.dart';
import '../../../core/logger/app_logger.dart';
import 'evaluator_model.dart';
import 'evaluator_constants.dart';

class EvaluatorLocalDataSource {
  final Database _db;
  EvaluatorLocalDataSource(this._db);

  /// Fetch all evaluators
  Future<List<EvaluatorModel>> getAll() async {
    AppLogger.db('[EVALUATOR] Fetching all evaluators');
    final result = await _db.query(Tables.evaluators);
    return result.map(EvaluatorModel.fromMap).toList();
  }

  /// Insert evaluator (replace on conflict)
  Future<void> insert(EvaluatorModel evaluator) async {
    AppLogger.db('[EVALUATOR] Inserting evaluator: ${evaluator.email}');
    await _db.insert(
      Tables.evaluators,
      evaluator.toMap(),
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
  }

  /// Get evaluator by ID
  Future<EvaluatorModel?> getById(int id) async {
    final result = await _db.query(
      Tables.evaluators,
      where: '${EvaluatorFields.id} = ?',
      whereArgs: [id],
      limit: 1,
    );
    return result.isNotEmpty ? EvaluatorModel.fromMap(result.first) : null;
  }

  Future<EvaluatorModel?> getFirstEvaluator() async {
    final result = await _db.query(
      Tables.evaluators,
      orderBy: '${EvaluatorFields.id} ASC',
      limit: 1,
    );
    return result.isNotEmpty ? EvaluatorModel.fromMap(result.first) : null;
  }


  /// ‚úÖ NEW: Check if there is any evaluator admin (legacy support)
  Future<bool> hasAnyEvaluatorAdmin() async {
    AppLogger.db('[EVALUATOR] Checking if any admin evaluator exists...');
    final result = await _db.query(
      Tables.evaluators,
      where: '${EvaluatorFields.isAdmin} = ?',
      whereArgs: [1],
      limit: 1,
    );
    return result.isNotEmpty;
  }

  /// Delete evaluator
  Future<int> deleteById(int id) async {
    return await _db.delete(
      Tables.evaluators,
      where: '${EvaluatorFields.id} = ?',
      whereArgs: [id],
    );
  }

  Future<bool> existsByEmail(String email) async {
    AppLogger.db('[EVALUATOR] Checking if evaluator exists for email: $email');
    try {
      final result = await _db.query(
        Tables.evaluators,
        where: '${EvaluatorFields.email} = ?',
        whereArgs: [email],
        limit: 1,
      );
      final exists = result.isNotEmpty;
      AppLogger.db('[EVALUATOR] existsByEmail($email) ‚Üí $exists');
      return exists;
    } catch (e, s) {
      AppLogger.error('[EVALUATOR] Error checking existsByEmail', e, s);
      return false;
    }
  }

}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\data\evaluator_model.dart ===
import 'package:segundo_cogni/features/evaluator/domain/evaluator_registration_data.dart';
import '../domain/evaluator_entity.dart';
import 'evaluator_constants.dart';

class EvaluatorModel extends EvaluatorEntity {
  const EvaluatorModel({
    super.evaluatorId,
    required super.name,
    required super.surname,
    required super.email,
    required super.birthDate,
    required super.specialty,
    required super.cpfOrNif,
    required super.username,
    required super.password,
    super.firstLogin = true,
  });

  factory EvaluatorModel.fromMap(Map<String, dynamic> map) => EvaluatorModel(
    evaluatorId: map[EvaluatorFields.id] as int?,
    name: map[EvaluatorFields.name],
    surname: map[EvaluatorFields.surname],
    email: map[EvaluatorFields.email],
    birthDate: map[EvaluatorFields.birthDate],
    specialty: map[EvaluatorFields.specialty],
    cpfOrNif: map[EvaluatorFields.cpf],
    username: map[EvaluatorFields.username],
    password: map[EvaluatorFields.password],
    firstLogin: (map[EvaluatorFields.firstLogin] as int) == 1,
  );

  Map<String, dynamic> toMap() => {
    EvaluatorFields.id: evaluatorId,
    EvaluatorFields.name: name,
    EvaluatorFields.surname: surname,
    EvaluatorFields.email: email,
    EvaluatorFields.birthDate: birthDate,
    EvaluatorFields.specialty: specialty,
    EvaluatorFields.cpf: cpfOrNif,
    EvaluatorFields.username: username,
    EvaluatorFields.password: password,
    EvaluatorFields.firstLogin: firstLogin ? 1 : 0,
  };

  Map<String, dynamic> toJson() => {
    'evaluator_id': evaluatorId,
    'name': name,
    'surname': surname,
    'email': email,
    'birthDate': birthDate,
    'specialty': specialty,
    'cpfOrNif': cpfOrNif,
    'username': username,
    'password': password,
    'firstLogin': firstLogin,
  };

  factory EvaluatorModel.fromEntity(EvaluatorEntity entity) => EvaluatorModel(
    evaluatorId: entity.evaluatorId,
    name: entity.name,
    surname: entity.surname,
    email: entity.email,
    birthDate: entity.birthDate,
    specialty: entity.specialty,
    cpfOrNif: entity.cpfOrNif,
    username: entity.username,
    password: entity.password,
    firstLogin: entity.firstLogin,
  );

  factory EvaluatorModel.fromDTO(EvaluatorRegistrationData dto) {
    return EvaluatorModel(
      name: dto.name,
      surname: dto.surname,
      email: dto.email,
      birthDate: dto.birthDate,
      specialty: dto.specialty,
      cpfOrNif: dto.cpf,
      username: dto.username,
      password: dto.password,
      firstLogin: dto.firstLogin,
    );
  }



}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\data\evaluator_remote_datasource.dart ===
import 'dart:convert';
import 'package:http/http.dart' as http;
import '../../../core/logger/app_logger.dart';
import 'evaluator_model.dart';

class EvaluatorRemoteDataSource {
  final String baseUrl = 'https://api.example.com/evaluators';

  Future<List<EvaluatorModel>> fetchAllEvaluators() async {
    final url = Uri.parse(baseUrl);
    AppLogger.info('HTTP GET ‚Üí $url');
    try {
      final response = await http.get(url);
      AppLogger.info('HTTP ${response.statusCode} ‚Üê $url');
      if (response.statusCode == 200) {
        final List<dynamic> data = jsonDecode(response.body);
        return data.map((e) => EvaluatorModel.fromMap(e)).toList();
      } else {
        AppLogger.warning('Failed to fetch evaluators: ${response.body}');
        return [];
      }
    } catch (e, s) {
      AppLogger.error('Error fetching evaluators from API', e, s);
      return [];
    }
  }

  Future<void> createEvaluator(EvaluatorModel evaluator) async {
    final url = Uri.parse(baseUrl);
    final body = jsonEncode(evaluator.toMap());
    AppLogger.info('HTTP POST ‚Üí $url | body: $body');
    try {
      final response = await http.post(
        url,
        headers: {'Content-Type': 'application/json'},
        body: body,
      );
      AppLogger.info('HTTP ${response.statusCode} ‚Üê $url');
      if (response.statusCode >= 400) {
        AppLogger.warning('Error creating evaluator: ${response.body}');
      }
    } catch (e, s) {
      AppLogger.error('HTTP POST failed for evaluator ${evaluator.email}', e, s);
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\data\evaluator_repository_impl.dart ===
import '../../../core/logger/app_logger.dart';
import '../domain/evaluator_repository.dart';
import '../domain/evaluator_registration_data.dart';
import 'evaluator_local_datasource.dart';
import 'evaluator_remote_datasource.dart';
import 'evaluator_model.dart';

class EvaluatorRepositoryImpl implements EvaluatorRepository {
  final EvaluatorLocalDataSource? _local;
  final EvaluatorRemoteDataSource? _remote;
  final bool _isLocal;

  EvaluatorRepositoryImpl.local(this._local)
      : _remote = null,
        _isLocal = true {
    AppLogger.info('[REPO] EvaluatorRepositoryImpl running in LOCAL mode');
  }

  EvaluatorRepositoryImpl.remote(this._remote)
      : _local = null,
        _isLocal = false {
    AppLogger.info('[REPO] EvaluatorRepositoryImpl running in REMOTE mode');
  }

  String get _mode => _isLocal ? 'LOCAL' : 'REMOTE';

  Future<List<EvaluatorModel>> getAllEvaluators() async {
    AppLogger.info('[REPO] Fetching all evaluators ($_mode)');
    try {
      if (_isLocal) {
        final list = await _local!.getAll();
        AppLogger.db('Fetched ${list.length} evaluators from local DB');
        return list;
      } else {
        final list = await _remote!.fetchAllEvaluators();
        AppLogger.info('Fetched ${list.length} evaluators from API');
        return list;
      }
    } catch (e, s) {
      AppLogger.error('[REPO] Error fetching all evaluators ($_mode)', e, s);
      rethrow;
    }
  }

  Future<void> addEvaluator(EvaluatorModel evaluator) async {
    AppLogger.info('[REPO] Adding evaluator ${evaluator.email} ($_mode)');
    try {
      if (_isLocal) {
        await _local!.insert(evaluator);
        AppLogger.db('[REPO] Evaluator inserted into local DB');
      } else {
        await _remote!.createEvaluator(evaluator);
        AppLogger.info('[REPO] Evaluator created remotely');
      }
    } catch (e, s) {
      AppLogger.error('[REPO] Failed to add evaluator', e, s);
      rethrow;
    }
  }

  @override
  Future<void> insertEvaluator(EvaluatorRegistrationData data) async {
    final model = EvaluatorModel.fromDTO(data);
    await _local!.insert(model);
  }

  @override
  Future<bool> hasAnyEvaluatorAdmin() async {
    return await _local!.hasAnyEvaluatorAdmin();
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\domain\evaluator_entity.dart ===
class EvaluatorEntity {
  final int? evaluatorId;
  final String name;
  final String surname;
  final String email;
  final String birthDate;
  final String specialty;
  final String cpfOrNif;
  final String username;
  final String password;
  final bool firstLogin;

  const EvaluatorEntity({
    this.evaluatorId,
    required this.name,
    required this.surname,
    required this.email,
    required this.birthDate,
    required this.specialty,
    required this.cpfOrNif,
    required this.username,
    required this.password,
    this.firstLogin = true,
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\domain\evaluator_registration_data.dart ===
class EvaluatorRegistrationData {
  final String name;
  final String surname;
  final String email;
  final String birthDate;
  final String specialty;
  final String cpf;
  final String username;
  final String password;
  final bool isAdmin;
  final bool firstLogin;

  EvaluatorRegistrationData({
    required this.name,
    required this.surname,
    required this.email,
    required this.birthDate,
    required this.specialty,
    required this.cpf,
    required this.username,
    required this.password,
    this.isAdmin = false,
    this.firstLogin = true,
  });

  Map<String, dynamic> toMap() => {
    'name': name,
    'surname': surname,
    'email': email,
    'birthDate': birthDate,
    'specialty': specialty,
    'cpfOrNif': cpf,
    'username': username,
    'password': password,
    'isAdmin': isAdmin,
    'firstLogin': firstLogin,
  };
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\domain\evaluator_repository.dart ===
import 'evaluator_registration_data.dart';

abstract class EvaluatorRepository {
  Future<void> insertEvaluator(EvaluatorRegistrationData data);
  Future<bool> hasAnyEvaluatorAdmin();
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\presentation\evaluator_registration_form.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:intl/intl.dart';
import 'package:syncfusion_flutter_datepicker/datepicker.dart';
import 'package:go_router/go_router.dart';

import '../../../../core/logger/app_logger.dart';
import '../../../../core/theme/app_colors.dart';
import '../domain/evaluator_registration_data.dart';
import 'evaluator_registration_provider.dart';

class EvaluatorRegistrationForm extends HookConsumerWidget {
  const EvaluatorRegistrationForm({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    AppLogger.nav('Opened EvaluatorRegistrationForm');

    final formKey = useMemoized(() => GlobalKey<FormState>());
    final nameController = useTextEditingController();
    final surnameController = useTextEditingController();
    final emailController = useTextEditingController();
    final usernameController = useTextEditingController();
    final cpfController = useTextEditingController();
    final passwordController = useTextEditingController();
    final confirmPasswordController = useTextEditingController();
    final specialtyController = useTextEditingController();

    final selectedDate = useState<DateTime?>(null);
    final showPassword = useState(false);
    final showConfirmPassword = useState(false);
    final manualUsername = useState(false);
    final isDateExpanded = useState(false);
    final isRedirecting = useState(false);

    final state = ref.watch(evaluatorRegistrationProvider);
    final notifier = ref.read(evaluatorRegistrationProvider.notifier);

    // auto-generate username
    useEffect(() {
      void listener() {
        if (!manualUsername.value) {
          final name = nameController.text.trim();
          final surname = surnameController.text.trim();
          if (name.isNotEmpty && surname.isNotEmpty) {
            usernameController.text =
            "${name.toLowerCase()}_${surname.toLowerCase()}";
          } else {
            usernameController.clear();
          }
        }
      }

      nameController.addListener(listener);
      surnameController.addListener(listener);
      return () {
        nameController.removeListener(listener);
        surnameController.removeListener(listener);
      };
    }, [manualUsername.value]);

    // Listen for registration result
    ref.listen<AsyncValue<EvaluatorRegistrationState>>(
      evaluatorRegistrationProvider,
          (prev, next) {
        next.whenData((value) async {
          if (value == EvaluatorRegistrationState.success) {
            AppLogger.info('Evaluator registered successfully ‚Äî redirecting');
            isRedirecting.value = true;

            displayInfoBar(
              context,
              builder: (ctx, close) => InfoBar(
                title: const Text("Avaliador registrado!"),
                content:
                const Text("Voc√™ ser√° redirecionado para o home!"),
                severity: InfoBarSeverity.success,
                isLong: true,
                onClose: close,
              ),
            );

            await Future.delayed(const Duration(seconds: 2));
            if (context.mounted) {
              AppLogger.nav('Navigating to /home after registration');
              context.go('/home');
            }
          }
        });
      },
    );

    Future<void> _submit() async {
      if (!formKey.currentState!.validate() || selectedDate.value == null) {
        AppLogger.warning('Registration form validation failed');
        return;
      }

      final data = EvaluatorRegistrationData(
        name: nameController.text,
        surname: surnameController.text,
        email: emailController.text,
        birthDate: DateFormat('yyyy-MM-dd').format(selectedDate.value!),
        cpf: cpfController.text,
        username: usernameController.text,
        password: passwordController.text,
        specialty: specialtyController.text,
        isAdmin: false,
      );

      AppLogger.info('Submitting evaluator registration for ${data.email}');
      await notifier.registerEvaluator(data);
    }

    return Container(
      padding: const EdgeInsets.all(24),
      decoration: BoxDecoration(
        gradient: const LinearGradient(
          colors: [Color(0xFF141E30), Color(0xFF243B55)],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        borderRadius: BorderRadius.circular(16),
      ),
      child: Form(
        key: formKey,
        child: ListView(
          shrinkWrap: true,
          children: [
            const Text(
              "Registro de Administrador",
              textAlign: TextAlign.center,
              style: TextStyle(
                fontSize: 28,
                fontWeight: FontWeight.bold,
                color: AppColors.softWhite,
              ),
            ),
            const SizedBox(height: 24),

            // name + surname
            Row(
              children: [
                Expanded(child: _buildTextField("Nome", nameController)),
                const SizedBox(width: 12),
                Expanded(child: _buildTextField("Sobrenome", surnameController)),
              ],
            ),

            // email + cpf
            Row(
              children: [
                Expanded(child: _buildTextField("Email", emailController)),
                const SizedBox(width: 12),
                Expanded(child: _buildTextField("CPF/NIF", cpfController)),
              ],
            ),

            // username + checkbox
            Padding(
              padding: const EdgeInsets.only(bottom: 16),
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.end,
                children: [
                  Expanded(
                    child: InfoLabel(
                      label: "Usu√°rio",
                      child: TextFormBox(
                        controller: usernameController,
                        enabled: manualUsername.value,
                        validator: (v) =>
                        v!.isEmpty ? "Campo obrigat√≥rio" : null,
                      ),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Padding(
                    padding: const EdgeInsets.only(bottom: 8),
                    child: Checkbox(
                      content: const Text("Definir usu√°rio manualmente"),
                      checked: manualUsername.value,
                      onChanged: (v) {
                        manualUsername.value = v ?? false;
                        AppLogger.debug(
                            'Manual username mode: ${manualUsername.value}');
                      },
                    ),
                  ),
                ],
              ),
            ),

            // password + confirm password
            Row(
              children: [
                Expanded(
                  child: _buildPasswordField(
                    "Senha",
                    passwordController,
                    showPassword,
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: _buildPasswordField(
                    "Confirmar Senha",
                    confirmPasswordController,
                    showConfirmPassword,
                    confirm: passwordController,
                  ),
                ),
              ],
            ),

            const SizedBox(height: 16),

            // date picker
            InfoLabel(
              label: "Data de Nascimento",
              child: Expander(
                key: ValueKey(isDateExpanded.value),
                initiallyExpanded: isDateExpanded.value,
                onStateChanged: (open) =>
                isDateExpanded.value = open,
                header: Text(
                  selectedDate.value != null
                      ? DateFormat('dd/MM/yyyy')
                      .format(selectedDate.value!)
                      : "Selecionar data",
                ),
                content: SfDateRangePicker(
                  onSelectionChanged: (args) {
                    selectedDate.value = args.value;
                    isDateExpanded.value = false;
                    AppLogger.debug(
                        'Selected birth date: ${selectedDate.value}');
                  },
                  selectionMode: DateRangePickerSelectionMode.single,
                  initialSelectedDate: selectedDate.value,
                  showNavigationArrow: true,
                  todayHighlightColor: AppColors.primary,
                  selectionColor: AppColors.primary,
                ),
              ),
            ),

            const SizedBox(height: 16),
            _buildTextField("Especialidade", specialtyController),
            const SizedBox(height: 24),

            FilledButton(
              style: ButtonStyle(
                backgroundColor: ButtonState.all(AppColors.primary),
              ),
              onPressed: state.isLoading || isRedirecting.value ? null : _submit,
              child: (state.isLoading || isRedirecting.value)
                  ? const ProgressRing()
                  : const Text("Registrar"),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildTextField(String label, TextEditingController controller) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12),
      child: InfoLabel(
        label: label,
        child: TextFormBox(
          controller: controller,
          validator: (v) => v!.isEmpty ? "Campo obrigat√≥rio" : null,
        ),
      ),
    );
  }

  Widget _buildPasswordField(String label, TextEditingController controller,
      ValueNotifier<bool> show, {TextEditingController? confirm}) {
    return InfoLabel(
      label: label,
      child: TextFormBox(
        controller: controller,
        obscureText: !show.value,
        placeholder: label == "Senha"
            ? "Digite a senha"
            : "Repita a senha",
        validator: (v) {
          if (v == null || v.isEmpty) return "Campo obrigat√≥rio";
          if (label == "Confirmar Senha" &&
              v != confirm?.text) {
            return "As senhas n√£o coincidem";
          }
          if (label == "Senha" && v.length < 6) {
            return "M√≠nimo 6 caracteres";
          }
          return null;
        },
        suffix: IconButton(
          icon: Icon(show.value
              ? FluentIcons.hide3
              : FluentIcons.view),
          onPressed: () => show.value = !show.value,
        ),
      ),
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\presentation\evaluator_registration_provider.dart ===
import 'package:hooks_riverpod/hooks_riverpod.dart';
import '../../../core/logger/app_logger.dart';
import '../application/evaluator_notifier.dart';
import '../domain/evaluator_registration_data.dart';
import '../domain/evaluator_repository.dart';

enum EvaluatorRegistrationState { initial, loading, success, error }

class EvaluatorRegistrationNotifier
    extends AsyncNotifier<EvaluatorRegistrationState> {
  late final EvaluatorRepository _repository;

  @override
  Future<EvaluatorRegistrationState> build() async {
    _repository = await ref.watch(evaluatorRepositoryProvider.future);
    AppLogger.info('EvaluatorRegistrationNotifier initialized');
    return EvaluatorRegistrationState.initial;
  }

  Future<void> registerEvaluator(EvaluatorRegistrationData data) async {
    AppLogger.info('Starting evaluator registration for ${data.email}');
    state = const AsyncValue.loading();

    try {
      await _repository.insertEvaluator(data);
      AppLogger.info('Evaluator ${data.email} registered successfully');
      state = const AsyncValue.data(EvaluatorRegistrationState.success);
    } catch (e, s) {
      AppLogger.error('Error registering evaluator ${data.email}', e, s);
      state = const AsyncValue.data(EvaluatorRegistrationState.error);
    }
  }
}

final evaluatorRegistrationProvider =
AsyncNotifierProvider<EvaluatorRegistrationNotifier,
    EvaluatorRegistrationState>(
  EvaluatorRegistrationNotifier.new,
);


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\presentation\evaluator_registration_screen.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import '../../../../core/logger/app_logger.dart';
import '../../../../core/theme/app_colors.dart';
import 'evaluator_registration_form.dart';

class EvaluatorRegistrationScreen extends StatelessWidget {
  const EvaluatorRegistrationScreen({super.key});

  @override
  Widget build(BuildContext context) {
    AppLogger.nav('Opened EvaluatorRegistrationScreen');
    return NavigationView(
      content: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [
              AppColors.midnightBlue,
              AppColors.deepSeaBlue,
              AppColors.steelBlue,
            ],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: Center(
          child: Padding(
            padding: const EdgeInsets.all(24),
            child: ConstrainedBox(
              constraints: const BoxConstraints(maxWidth: 700),
              child: const EvaluatorRegistrationForm(),
            ),
          ),
        ),
      ),
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\presentation\providers\evaluator_provider.dart ===
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../../core/database_helper.dart';
import '../../data/evaluator_local_datasource.dart';
import '../../data/evaluator_model.dart';

final currentEvaluatorProvider = FutureProvider<EvaluatorModel?>((ref) async {
  final db = await DatabaseHelper.instance.database;
  final ds = EvaluatorLocalDataSource(db);
  return await ds.getFirstEvaluator();
});


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\home\home_screen.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

import '../../core/logger/app_logger.dart';
import '../evaluator/data/evaluator_model.dart';
import '../../providers/providers.dart';
import '../participant/domain/participant_entity.dart';
import '../participant/presentation/create_participant_evaluation_provider.dart';

class HomeScreen extends HookConsumerWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final EvaluatorModel? user = ref.watch(currentUserProvider);

    // Listen for creation state changes
    ref.listen(createParticipantEvaluationProvider, (_, next) {
      next.whenOrNull(
        data: (participant) => _showSuccessInfoBar(context, ref, participant),
        error: (e, _) => _showErrorInfoBar(context, e.toString()),
      );
    });

    return NavigationView(
      content: ScaffoldPage.scrollable(
        header: PageHeader(
          title: Text(
            "Bem-vindo, ${user?.name ?? 'Usu√°rio'} üëã",
            style: FluentTheme.of(context).typography.title,
          ),
        ),
        children: [
          _buildQuickActions(context, ref, user),
          const SizedBox(height: 32),
          _buildRecentActivity(),
        ],
      ),
    );
  }

  Widget _buildQuickActions(
      BuildContext context, WidgetRef ref, EvaluatorModel? user) {
    return Wrap(
      spacing: 16,
      runSpacing: 12,
      children: [
        _quickActionButton(
          icon: FluentIcons.people_add,
          label: 'Novo Participante',
          onPressed: () {
            ref
                .read(createParticipantEvaluationProvider.notifier)
                .createParticipantWithEvaluation(
              evaluatorId: user?.evaluatorId ?? 1,
            );
          },
        ),
      ],
    );
  }

  Widget _quickActionButton({
    required IconData icon,
    required String label,
    required VoidCallback onPressed,
  }) {
    return FilledButton(
      onPressed: onPressed,
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [Icon(icon), const SizedBox(width: 8), Text(label)],
      ),
    );
  }

  Widget _buildRecentActivity() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: const [
        Text(
          "üïì Atividades Recentes",
          style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
        ),
        SizedBox(height: 12),
        Text("Cria√ß√µes recentes aparecer√£o aqui em breve."),
      ],
    );
  }

  // === FEEDBACK ===
  void _showSuccessInfoBar(
      BuildContext context,
      WidgetRef ref,
      ParticipantEntity? participant,
      ) {
    AppLogger.info('[UI] Participant created successfully.');

    if (participant == null) return;

    displayInfoBar(
      context,
      builder: (ctx, close) => InfoBar(
        title: const Text('Sucesso'),
        content: Text(
          'Participante "${participant.fullName}" e avalia√ß√£o criados com sucesso!',
        ),
        severity: InfoBarSeverity.success,
        action: IconButton(
          icon: const Icon(FluentIcons.info),
          onPressed: () {
            close();
            _showParticipantDetailsDialog(context, participant);
          },
        ),
      ),
    );
  }

  void _showErrorInfoBar(BuildContext context, String message) {
    AppLogger.warning('[UI] Participant creation failed: $message');
    displayInfoBar(
      context,
      builder: (ctx, close) => InfoBar(
        title: const Text('Erro'),
        content: Text(message),
        severity: InfoBarSeverity.error,
        action: IconButton(
          icon: const Icon(FluentIcons.clear),
          onPressed: close,
        ),
      ),
    );
  }

  Future<void> _showParticipantDetailsDialog(
      BuildContext context,
      ParticipantEntity participant,
      ) async {
    await showDialog(
      context: context,
      builder: (ctx) => ContentDialog(
        title: const Text('Novo Participante Criado'),
        content: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('üßç Nome: ${participant.fullName}'),
            Text('üéÇ Nascimento: ${participant.birthDate.toLocal()}'),
            Text('üéì Educa√ß√£o: ${participant.educationLevel}'),
            const Text('üìä Status da Avalia√ß√£o: Pendente'),
          ],
        ),
        actions: [
          Button(
            child: const Text('Fechar'),
            onPressed: () => Navigator.pop(ctx),
          ),
        ],
      ),
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module\data\module_constants.dart ===
import '../../../core/constants/database_constants.dart';

class ModuleFields {
  static const id = 'module_id';
  static const title = 'title';

  static const values = [id, title];
}

const scriptCreateTableModules = '''
CREATE TABLE ${Tables.modules} (
  ${ModuleFields.id} INTEGER PRIMARY KEY AUTOINCREMENT,
  ${ModuleFields.title} TEXT NOT NULL
)
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module\data\module_local_datasource.dart ===
import 'package:sqflite_common/sqlite_api.dart';
import '../../../core/constants/database_constants.dart';
import '../../../core/database_helper.dart';
import '../../../core/logger/app_logger.dart';
import 'module_constants.dart';
import 'module_model.dart';

class ModuleLocalDataSource {
  final dbHelper = DatabaseHelper.instance;
  Future<Database> get _db async => dbHelper.database;

  Future<int?> insertModule(ModuleModel module) async {
    AppLogger.db('Inserting module: ${module.title}');
    try {
      final db = await _db;
      final id = await db.insert(
        Tables.modules,
        module.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
      AppLogger.db('Module inserted successfully (id=$id)');
      return id;
    } catch (e, s) {
      AppLogger.error('Error inserting module ${module.title}', e, s);
      return null;
    }
  }

  Future<List<ModuleModel>> getAllModules() async {
    AppLogger.db('Fetching all modules');
    try {
      final db = await _db;
      final maps = await db.query(Tables.modules);
      AppLogger.db('Fetched ${maps.length} modules');
      return maps.map(ModuleModel.fromMap).toList();
    } catch (e, s) {
      AppLogger.error('Error fetching modules', e, s);
      return [];
    }
  }

  Future<ModuleModel?> getModuleById(int id) async {
    AppLogger.db('Fetching module by ID: $id');
    try {
      final db = await _db;
      final result = await db.query(
        Tables.modules,
        where: '${ModuleFields.id} = ?',
        whereArgs: [id],
      );
      return result.isNotEmpty ? ModuleModel.fromMap(result.first) : null;
    } catch (e, s) {
      AppLogger.error('Error fetching module by ID: $id', e, s);
      return null;
    }
  }

  Future<ModuleModel?> getModuleByTitle(String title) async {
    AppLogger.db('Fetching module by title: $title');
    try {
      final db = await _db;
      final result = await db.query(
        Tables.modules,
        where: '${ModuleFields.title} = ?',
        whereArgs: [title],
      );
      return result.isNotEmpty ? ModuleModel.fromMap(result.first) : null;
    } catch (e, s) {
      AppLogger.error('Error fetching module by title: $title', e, s);
      return null;
    }
  }

  Future<int> updateModule(ModuleModel module) async {
    AppLogger.db('Updating module ID=${module.moduleID}');
    try {
      final db = await _db;
      final rows = await db.update(
        Tables.modules,
        module.toMap(),
        where: '${ModuleFields.id} = ?',
        whereArgs: [module.moduleID],
      );
      AppLogger.db('Updated $rows row(s) for module ID=${module.moduleID}');
      return rows;
    } catch (e, s) {
      AppLogger.error('Error updating module ID=${module.moduleID}', e, s);
      return 0;
    }
  }

  Future<int> deleteModule(int id) async {
    AppLogger.db('Deleting module ID=$id');
    try {
      final db = await _db;
      final count = await db.delete(
        Tables.modules,
        where: '${ModuleFields.id} = ?',
        whereArgs: [id],
      );
      AppLogger.db('Deleted $count module(s)');
      return count;
    } catch (e, s) {
      AppLogger.error('Error deleting module ID=$id', e, s);
      return 0;
    }
  }

  Future<int> getNumberOfModules() async {
    AppLogger.db('Counting modules');
    try {
      final db = await _db;
      final result =
      await db.rawQuery('SELECT COUNT(*) AS count FROM ${Tables.modules}');
      final count = (result.first['count'] as int?) ?? 0;
      AppLogger.db('Module count: $count');
      return count;
    } catch (e, s) {
      AppLogger.error('Error counting modules', e, s);
      return 0;
    }
  }

  Future<bool> exists(String moduleId) async {
    final db = await _db;
    final result = await db.query(
      'modules',
      where: '${ModuleFields.id} = ?',
      whereArgs: [moduleId],
      limit: 1,
    );
    return result.isNotEmpty;
  }

}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module\data\module_model.dart ===
import '../../../features/module/domain/module_entity.dart';
import '../../../features/module/data/module_constants.dart';

class ModuleModel extends ModuleEntity {
  const ModuleModel({
    super.moduleID,
    required super.title,
    super.tasks = const [],
  });

  factory ModuleModel.fromMap(Map<String, dynamic> map) {
    return ModuleModel(
      moduleID: map[ModuleFields.id] as int?,
      title: map[ModuleFields.title] as String,
    );
  }

  Map<String, dynamic> toMap() => {
    ModuleFields.id: moduleID,
    ModuleFields.title: title,
  };

  factory ModuleModel.fromEntity(ModuleEntity entity) {
    return ModuleModel(
      moduleID: entity.moduleID,
      title: entity.title,
      tasks: entity.tasks,
    );
  }

  ModuleEntity toEntity() => ModuleEntity(
    moduleID: moduleID,
    title: title,
    tasks: tasks,
  );
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module\data\module_repository_impl.dart ===
import '../../task/data/task_local_datasource.dart';
import '../domain/module_entity.dart';
import '../domain/module_repository.dart';
import 'module_local_datasource.dart';
import 'module_model.dart';

class ModuleRepositoryImpl implements ModuleRepository {
  final ModuleLocalDataSource localDataSource;
  final TaskLocalDataSource taskLocalDataSource;

  ModuleRepositoryImpl({
    required this.localDataSource,
    required this.taskLocalDataSource,
  });

  @override
  Future<int?> insertModule(ModuleEntity module) async {
    final model = ModuleModel.fromEntity(module);
    return await localDataSource.insertModule(model);
  }

  @override
  Future<List<ModuleEntity>> getAllModules() async {
    final modules = await localDataSource.getAllModules();
    return modules.map((m) => m.toEntity()).toList();
  }

  @override
  Future<ModuleEntity?> getModuleById(int id) async {
    final module = await localDataSource.getModuleById(id);
    if (module == null) return null;

    final tasks = await taskLocalDataSource.getTasksByModuleId(id);
    return module.toEntity().copyWith(tasks: tasks);
  }

  @override
  Future<ModuleEntity?> getModuleByTitle(String title) async {
    final module = await localDataSource.getModuleByTitle(title);
    if (module == null) return null;

    final tasks = await taskLocalDataSource.getTasksByModuleId(module.moduleID!);
    return module.toEntity().copyWith(tasks: tasks);
  }


  @override
  Future<int> updateModule(ModuleEntity module) async {
    final model = ModuleModel.fromEntity(module);
    return await localDataSource.updateModule(model);
  }

  @override
  Future<int> deleteModule(int id) async {
    return await localDataSource.deleteModule(id);
  }

  @override
  Future<int> getNumberOfModules() async {
    return await localDataSource.getNumberOfModules();
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module\domain\module_entity.dart ===
import '../../task/domain/task_entity.dart';

class ModuleEntity {
  final int? moduleID;
  final String title;
  final List<TaskEntity> tasks;

  const ModuleEntity({
    this.moduleID,
    required this.title,
    this.tasks = const [],
  });

  Map<String, dynamic> toMap() => {
    'module_id': moduleID,
    'title': title,
  };

  factory ModuleEntity.fromMap(Map<String, dynamic> map) {
    return ModuleEntity(
      moduleID: map['module_id'] as int?,
      title: map['title'] as String,
    );
  }

  ModuleEntity copyWith({
    int? moduleID,
    String? title,
    List<TaskEntity>? tasks,
  }) {
    return ModuleEntity(
      moduleID: moduleID ?? this.moduleID,
      title: title ?? this.title,
      tasks: tasks ?? this.tasks,
    );
  }

  @override
  String toString() => 'ModuleEntity(id: $moduleID, title: $title, tasks: $tasks)';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module\domain\module_repository.dart ===
import 'module_entity.dart';

abstract class ModuleRepository {
  Future<int?> insertModule(ModuleEntity module);
  Future<List<ModuleEntity>> getAllModules();
  Future<ModuleEntity?> getModuleById(int id);
  Future<ModuleEntity?> getModuleByTitle(String title);
  Future<int> updateModule(ModuleEntity module);
  Future<int> deleteModule(int id);
  Future<int> getNumberOfModules();
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module_instance\data\module_instance_constants.dart ===
import '../../../core/constants/database_constants.dart';
import '../../evaluation/data/evaluation_constants.dart';
import '../../module/data/module_constants.dart';

class ModuleInstanceFields {
  static const id = 'module_inst_id';
  static const moduleId = ModuleFields.id;
  static const evaluationId = EvaluationFields.id;
  static const status = 'status';

  static const values = [id, moduleId, evaluationId, status];
}

const scriptCreateTableModuleInstances = '''
CREATE TABLE ${Tables.moduleInstances} (
  ${ModuleInstanceFields.id} INTEGER PRIMARY KEY AUTOINCREMENT,
  ${ModuleInstanceFields.moduleId} INTEGER NOT NULL,
  ${ModuleInstanceFields.evaluationId} INTEGER NOT NULL,
  ${ModuleInstanceFields.status} INT NOT NULL CHECK(${ModuleInstanceFields.status} >= 1 AND ${ModuleInstanceFields.status} <= 3),
  FOREIGN KEY (${ModuleInstanceFields.moduleId}) REFERENCES ${Tables.modules}(${ModuleFields.id}),
  FOREIGN KEY (${ModuleInstanceFields.evaluationId}) REFERENCES ${Tables.evaluations}(${EvaluationFields.id})
)
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module_instance\data\module_instance_local_datasource.dart ===
import 'package:sqflite_common/sqlite_api.dart';
import '../../../core/database_helper.dart';
import '../../../core/logger/app_logger.dart';
import '../../../core/constants/database_constants.dart';
import '../../../core/constants/enums/progress_status.dart';
import 'module_instance_constants.dart';
import 'module_instance_model.dart';

class ModuleInstanceLocalDataSource {
  final dbHelper = DatabaseHelper.instance;
  Future<Database> get _db async => dbHelper.database;

  Future<int?> insertModuleInstance(ModuleInstanceModel instance) async {
    AppLogger.db('Inserting module instance for evaluationId=${instance.evaluationId}');
    try {
      final db = await _db;
      final id = await db.insert(
        Tables.moduleInstances,
        instance.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
      AppLogger.db('Module instance inserted (id=$id)');
      return id;
    } catch (e, s) {
      AppLogger.error('Error inserting module instance', e, s);
      return null;
    }
  }

  Future<ModuleInstanceModel?> getModuleInstanceById(int id) async {
    AppLogger.db('Fetching module instance ID=$id');
    try {
      final db = await _db;
      final maps = await db.query(
        Tables.moduleInstances,
        where: '${ModuleInstanceFields.id} = ?',
        whereArgs: [id],
      );
      return maps.isNotEmpty ? ModuleInstanceModel.fromMap(maps.first) : null;
    } catch (e, s) {
      AppLogger.error('Error fetching module instance ID=$id', e, s);
      return null;
    }
  }

  Future<List<ModuleInstanceModel>> getAllModuleInstances() async {
    AppLogger.db('Fetching all module instances');
    try {
      final db = await _db;
      final maps = await db.query(Tables.moduleInstances);
      AppLogger.db('Fetched ${maps.length} module instances');
      return maps.map(ModuleInstanceModel.fromMap).toList();
    } catch (e, s) {
      AppLogger.error('Error fetching all module instances', e, s);
      return [];
    }
  }

  Future<List<ModuleInstanceModel>> getModuleInstancesByEvaluationId(int evaluationId) async {
    AppLogger.db('Fetching module instances by evaluationId=$evaluationId');
    try {
      final db = await _db;
      final maps = await db.query(
        Tables.moduleInstances,
        where: '${ModuleInstanceFields.evaluationId} = ?',
        whereArgs: [evaluationId],
      );
      AppLogger.db('Fetched ${maps.length} instances for evaluationId=$evaluationId');
      return maps.map(ModuleInstanceModel.fromMap).toList();
    } catch (e, s) {
      AppLogger.error('Error fetching instances by evaluationId=$evaluationId', e, s);
      return [];
    }
  }

  Future<int> updateModuleInstance(ModuleInstanceModel instance) async {
    AppLogger.db('Updating module instance ID=${instance.id}');
    try {
      final db = await _db;
      final rows = await db.update(
        Tables.moduleInstances,
        instance.toMap(),
        where: '${ModuleInstanceFields.id} = ?',
        whereArgs: [instance.id],
      );
      AppLogger.db('Updated $rows row(s)');
      return rows;
    } catch (e, s) {
      AppLogger.error('Error updating module instance ID=${instance.id}', e, s);
      return 0;
    }
  }

  Future<int> deleteModuleInstance(int id) async {
    AppLogger.db('Deleting module instance ID=$id');
    try {
      final db = await _db;
      final count = await db.delete(
        Tables.moduleInstances,
        where: '${ModuleInstanceFields.id} = ?',
        whereArgs: [id],
      );
      AppLogger.db('Deleted $count module instance(s)');
      return count;
    } catch (e, s) {
      AppLogger.error('Error deleting module instance ID=$id', e, s);
      return 0;
    }
  }

  Future<int> getCount() async {
    AppLogger.db('Counting module instances');
    try {
      final db = await _db;
      final result = await db.rawQuery('SELECT COUNT(*) AS count FROM ${Tables.moduleInstances}');
      final count = (result.first['count'] as int?) ?? 0;
      AppLogger.db('Module instance count: $count');
      return count;
    } catch (e, s) {
      AppLogger.error('Error counting module instances', e, s);
      return 0;
    }
  }

  Future<int> setStatus(int instanceId, ModuleStatus status) async {
    AppLogger.db('Setting status=${status.name} for moduleInstanceId=$instanceId');
    try {
      final db = await _db;
      final rows = await db.update(
        Tables.moduleInstances,
        {ModuleInstanceFields.status: status.numericValue},
        where: '${ModuleInstanceFields.id} = ?',
        whereArgs: [instanceId],
      );
      AppLogger.db('Updated status for $rows row(s)');
      return rows;
    } catch (e, s) {
      AppLogger.error('Error setting status for moduleInstanceId=$instanceId', e, s);
      return 0;
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module_instance\data\module_instance_model.dart ===
import '../../../core/constants/enums/progress_status.dart';
import '../../module_instance/domain/module_instance_entity.dart';
import 'module_instance_constants.dart';

class ModuleInstanceModel extends ModuleInstanceEntity {
  const ModuleInstanceModel({
    super.id,
    required super.moduleId,
    required super.evaluationId,
    required super.status,
    super.module,
  });

  factory ModuleInstanceModel.fromMap(Map<String, dynamic> map) {
    return ModuleInstanceModel(
      id: map[ModuleInstanceFields.id] as int?,
      moduleId: map[ModuleInstanceFields.moduleId] as int,
      evaluationId: map[ModuleInstanceFields.evaluationId] as int,
      status: ModuleStatus.fromValue(map[ModuleInstanceFields.status] as int),
    );
  }

  Map<String, dynamic> toMap() => {
    ModuleInstanceFields.id: id,
    ModuleInstanceFields.moduleId: moduleId,
    ModuleInstanceFields.evaluationId: evaluationId,
    ModuleInstanceFields.status: status.numericValue,
  };

  factory ModuleInstanceModel.fromEntity(ModuleInstanceEntity entity) {
    return ModuleInstanceModel(
      id: entity.id,
      moduleId: entity.moduleId,
      evaluationId: entity.evaluationId,
      status: entity.status,
      module: entity.module,
    );
  }

  ModuleInstanceEntity toEntity() {
    return ModuleInstanceEntity(
      id: id,
      moduleId: moduleId,
      evaluationId: evaluationId,
      status: status,
      module: module,
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module_instance\data\module_instance_repository_impl.dart ===
import '../../../core/constants/enums/progress_status.dart';
import '../domain/module_instance_repository.dart';
import '../domain/module_instance_entity.dart';
import 'module_instance_model.dart';
import 'module_instance_local_datasource.dart';

class ModuleInstanceRepositoryImpl implements ModuleInstanceRepository {
  final ModuleInstanceLocalDataSource localDataSource;

  ModuleInstanceRepositoryImpl({required this.localDataSource});

  @override
  Future<ModuleInstanceEntity?> createModuleInstance(
      ModuleInstanceEntity instance) async {
    final model = ModuleInstanceModel.fromEntity(instance);
    final id = await localDataSource.insertModuleInstance(model);
    if (id == null) return null;
    final created = await localDataSource.getModuleInstanceById(id);
    return created?.toEntity();
  }

  @override
  Future<ModuleInstanceEntity?> getModuleInstanceById(int id) async {
    final model = await localDataSource.getModuleInstanceById(id);
    return model?.toEntity();
  }

  @override
  Future<List<ModuleInstanceEntity>> getAllModuleInstances() async {
    final models = await localDataSource.getAllModuleInstances();
    return models.map((m) => m.toEntity()).toList();
  }

  @override
  Future<List<ModuleInstanceEntity>> getModuleInstancesByEvaluationId(
      int evaluationId) async {
    final models =
    await localDataSource.getModuleInstancesByEvaluationId(evaluationId);
    return models.map((m) => m.toEntity()).toList();
  }

  @override
  Future<int> updateModuleInstance(ModuleInstanceEntity instance) async {
    final model = ModuleInstanceModel.fromEntity(instance);
    return await localDataSource.updateModuleInstance(model);
  }

  @override
  Future<int> deleteModuleInstance(int id) async {
    return await localDataSource.deleteModuleInstance(id);
  }

  @override
  Future<int> getCount() async {
    return await localDataSource.getCount();
  }

  @override
  Future<int> setModuleInstanceStatus(int instanceId, ModuleStatus status) async {
    return await localDataSource.setStatus(instanceId, status);
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module_instance\domain\module_instance_entity.dart ===
import '../../../core/constants/enums/progress_status.dart';
import '../../module/domain/module_entity.dart';

class ModuleInstanceEntity {
  final int? id;
  final int moduleId;
  final int evaluationId;
  final ModuleStatus status;
  final ModuleEntity? module;

  const ModuleInstanceEntity({
    this.id,
    required this.moduleId,
    required this.evaluationId,
    this.status = ModuleStatus.pending,
    this.module,
  });

  ModuleInstanceEntity copyWith({
    int? id,
    int? moduleId,
    int? evaluationId,
    ModuleStatus? status,
    ModuleEntity? module,
  }) {
    return ModuleInstanceEntity(
      id: id ?? this.id,
      moduleId: moduleId ?? this.moduleId,
      evaluationId: evaluationId ?? this.evaluationId,
      status: status ?? this.status,
      module: module ?? this.module,
    );
  }

  @override
  String toString() =>
      'ModuleInstanceEntity(id: $id, moduleId: $moduleId, evaluationId: $evaluationId, status: $status)';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module_instance\domain\module_instance_repository.dart ===
import '../../../core/constants/enums/progress_status.dart';
import 'module_instance_entity.dart';

abstract class ModuleInstanceRepository {
  Future<ModuleInstanceEntity?> createModuleInstance(ModuleInstanceEntity instance);
  Future<ModuleInstanceEntity?> getModuleInstanceById(int id);
  Future<List<ModuleInstanceEntity>> getAllModuleInstances();
  Future<List<ModuleInstanceEntity>> getModuleInstancesByEvaluationId(int evaluationId);
  Future<int> updateModuleInstance(ModuleInstanceEntity instance);
  Future<int> deleteModuleInstance(int id);
  Future<int> getCount();
  Future<int> setModuleInstanceStatus(int instanceId, ModuleStatus status);
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\participant\data\participant_constants.dart ===
import '../../../core/constants/database_constants.dart';

class ParticipantFields {
  static const id = "participant_id";
  static const name = "name";
  static const surname = "surname";
  static const educationLevel = "education";
  static const sex = "sex";
  static const birthDate = "birth_date";

  static const all = [
    id,
    name,
    surname,
    educationLevel,
    sex,
    birthDate,
  ];
}

const scriptCreateTableParticipants = '''
CREATE TABLE ${Tables.participants} (
  ${ParticipantFields.id} INTEGER PRIMARY KEY AUTOINCREMENT,
  ${ParticipantFields.name} TEXT NOT NULL,
  ${ParticipantFields.surname} TEXT NOT NULL,
  ${ParticipantFields.educationLevel} INT CHECK(${ParticipantFields.educationLevel} BETWEEN 1 AND 7),
  ${ParticipantFields.sex} INT CHECK(${ParticipantFields.sex} IN (1, 2)),
  ${ParticipantFields.birthDate} TIMESTAMP
);
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\participant\data\participant_local_datasource.dart ===
import 'package:sqflite_common/sqlite_api.dart';
import '../../../core/constants/database_constants.dart';
import '../../../core/database_helper.dart';
import '../../../core/logger/app_logger.dart';
import '../domain/participant_entity.dart';

class ParticipantLocalDataSource {
  final dbHelper = DatabaseHelper.instance;
  Future<Database> get _db async => dbHelper.database;

  Future<int?> insertParticipant(DatabaseExecutor txn, Map<String, dynamic> data) async {
    AppLogger.db('Inserting participant: ${data['name']}');
    try {
      final id = await txn.insert(Tables.participants, data);
      AppLogger.db('Inserted participant with ID=$id');
      return id;
    } catch (e, s) {
      AppLogger.error('Error inserting participant', e, s);
      return null;
    }
  }

  Future<List<ParticipantEntity>> getAllParticipants() async {
    final db = await _db;
    final maps = await db.query(Tables.participants);
    return maps.map(ParticipantEntity.fromMap).toList();
  }

  Future<ParticipantEntity?> getById(int id) async {
    final db = await _db;
    final result = await db.query(Tables.participants,
        where: 'participant_id = ?', whereArgs: [id]);
    return result.isNotEmpty ? ParticipantEntity.fromMap(result.first) : null;
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\participant\domain\participant_entity.dart ===
import '../../../core/constants/enums/person_enums.dart';
import '../data/participant_constants.dart';

class ParticipantEntity {
  final int? participantID;
  final String name;
  final String surname;
  final DateTime birthDate;
  final Sex sex;
  final EducationLevel educationLevel;

  ParticipantEntity({
    this.participantID,
    required this.name,
    required this.surname,
    required this.birthDate,
    required this.sex,
    required this.educationLevel,
  });

  static ParticipantEntity fromMap(Map<String, dynamic> map) {
    return ParticipantEntity(
      participantID: map[ParticipantFields.id],
      name: map[ParticipantFields.name],
      surname: map[ParticipantFields.surname],
      birthDate: DateTime.parse(map[ParticipantFields.birthDate]),
      sex: Sex.fromValue(map[ParticipantFields.sex]),
      educationLevel: EducationLevel.fromValue(map[ParticipantFields.educationLevel]),
    );
  }

  Map<String, dynamic> toMap() => {
    ParticipantFields.id: participantID,
    ParticipantFields.name: name,
    ParticipantFields.surname: surname,
    ParticipantFields.birthDate: birthDate.toIso8601String(),
    ParticipantFields.sex: sex.numericValue,
    ParticipantFields.educationLevel: educationLevel.numericValue,
  };

  ParticipantEntity copyWith({
    int? participantID,
    String? name,
    String? surname,
    DateTime? birthDate,
    Sex? sex,
    EducationLevel? educationLevel,
  }) {
    return ParticipantEntity(
      participantID: participantID ?? this.participantID,
      name: name ?? this.name,
      surname: surname ?? this.surname,
      birthDate: birthDate ?? this.birthDate,
      sex: sex ?? this.sex,
      educationLevel: educationLevel ?? this.educationLevel,
    );
  }

  @override
  String toString() =>
      'ParticipantEntity(id: $participantID, name: $name, surname: $surname, sex: $sex, education: $educationLevel)';

  String get fullName => '$name $surname';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\participant\presentation\create_participant_evaluation_provider.dart ===
import 'dart:async';

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:sqflite_common_ffi/sqflite_ffi.dart';

import '../../../core/constants/enums/person_enums.dart';
import '../../../core/database_helper.dart';
import '../../../core/logger/app_logger.dart';
import '../../evaluation/data/evaluation_local_datasource.dart';
import '../../evaluation/domain/usecases/create_participant_evaluation_usecase.dart';
import '../../module/data/module_local_datasource.dart';
import '../../module_instance/data/module_instance_local_datasource.dart';
import '../../module_instance/data/module_instance_repository_impl.dart';
import '../../task/data/task_local_datasource.dart';
import '../../task_instance/data/task_instance_local_datasource.dart';
import '../../task_instance/data/task_instance_repository_impl.dart';
import '../data/participant_local_datasource.dart';
import '../domain/participant_entity.dart';

final createParticipantEvaluationProvider =
AsyncNotifierProvider<CreateParticipantEvaluationNotifier, ParticipantEntity?>(
  CreateParticipantEvaluationNotifier.new,
);

class CreateParticipantEvaluationNotifier extends AsyncNotifier<ParticipantEntity?> {
  late final CreateParticipantEvaluationUseCase _useCase;

  @override
  FutureOr<ParticipantEntity?> build() async {
    final Database db = await DatabaseHelper.instance.database;

    _useCase = CreateParticipantEvaluationUseCase(
      participantDataSource: ParticipantLocalDataSource(),
      evaluationDataSource: EvaluationLocalDataSource(),
      moduleDataSource: ModuleLocalDataSource(),
      moduleInstanceRepository:
      ModuleInstanceRepositoryImpl(localDataSource: ModuleInstanceLocalDataSource()),
      taskDataSource: TaskLocalDataSource(),
      taskInstanceRepository:
      TaskInstanceRepositoryImpl(localDataSource: TaskInstanceLocalDataSource()),
      db: db,
    );

    return null;
  }

  Future<void> createParticipantWithEvaluation({required int evaluatorId}) async {
    state = const AsyncLoading();
    AppLogger.info('[PROVIDER] Creating participant for evaluator=$evaluatorId');
    try {
      final participant = ParticipantEntity(
        name: 'Novo',
        surname: 'Participante',
        birthDate: DateTime(1990, 1, 1),
        sex: Sex.male,
        educationLevel: EducationLevel.completeCollege,
      );

      final created = await _useCase.execute(
        participant: participant,
        evaluatorId: evaluatorId,
      );

      AppLogger.info('[PROVIDER] ‚úÖ Participant + Evaluation created successfully');
      state = AsyncData(created);
    } catch (e, s) {
      AppLogger.error('[PROVIDER] ‚ùå Failed to create participant', e, s);
      state = AsyncError(e, s);
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\recording_file\data\recording_file_constants.dart ===
import '../../../core/constants/database_constants.dart';
import '../../task_instance/data/task_instance_constants.dart';

class RecordingFileFields {
  static const id = 'recording_id';
  static const taskInstanceId = TaskInstanceFields.id;
  static const filePath = 'file_path';

  static const values = [id, taskInstanceId, filePath];
}

final scriptCreateTableRecordings = '''
CREATE TABLE ${Tables.recordings} (
  ${RecordingFileFields.id} INTEGER PRIMARY KEY AUTOINCREMENT,
  ${RecordingFileFields.taskInstanceId} INTEGER UNIQUE NOT NULL,
  ${RecordingFileFields.filePath} TEXT NOT NULL,
  FOREIGN KEY (${RecordingFileFields.taskInstanceId}) 
    REFERENCES ${Tables.taskInstances}(${TaskInstanceFields.id})
)
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\recording_file\data\recording_file_local_datasource.dart ===
import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import '../../../core/constants/database_constants.dart';
import '../../../core/database_helper.dart';
import '../../recording_file/data/recording_file_constants.dart';
import '../../recording_file/data/recording_file_model.dart';
import '../../../core/logger/app_logger.dart';

class RecordingFileLocalDataSource {
  static final RecordingFileLocalDataSource _instance =
  RecordingFileLocalDataSource._internal();

  factory RecordingFileLocalDataSource() => _instance;

  RecordingFileLocalDataSource._internal();

  final dbHelper = DatabaseHelper.instance;

  Future<Database> get _db async => dbHelper.database;

  Future<int?> insert(RecordingFileModel model) async {
    try {
      final db = await _db;
      final id = await db.insert(
        Tables.recordings,
        model.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
      AppLogger.db('Inserted RecordingFile (id=$id)');
      return id;
    } catch (e, s) {
      AppLogger.error('Error inserting RecordingFile', e, s);
      return null;
    }
  }

  Future<RecordingFileModel?> getById(int id) async {
    try {
      final db = await _db;
      final result = await db.query(
        Tables.recordings,
        where: '${RecordingFileFields.id} = ?',
        whereArgs: [id],
      );
      return result.isNotEmpty ? RecordingFileModel.fromMap(result.first) : null;
    } catch (e, s) {
      AppLogger.error('Error fetching RecordingFile by ID: $id', e, s);
      return null;
    }
  }

  Future<RecordingFileModel?> getByTaskInstanceId(int taskInstanceId) async {
    try {
      final db = await _db;
      final result = await db.query(
        Tables.recordings,
        where: '${RecordingFileFields.taskInstanceId} = ?',
        whereArgs: [taskInstanceId],
      );
      return result.isNotEmpty ? RecordingFileModel.fromMap(result.first) : null;
    } catch (e, s) {
      AppLogger.error('Error fetching RecordingFile by TaskInstanceId: $taskInstanceId', e, s);
      return null;
    }
  }

  Future<List<RecordingFileModel>> getAll() async {
    try {
      final db = await _db;
      final result = await db.query(Tables.recordings);
      return result.map(RecordingFileModel.fromMap).toList();
    } catch (e, s) {
      AppLogger.error('Error fetching all RecordingFiles', e, s);
      return [];
    }
  }

  Future<int> update(RecordingFileModel model) async {
    try {
      final db = await _db;
      return await db.update(
        Tables.recordings,
        model.toMap(),
        where: '${RecordingFileFields.id} = ?',
        whereArgs: [model.id],
      );
    } catch (e, s) {
      AppLogger.error('Error updating RecordingFile ID=${model.id}', e, s);
      return -1;
    }
  }

  Future<int> delete(int id) async {
    try {
      final db = await _db;
      return await db.delete(
        Tables.recordings,
        where: '${RecordingFileFields.id} = ?',
        whereArgs: [id],
      );
    } catch (e, s) {
      AppLogger.error('Error deleting RecordingFile ID=$id', e, s);
      return -1;
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\recording_file\data\recording_file_model.dart ===
import '../../recording_file/domain/recording_file_entity.dart';
import '../../recording_file/data/recording_file_constants.dart';

class RecordingFileModel extends RecordingFileEntity {
  const RecordingFileModel({
    super.id,
    required super.taskInstanceId,
    required super.filePath,
  });

  factory RecordingFileModel.fromMap(Map<String, dynamic> map) {
    return RecordingFileModel(
      id: map[RecordingFileFields.id] as int?,
      taskInstanceId: map[RecordingFileFields.taskInstanceId] as int,
      filePath: map[RecordingFileFields.filePath] as String,
    );
  }

  Map<String, dynamic> toMap() => {
    RecordingFileFields.id: id,
    RecordingFileFields.taskInstanceId: taskInstanceId,
    RecordingFileFields.filePath: filePath,
  };

  factory RecordingFileModel.fromEntity(RecordingFileEntity entity) =>
      RecordingFileModel(
        id: entity.id,
        taskInstanceId: entity.taskInstanceId,
        filePath: entity.filePath,
      );

  RecordingFileEntity toEntity() => RecordingFileEntity(
    id: id,
    taskInstanceId: taskInstanceId,
    filePath: filePath,
  );
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\recording_file\data\recording_file_repository_impl.dart ===
import '../../recording_file/domain/recording_file_entity.dart';
import '../../recording_file/domain/recording_file_repository.dart';
import '../../recording_file/data/recording_file_model.dart';
import '../../recording_file/data/recording_file_local_datasource.dart';

class RecordingFileRepositoryImpl implements RecordingFileRepository {
  final RecordingFileLocalDataSource localDataSource;

  RecordingFileRepositoryImpl({required this.localDataSource});

  @override
  Future<int?> insert(RecordingFileEntity entity) async {
    final model = RecordingFileModel.fromEntity(entity);
    return await localDataSource.insert(model);
  }

  @override
  Future<RecordingFileEntity?> getById(int id) async {
    final model = await localDataSource.getById(id);
    return model?.toEntity();
  }

  @override
  Future<RecordingFileEntity?> getByTaskInstanceId(int taskInstanceId) async {
    final model = await localDataSource.getByTaskInstanceId(taskInstanceId);
    return model?.toEntity();
  }

  @override
  Future<List<RecordingFileEntity>> getAll() async {
    final models = await localDataSource.getAll();
    return models.map((m) => m.toEntity()).toList();
  }

  @override
  Future<int> update(RecordingFileEntity entity) async {
    final model = RecordingFileModel.fromEntity(entity);
    return await localDataSource.update(model);
  }

  @override
  Future<int> delete(int id) async {
    return await localDataSource.delete(id);
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\recording_file\domain\recording_file_entity.dart ===
class RecordingFileEntity {
  final int? id;
  final int taskInstanceId;
  final String filePath;

  const RecordingFileEntity({
    this.id,
    required this.taskInstanceId,
    required this.filePath,
  });

  RecordingFileEntity copyWith({
    int? id,
    int? taskInstanceId,
    String? filePath,
  }) {
    return RecordingFileEntity(
      id: id ?? this.id,
      taskInstanceId: taskInstanceId ?? this.taskInstanceId,
      filePath: filePath ?? this.filePath,
    );
  }

  @override
  String toString() =>
      'RecordingFileEntity(id: $id, taskInstanceId: $taskInstanceId, filePath: $filePath)';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\recording_file\domain\recording_file_repository.dart ===
import 'recording_file_entity.dart';

abstract class RecordingFileRepository {
  Future<int?> insert(RecordingFileEntity entity);
  Future<RecordingFileEntity?> getById(int id);
  Future<RecordingFileEntity?> getByTaskInstanceId(int taskInstanceId);
  Future<List<RecordingFileEntity>> getAll();
  Future<int> update(RecordingFileEntity entity);
  Future<int> delete(int id);
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\splash\splash_screen.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

import '../../core/logger/app_logger.dart';
import '../../core/database_helper.dart';
import '../../features/evaluator/data/evaluator_local_datasource.dart';
import '../../features/evaluator/data/evaluator_model.dart';
import '../../seeders/seed_runner.dart';

class SplashScreen extends HookConsumerWidget {
  const SplashScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Initialize app safely after the first frame
    Future.microtask(() => _initializeApp(context));

    return NavigationView(
      content: ScaffoldPage(
        content: Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: const [
              ProgressRing(),
              SizedBox(height: 16),
              Text(
                'Inicializando o aplicativo...',
                style: TextStyle(fontSize: 16),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Future<void> _initializeApp(BuildContext context) async {
    try {
      AppLogger.seed('[SPLASH] Starting database seeding...');
      await SeedRunner().run();

      final db = await DatabaseHelper.instance.database;
      final ds = EvaluatorLocalDataSource(db);

      final EvaluatorModel? evaluator = await ds.getFirstEvaluator();

      if (evaluator != null) {
        AppLogger.seed('[SPLASH] Found evaluator: ${evaluator.email}');
        await Future.delayed(const Duration(milliseconds: 800));
        if (context.mounted) context.go('/login');
      } else {
        AppLogger.seed('[SPLASH] No evaluator found ‚Äî going to registration.');
        context.go('/register');
      }
    } catch (e, s) {
      AppLogger.error('[SPLASH] Error during initialization', e, s);
      if (context.mounted) {
        _showErrorDialog(context, e.toString());
      }
    }
  }

  void _showErrorDialog(BuildContext context, String message) {
    showDialog(
      context: context,
      builder: (_) => ContentDialog(
        title: const Text('Erro ao iniciar'),
        content: Text(message),
        actions: [
          Button(
            child: const Text('Fechar'),
            onPressed: () => Navigator.pop(context),
          ),
        ],
      ),
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task\data\task_constants.dart ===
import '../../../core/constants/database_constants.dart';

class TaskFields {
  static const id = 'task_id';
  static const moduleId = 'module_id';
  static const title = 'title';
  static const transcript = 'transcript';
  static const mode = 'mode';
  static const position = 'position';
  static const imagePath = 'image_path';
  static const timeForCompletion = 'time_for_completion';
  static const mayRepeatPrompt = 'may_repeat_prompt';
  static const testOnly = 'test_only';

  static const values = [
    id,
    moduleId,
    title,
    transcript,
    mode,
    position,
    imagePath,
    timeForCompletion,
    mayRepeatPrompt,
    testOnly,
  ];
}

const scriptCreateTableTasks = '''
CREATE TABLE ${Tables.tasks} (
  ${TaskFields.id} INTEGER PRIMARY KEY AUTOINCREMENT,
  ${TaskFields.moduleId} INTEGER NOT NULL,
  ${TaskFields.title} TEXT NOT NULL,
  ${TaskFields.transcript} TEXT,
  ${TaskFields.mode} INTEGER NOT NULL,
  ${TaskFields.position} INTEGER NOT NULL,
  ${TaskFields.imagePath} TEXT NOT NULL,
  ${TaskFields.mayRepeatPrompt} INTEGER NOT NULL,
  ${TaskFields.testOnly} INTEGER NOT NULL,
  ${TaskFields.timeForCompletion} INTEGER NOT NULL,
  FOREIGN KEY (${TaskFields.moduleId}) REFERENCES ${Tables.modules}(${TaskFields.id}),
  CHECK(${TaskFields.mode} >= 0 AND ${TaskFields.mode} <= 1),
  CHECK(${TaskFields.mayRepeatPrompt} >= 0 AND ${TaskFields.mayRepeatPrompt} <= 1)
)
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task\data\task_local_datasource.dart ===
import 'package:sqflite_common/sqlite_api.dart';
import '../../../core/database_helper.dart';
import '../../../core/logger/app_logger.dart';
import '../../../core/constants/database_constants.dart';
import 'task_constants.dart';
import 'task_model.dart';

class TaskLocalDataSource {
  final dbHelper = DatabaseHelper.instance;
  Future<Database> get _db async => dbHelper.database;

  Future<int?> insertTask(TaskModel task) async {
    AppLogger.db('Inserting task: ${task.title}');
    try {
      final db = await _db;
      final id = await db.insert(
        Tables.tasks,
        task.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
      AppLogger.db('Task inserted successfully (id=$id)');
      return id;
    } catch (e, s) {
      AppLogger.error('Error inserting task: ${task.title}', e, s);
      return null;
    }
  }

  Future<TaskModel?> getTaskById(int id) async {
    AppLogger.db('Fetching task by ID=$id');
    try {
      final db = await _db;
      final result = await db.query(
        Tables.tasks,
        where: '${TaskFields.id} = ?',
        whereArgs: [id],
      );
      if (result.isNotEmpty) {
        AppLogger.db('Task found (ID=$id)');
        return TaskModel.fromMap(result.first);
      }
      AppLogger.db('No task found (ID=$id)');
      return null;
    } catch (e, s) {
      AppLogger.error('Error fetching task by ID=$id', e, s);
      return null;
    }
  }

  Future<List<TaskModel>> getAllTasks() async {
    AppLogger.db('Fetching all tasks');
    try {
      final db = await _db;
      final maps = await db.query(Tables.tasks);
      AppLogger.db('Fetched ${maps.length} tasks');
      return maps.map(TaskModel.fromMap).toList();
    } catch (e, s) {
      AppLogger.error('Error fetching all tasks', e, s);
      return [];
    }
  }

  Future<List<TaskModel>> getTasksByModuleId(int moduleId) async {
    AppLogger.db('Fetching tasks for moduleId=$moduleId');
    try {
      final db = await _db;
      final maps = await db.query(
        Tables.tasks,
        where: '${TaskFields.moduleId} = ?',
        whereArgs: [moduleId],
      );
      AppLogger.db('Fetched ${maps.length} tasks for moduleId=$moduleId');
      return maps.map(TaskModel.fromMap).toList();
    } catch (e, s) {
      AppLogger.error('Error fetching tasks for moduleId=$moduleId', e, s);
      return [];
    }
  }

  Future<int> updateTask(TaskModel task) async {
    AppLogger.db('Updating task ID=${task.taskID}');
    try {
      final db = await _db;
      final rows = await db.update(
        Tables.tasks,
        task.toMap(),
        where: '${TaskFields.id} = ?',
        whereArgs: [task.taskID],
      );
      AppLogger.db('Updated $rows task(s) for ID=${task.taskID}');
      return rows;
    } catch (e, s) {
      AppLogger.error('Error updating task ID=${task.taskID}', e, s);
      return 0;
    }
  }

  Future<int> deleteTask(int id) async {
    AppLogger.db('Deleting task ID=$id');
    try {
      final db = await _db;
      final count = await db.delete(
        Tables.tasks,
        where: '${TaskFields.id} = ?',
        whereArgs: [id],
      );
      AppLogger.db('Deleted $count task(s)');
      return count;
    } catch (e, s) {
      AppLogger.error('Error deleting task ID=$id', e, s);
      return 0;
    }
  }

  Future<bool> exists(String taskId) async {
    final db = await _db;
    final result = await db.query(
      Tables.tasks,
      where: '${TaskFields.id} = ?',
      whereArgs: [taskId],
      limit: 1,
    );
    return result.isNotEmpty;
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task\data\task_model.dart ===
import '../../../core/constants/enums/task_mode.dart';
import '../../task/domain/task_entity.dart';
import '../../task/data/task_constants.dart';

class TaskModel extends TaskEntity {
  const TaskModel({
    super.taskID,
    required super.moduleID,
    required super.title,
    required super.taskMode,
    required super.position,
    super.imagePath = 'no_image',
    super.timeForCompletion = 60,
    super.mayRepeatPrompt = true,
    super.testOnly = false,
    super.transcript,
  });

  factory TaskModel.fromMap(Map<String, dynamic> map) {
    return TaskModel(
      taskID: map[TaskFields.id] as int?,
      moduleID: map[TaskFields.moduleId] as int,
      title: map[TaskFields.title] as String,
      transcript: map[TaskFields.transcript] as String?,
      taskMode: TaskMode.fromValue(map[TaskFields.mode] as int),
      position: map[TaskFields.position] as int,
      imagePath: map[TaskFields.imagePath] as String? ?? 'no_image',
      timeForCompletion: map[TaskFields.timeForCompletion] as int? ?? 60,
      mayRepeatPrompt: (map[TaskFields.mayRepeatPrompt] as int) == 1,
      testOnly: (map[TaskFields.testOnly] as int) == 1,
    );
  }

  Map<String, dynamic> toMap() => {
    TaskFields.id: taskID,
    TaskFields.moduleId: moduleID,
    TaskFields.title: title,
    TaskFields.transcript: transcript,
    TaskFields.mode: taskMode.numericValue,
    TaskFields.position: position,
    TaskFields.imagePath: imagePath,
    TaskFields.timeForCompletion: timeForCompletion,
    TaskFields.mayRepeatPrompt: mayRepeatPrompt ? 1 : 0,
    TaskFields.testOnly: testOnly ? 1 : 0,
  };

  factory TaskModel.fromEntity(TaskEntity entity) => TaskModel(
    taskID: entity.taskID,
    moduleID: entity.moduleID,
    title: entity.title,
    transcript: entity.transcript,
    taskMode: entity.taskMode,
    position: entity.position,
    imagePath: entity.imagePath,
    timeForCompletion: entity.timeForCompletion,
    mayRepeatPrompt: entity.mayRepeatPrompt,
    testOnly: entity.testOnly,
  );

  TaskEntity toEntity() => TaskEntity(
    taskID: taskID,
    moduleID: moduleID,
    title: title,
    transcript: transcript,
    taskMode: taskMode,
    position: position,
    imagePath: imagePath,
    timeForCompletion: timeForCompletion,
    mayRepeatPrompt: mayRepeatPrompt,
    testOnly: testOnly,
  );
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task\data\task_repository_impl.dart ===
import '../domain/task_repository.dart';
import '../domain/task_entity.dart';
import 'task_local_datasource.dart';
import 'task_model.dart';

class TaskRepositoryImpl implements TaskRepository {
  final TaskLocalDataSource localDataSource;

  TaskRepositoryImpl({required this.localDataSource});

  @override
  Future<int?> insertTask(TaskEntity task) async {
    final model = TaskModel.fromEntity(task);
    return await localDataSource.insertTask(model);
  }

  @override
  Future<TaskEntity?> getTaskById(int id) async {
    final model = await localDataSource.getTaskById(id);
    return model?.toEntity();
  }

  @override
  Future<List<TaskEntity>> getAllTasks() async {
    final models = await localDataSource.getAllTasks();
    return models.map((m) => m.toEntity()).toList();
  }

  @override
  Future<List<TaskEntity>> getTasksByModuleId(int moduleId) async {
    final models = await localDataSource.getTasksByModuleId(moduleId);
    return models.map((m) => m.toEntity()).toList();
  }

  @override
  Future<int> updateTask(TaskEntity task) async {
    final model = TaskModel.fromEntity(task);
    return await localDataSource.updateTask(model);
  }

  @override
  Future<int> deleteTask(int id) async {
    return await localDataSource.deleteTask(id);
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task\domain\task_entity.dart ===
import '../../../core/constants/enums/task_mode.dart';
import '../data/task_constants.dart';

class TaskEntity {
  final int? taskID;
  final int moduleID;
  final String title;
  final String? transcript;
  final TaskMode taskMode;
  final int position;
  final String imagePath;
  final int timeForCompletion;
  final bool mayRepeatPrompt;
  final bool testOnly;

  const TaskEntity({
    this.taskID,
    required this.moduleID,
    required this.title,
    required this.taskMode,
    required this.position,
    this.imagePath = 'no_image',
    this.timeForCompletion = 60,
    this.mayRepeatPrompt = true,
    this.testOnly = false,
    this.transcript,
  });

  Map<String, dynamic> toMap() => {
    TaskFields.id: taskID,
    TaskFields.moduleId: moduleID,
    TaskFields.title: title,
    TaskFields.transcript: transcript,
    TaskFields.mode: taskMode.index,
    TaskFields.position: position,
    TaskFields.imagePath: imagePath,
    TaskFields.timeForCompletion: timeForCompletion,
    TaskFields.mayRepeatPrompt: mayRepeatPrompt ? 1 : 0,
    TaskFields.testOnly: testOnly ? 1 : 0,
  };

  factory TaskEntity.fromMap(Map<String, dynamic> map) => TaskEntity(
    taskID: map[TaskFields.id] as int?,
    moduleID: map[TaskFields.moduleId] as int,
    title: map[TaskFields.title] as String,
    transcript: map[TaskFields.transcript] as String?,
    taskMode: TaskMode.values[map[TaskFields.mode] as int],
    position: map[TaskFields.position] as int,
    imagePath: map[TaskFields.imagePath] as String,
    timeForCompletion: map[TaskFields.timeForCompletion] as int,
    mayRepeatPrompt: (map[TaskFields.mayRepeatPrompt] as int) == 1,
    testOnly: (map[TaskFields.testOnly] as int) == 1,
  );

  TaskEntity copyWith({
    int? taskID,
    int? moduleID,
    String? title,
    String? transcript,
    TaskMode? taskMode,
    int? position,
    String? imagePath,
    int? timeForCompletion,
    bool? mayRepeatPrompt,
    bool? testOnly,
  }) {
    return TaskEntity(
      taskID: taskID ?? this.taskID,
      moduleID: moduleID ?? this.moduleID,
      title: title ?? this.title,
      transcript: transcript ?? this.transcript,
      taskMode: taskMode ?? this.taskMode,
      position: position ?? this.position,
      imagePath: imagePath ?? this.imagePath,
      timeForCompletion: timeForCompletion ?? this.timeForCompletion,
      mayRepeatPrompt: mayRepeatPrompt ?? this.mayRepeatPrompt,
      testOnly: testOnly ?? this.testOnly,
    );
  }

  @override
  String toString() =>
      'TaskEntity(id: $taskID, title: $title, mode: $taskMode, moduleId: $moduleID, pos: $position)';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task\domain\task_repository.dart ===
import 'task_entity.dart';

abstract class TaskRepository {
  Future<int?> insertTask(TaskEntity task);
  Future<TaskEntity?> getTaskById(int id);
  Future<List<TaskEntity>> getAllTasks();
  Future<List<TaskEntity>> getTasksByModuleId(int moduleId);
  Future<int> updateTask(TaskEntity task);
  Future<int> deleteTask(int id);
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_instance\data\task_instance_constants.dart ===
import '../../../core/constants/database_constants.dart';
import '../../module_instance/data/module_instance_constants.dart';
import '../../task/data/task_constants.dart';

class TaskInstanceFields {
  static const id = 'task_inst_id';
  static const taskId = TaskFields.id;
  static const moduleInstanceId = ModuleInstanceFields.id;
  static const status = 'status';
  static const completingTime = 'task_completing_time';

  static const values = [id, taskId, moduleInstanceId, status, completingTime];
}

final scriptCreateTableTaskInstances = '''
CREATE TABLE ${Tables.taskInstances} (
  ${TaskInstanceFields.id} INTEGER PRIMARY KEY AUTOINCREMENT,
  ${TaskInstanceFields.taskId} INTEGER NOT NULL,
  ${TaskInstanceFields.moduleInstanceId} INTEGER NOT NULL,
  ${TaskInstanceFields.status} INT NOT NULL CHECK(${TaskInstanceFields.status} IN (0, 1)),
  ${TaskInstanceFields.completingTime} TEXT,
  FOREIGN KEY (${TaskInstanceFields.taskId}) REFERENCES ${Tables.tasks}(${TaskFields.id}),
  FOREIGN KEY (${TaskInstanceFields.moduleInstanceId}) REFERENCES ${Tables.moduleInstances}(${ModuleInstanceFields.id})
)
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_instance\data\task_instance_local_datasource.dart ===
import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import '../../../core/database_helper.dart';
import '../../../core/logger/app_logger.dart';
import '../../../core/constants/database_constants.dart';
import '../../task/data/task_constants.dart';
import '../../task_instance/data/task_instance_constants.dart';
import '../../task_instance/data/task_instance_model.dart';
import '../../../core/constants/enums/progress_status.dart';

class TaskInstanceLocalDataSource {
  static final TaskInstanceLocalDataSource _instance =
  TaskInstanceLocalDataSource._internal();

  factory TaskInstanceLocalDataSource() => _instance;

  TaskInstanceLocalDataSource._internal();

  final dbHelper = DatabaseHelper.instance;
  Future<Database> get _db async => dbHelper.database;

  Future<int?> create(TaskInstanceModel model) async {
    AppLogger.db('Creating task instance for taskId=${model.taskId}');
    try {
      final db = await _db;
      final id = await db.insert(
        Tables.taskInstances,
        model.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
      AppLogger.db('Task instance created successfully (id=$id)');
      return id;
    } catch (e, s) {
      AppLogger.error('Error creating task instance', e, s);
      return null;
    }
  }

  Future<TaskInstanceModel?> getTaskInstance(int id) async {
    AppLogger.db('Fetching task instance ID=$id');
    try {
      final db = await _db;
      final maps = await db.query(
        Tables.taskInstances,
        where: '${TaskInstanceFields.id} = ?',
        whereArgs: [id],
      );
      if (maps.isNotEmpty) {
        AppLogger.db('Task instance found (ID=$id)');
        return TaskInstanceModel.fromMap(maps.first);
      }
      AppLogger.db('No task instance found (ID=$id)');
      return null;
    } catch (e, s) {
      AppLogger.error('Error fetching task instance ID=$id', e, s);
      return null;
    }
  }

  Future<int> updateTaskInstance(TaskInstanceModel model) async {
    AppLogger.db('Updating task instance ID=${model.id}');
    try {
      final db = await _db;
      final rows = await db.update(
        Tables.taskInstances,
        model.toMap(),
        where: '${TaskInstanceFields.id} = ?',
        whereArgs: [model.id],
      );
      AppLogger.db('Updated $rows task instance(s)');
      return rows;
    } catch (e, s) {
      AppLogger.error('Error updating task instance ID=${model.id}', e, s);
      return 0;
    }
  }

  Future<int> deleteTaskInstance(int id) async {
    AppLogger.db('Deleting task instance ID=$id');
    try {
      final db = await _db;
      final count = await db.delete(
        Tables.taskInstances,
        where: '${TaskInstanceFields.id} = ?',
        whereArgs: [id],
      );
      AppLogger.db('Deleted $count task instance(s)');
      return count;
    } catch (e, s) {
      AppLogger.error('Error deleting task instance ID=$id', e, s);
      return 0;
    }
  }

  Future<List<TaskInstanceModel>> getAllTaskInstances() async {
    AppLogger.db('Fetching all task instances');
    try {
      final db = await _db;
      final maps = await db.query(Tables.taskInstances);
      AppLogger.db('Fetched ${maps.length} task instances');
      return maps.map(TaskInstanceModel.fromMap).toList();
    } catch (e, s) {
      AppLogger.error('Error fetching all task instances', e, s);
      return [];
    }
  }

  Future<List<TaskInstanceModel>> getTaskInstancesForModuleInstance(int moduleInstanceId) async {
    AppLogger.db('Fetching task instances for moduleInstanceId=$moduleInstanceId');
    try {
      final db = await _db;
      final maps = await db.query(
        Tables.taskInstances,
        where: '${TaskInstanceFields.moduleInstanceId} = ?',
        whereArgs: [moduleInstanceId],
      );
      AppLogger.db('Fetched ${maps.length} task instances for moduleInstanceId=$moduleInstanceId');
      return maps.map(TaskInstanceModel.fromMap).toList();
    } catch (e, s) {
      AppLogger.error('Error fetching task instances for moduleInstanceId=$moduleInstanceId', e, s);
      return [];
    }
  }

  Future<int?> getNumberOfTaskInstances() async {
    AppLogger.db('Counting task instances');
    try {
      final db = await _db;
      final result = await db.rawQuery('SELECT COUNT(*) as count FROM ${Tables.taskInstances}');
      final count = result.first['count'] as int?;
      AppLogger.db('Task instance count: $count');
      return count;
    } catch (e, s) {
      AppLogger.error('Error counting task instances', e, s);
      return null;
    }
  }

  Future<TaskInstanceModel?> getFirstPendingTaskInstance() async {
    AppLogger.db('Fetching first pending task instance');
    try {
      final db = await _db;
      final result = await db.rawQuery('''
        SELECT ti.* FROM ${Tables.taskInstances} ti
        INNER JOIN ${Tables.tasks} t ON ti.${TaskInstanceFields.taskId} = t.${TaskFields.id}
        WHERE ti.${TaskInstanceFields.status} = 0
        ORDER BY t.${TaskFields.position} ASC
        LIMIT 1
      ''');
      if (result.isNotEmpty) {
        AppLogger.db('Found pending task instance ID=${result.first[TaskInstanceFields.id]}');
        return TaskInstanceModel.fromMap(result.first);
      }
      AppLogger.db('No pending task instance found');
      return null;
    } catch (e, s) {
      AppLogger.error('Error fetching first pending task instance', e, s);
      return null;
    }
  }

  Future<int> markAsCompleted(int id, {String? duration}) async {
    AppLogger.db('Marking task instance ID=$id as completed');
    try {
      final db = await _db;
      final map = {
        TaskInstanceFields.status: TaskStatus.completed.numericValue,
        if (duration != null) TaskInstanceFields.completingTime: duration,
      };
      final rows = await db.update(
        Tables.taskInstances,
        map,
        where: '${TaskInstanceFields.id} = ?',
        whereArgs: [id],
      );
      AppLogger.db('Task instance ID=$id marked as completed ($rows row(s) affected)');
      return rows;
    } catch (e, s) {
      AppLogger.error('Error marking task instance ID=$id as completed', e, s);
      return 0;
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_instance\data\task_instance_model.dart ===
import '../../task_instance/domain/task_instance_entity.dart';
import '../../task_instance/data/task_instance_constants.dart';
import '../../../core/constants/enums/progress_status.dart';

class TaskInstanceModel extends TaskInstanceEntity {
  const TaskInstanceModel({
    super.id,
    required super.taskId,
    required super.moduleInstanceId,
    required super.status,
    super.completingTime,
    super.task,
  });

  factory TaskInstanceModel.fromMap(Map<String, dynamic> map) {
    return TaskInstanceModel(
      id: map[TaskInstanceFields.id] as int?,
      taskId: map[TaskInstanceFields.taskId] as int,
      moduleInstanceId: map[TaskInstanceFields.moduleInstanceId] as int,
      status: TaskStatus.fromValue(map[TaskInstanceFields.status] as int),
      completingTime: map[TaskInstanceFields.completingTime] as String?,
    );
  }

  Map<String, dynamic> toMap() => {
    TaskInstanceFields.id: id,
    TaskInstanceFields.taskId: taskId,
    TaskInstanceFields.moduleInstanceId: moduleInstanceId,
    TaskInstanceFields.status: status.numericValue,
    TaskInstanceFields.completingTime: completingTime,
  };

  factory TaskInstanceModel.fromEntity(TaskInstanceEntity entity) {
    return TaskInstanceModel(
      id: entity.id,
      taskId: entity.taskId,
      moduleInstanceId: entity.moduleInstanceId,
      status: entity.status,
      completingTime: entity.completingTime,
      task: entity.task,
    );
  }

  TaskInstanceEntity toEntity() {
    return TaskInstanceEntity(
      id: id,
      taskId: taskId,
      moduleInstanceId: moduleInstanceId,
      status: status,
      completingTime: completingTime,
      task: task,
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_instance\data\task_instance_repository_impl.dart ===
import '../../task_instance/domain/task_instance_entity.dart';
import '../../task_instance/domain/task_instance_repository.dart';
import 'task_instance_local_datasource.dart';
import 'task_instance_model.dart';

class TaskInstanceRepositoryImpl implements TaskInstanceRepository {
  final TaskInstanceLocalDataSource localDataSource;

  TaskInstanceRepositoryImpl({required this.localDataSource});

  @override
  Future<int?> insert(TaskInstanceEntity entity) async {
    final model = TaskInstanceModel.fromEntity(entity);
    return await localDataSource.create(model);
  }

  @override
  Future<TaskInstanceEntity?> getById(int id) async {
    final model = await localDataSource.getTaskInstance(id);
    return model?.toEntity();
  }

  @override
  Future<List<TaskInstanceEntity>> getAll() async {
    final models = await localDataSource.getAllTaskInstances();
    return models.map((m) => m.toEntity()).toList();
  }

  @override
  Future<int> update(TaskInstanceEntity entity) async {
    final model = TaskInstanceModel.fromEntity(entity);
    return await localDataSource.updateTaskInstance(model);
  }

  @override
  Future<int> delete(int id) async {
    return await localDataSource.deleteTaskInstance(id);
  }

  @override
  Future<List<TaskInstanceEntity>> getByModuleInstance(int moduleInstanceId) async {
    final models = await localDataSource.getTaskInstancesForModuleInstance(moduleInstanceId);
    return models.map((m) => m.toEntity()).toList();
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_instance\domain\task_instance_entity.dart ===
import '../../task/domain/task_entity.dart';
import '../../../core/constants/enums/progress_status.dart';

class TaskInstanceEntity {
  final int? id;
  final int taskId;
  final int moduleInstanceId;
  final TaskStatus status;
  final String? completingTime;
  final TaskEntity? task;

  const TaskInstanceEntity({
    this.id,
    required this.taskId,
    required this.moduleInstanceId,
    this.status = TaskStatus.pending,
    this.completingTime,
    this.task,
  });

  TaskInstanceEntity copyWith({
    int? id,
    int? taskId,
    int? moduleInstanceId,
    TaskStatus? status,
    String? completingTime,
    TaskEntity? task,
  }) {
    return TaskInstanceEntity(
      id: id ?? this.id,
      taskId: taskId ?? this.taskId,
      moduleInstanceId: moduleInstanceId ?? this.moduleInstanceId,
      status: status ?? this.status,
      completingTime: completingTime ?? this.completingTime,
      task: task ?? this.task,
    );
  }

  @override
  String toString() =>
      'TaskInstanceEntity(id: $id, taskId: $taskId, moduleInstanceId: $moduleInstanceId, status: $status, completingTime: $completingTime)';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_instance\domain\task_instance_repository.dart ===
import 'task_instance_entity.dart';

abstract class TaskInstanceRepository {
  Future<int?> insert(TaskInstanceEntity entity);
  Future<TaskInstanceEntity?> getById(int id);
  Future<List<TaskInstanceEntity>> getAll();
  Future<int> update(TaskInstanceEntity entity);
  Future<int> delete(int id);
  Future<List<TaskInstanceEntity>> getByModuleInstance(int moduleInstanceId);
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_prompt\data\task_prompt_constants.dart ===
import '../../../core/constants/database_constants.dart';
import '../../task/data/task_constants.dart';

class TaskPromptFields {
  static const promptID = 'prompt_id';
  static const taskID = TaskFields.id;
  static const filePath = 'file_path';
  static const transcription = 'transcription';

  static const values = [promptID, taskID, filePath, transcription];
}

final scriptCreateTableTaskPrompts = '''
CREATE TABLE ${Tables.taskPrompts} (
  ${TaskPromptFields.promptID} INTEGER PRIMARY KEY AUTOINCREMENT,
  ${TaskPromptFields.taskID} INTEGER UNIQUE NOT NULL,
  ${TaskPromptFields.filePath} TEXT NOT NULL,
  ${TaskPromptFields.transcription} TEXT,
  FOREIGN KEY (${TaskPromptFields.taskID}) REFERENCES ${Tables.tasks}(${TaskFields.id})
)
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_prompt\data\task_prompt_local_datasource.dart ===
import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import '../../../core/database_helper.dart';
import '../../../core/logger/app_logger.dart';
import '../../../core/constants/database_constants.dart';
import '../../task_prompt/data/task_prompt_constants.dart';
import '../../task_prompt/data/task_prompt_model.dart';

class TaskPromptLocalDataSource {
  static final TaskPromptLocalDataSource _instance =
  TaskPromptLocalDataSource._internal();

  factory TaskPromptLocalDataSource() => _instance;

  TaskPromptLocalDataSource._internal();

  final dbHelper = DatabaseHelper.instance;
  Future<Database> get _db async => dbHelper.database;

  Future<int?> insert(TaskPromptModel model) async {
    AppLogger.db('Inserting TaskPrompt for taskId=${model.taskID}');
    try {
      final db = await _db;
      final id = await db.insert(
        Tables.taskPrompts,
        model.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
      AppLogger.db('TaskPrompt inserted (id=$id)');
      return id;
    } catch (e, s) {
      AppLogger.error('Error inserting TaskPrompt', e, s);
      return null;
    }
  }

  Future<TaskPromptModel?> getById(int id) async {
    AppLogger.db('Fetching TaskPrompt by ID=$id');
    try {
      final db = await _db;
      final result = await db.query(
        Tables.taskPrompts,
        where: '${TaskPromptFields.promptID} = ?',
        whereArgs: [id],
      );
      return result.isNotEmpty ? TaskPromptModel.fromMap(result.first) : null;
    } catch (e, s) {
      AppLogger.error('Error fetching TaskPrompt by ID=$id', e, s);
      return null;
    }
  }

  Future<TaskPromptModel?> getByTaskId(int taskId) async {
    AppLogger.db('Fetching TaskPrompt by taskId=$taskId');
    try {
      final db = await _db;
      final result = await db.query(
        Tables.taskPrompts,
        where: '${TaskPromptFields.taskID} = ?',
        whereArgs: [taskId],
      );
      return result.isNotEmpty ? TaskPromptModel.fromMap(result.first) : null;
    } catch (e, s) {
      AppLogger.error('Error fetching TaskPrompt by taskId=$taskId', e, s);
      return null;
    }
  }

  Future<List<TaskPromptModel>> getAll() async {
    AppLogger.db('Fetching all TaskPrompts');
    try {
      final db = await _db;
      final result = await db.query(Tables.taskPrompts);
      AppLogger.db('Fetched ${result.length} TaskPrompts');
      return result.map(TaskPromptModel.fromMap).toList();
    } catch (e, s) {
      AppLogger.error('Error fetching all TaskPrompts', e, s);
      return [];
    }
  }

  Future<int> update(TaskPromptModel model) async {
    AppLogger.db('Updating TaskPrompt ID=${model.promptID}');
    try {
      final db = await _db;
      final rows = await db.update(
        Tables.taskPrompts,
        model.toMap(),
        where: '${TaskPromptFields.promptID} = ?',
        whereArgs: [model.promptID],
      );
      AppLogger.db('Updated $rows TaskPrompt(s)');
      return rows;
    } catch (e, s) {
      AppLogger.error('Error updating TaskPrompt ID=${model.promptID}', e, s);
      return 0;
    }
  }

  Future<int> delete(int id) async {
    AppLogger.db('Deleting TaskPrompt ID=$id');
    try {
      final db = await _db;
      final count = await db.delete(
        Tables.taskPrompts,
        where: '${TaskPromptFields.promptID} = ?',
        whereArgs: [id],
      );
      AppLogger.db('Deleted $count TaskPrompt(s)');
      return count;
    } catch (e, s) {
      AppLogger.error('Error deleting TaskPrompt ID=$id', e, s);
      return 0;
    }
  }

  Future<bool> exists(String promptId) async {
    final db = await _db;
    final result = await db.query(
      Tables.taskPrompts,
      where: '${TaskPromptFields.promptID} = ?',
      whereArgs: [promptId],
      limit: 1,
    );
    return result.isNotEmpty;
  }

}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_prompt\data\task_prompt_model.dart ===
import '../../task_prompt/domain/task_prompt_entity.dart';
import 'task_prompt_constants.dart';

class TaskPromptModel extends TaskPromptEntity {
  const TaskPromptModel({
    super.promptID,
    required super.taskID,
    required super.filePath,
    super.transcription,
  });

  factory TaskPromptModel.fromMap(Map<String, dynamic> map) {
    return TaskPromptModel(
      promptID: map[TaskPromptFields.promptID] as int?,
      taskID: map[TaskPromptFields.taskID] as int, //
      filePath: map[TaskPromptFields.filePath] as String,
      transcription: map[TaskPromptFields.transcription] as String?,
    );
  }

  Map<String, dynamic> toMap() => {
    TaskPromptFields.promptID: promptID,
    TaskPromptFields.taskID: taskID,
    TaskPromptFields.filePath: filePath,
    TaskPromptFields.transcription: transcription,
  };

  factory TaskPromptModel.fromEntity(TaskPromptEntity entity) =>
      TaskPromptModel(
        promptID: entity.promptID,
        taskID: entity.taskID,
        filePath: entity.filePath,
        transcription: entity.transcription,
      );

  TaskPromptEntity toEntity() => TaskPromptEntity(
    promptID: promptID,
    taskID: taskID,
    filePath: filePath,
    transcription: transcription,
  );
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_prompt\data\task_prompt_repository_impl.dart ===
import '../../task_prompt/domain/task_prompt_entity.dart';
import '../../task_prompt/domain/task_prompt_repository.dart';
import '../../task_prompt/data/task_prompt_local_datasource.dart';
import '../../task_prompt/data/task_prompt_model.dart';

class TaskPromptRepositoryImpl implements TaskPromptRepository {
  final TaskPromptLocalDataSource localDataSource;

  TaskPromptRepositoryImpl({required this.localDataSource});

  @override
  Future<int?> insert(TaskPromptEntity entity) async {
    final model = TaskPromptModel.fromEntity(entity);
    return await localDataSource.insert(model);
  }

  @override
  Future<TaskPromptEntity?> getById(int id) async {
    final model = await localDataSource.getById(id);
    return model?.toEntity();
  }

  @override
  Future<TaskPromptEntity?> getByTaskId(int taskId) async {
    final model = await localDataSource.getByTaskId(taskId);
    return model?.toEntity();
  }

  @override
  Future<List<TaskPromptEntity>> getAll() async {
    final models = await localDataSource.getAll();
    return models.map((m) => m.toEntity()).toList();
  }

  @override
  Future<int> update(TaskPromptEntity entity) async {
    final model = TaskPromptModel.fromEntity(entity);
    return await localDataSource.update(model);
  }

  @override
  Future<int> delete(int id) async {
    return await localDataSource.delete(id);
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_prompt\domain\task_prompt_entity.dart ===
class TaskPromptEntity {
  final int? promptID;
  final int taskID;
  final String filePath;
  final String? transcription;

  const TaskPromptEntity({
    this.promptID,
    required this.taskID,
    required this.filePath,
    this.transcription,
  });

  TaskPromptEntity copyWith({
    int? promptID,
    int? taskId,
    String? filePath,
    String? transcription,
  }) {
    return TaskPromptEntity(
      promptID: promptID ?? this.promptID,
      taskID: taskId ?? this.taskID,
      filePath: filePath ?? this.filePath,
      transcription: transcription ?? this.transcription,
    );
  }

  @override
  String toString() =>
      'TaskPromptEntity(id: $promptID, taskId: $taskID, filePath: $filePath, transcription: $transcription)';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_prompt\domain\task_prompt_repository.dart ===
import 'task_prompt_entity.dart';

abstract class TaskPromptRepository {
  Future<int?> insert(TaskPromptEntity entity);
  Future<TaskPromptEntity?> getById(int id);
  Future<TaskPromptEntity?> getByTaskId(int taskId);
  Future<List<TaskPromptEntity>> getAll();
  Future<int> update(TaskPromptEntity entity);
  Future<int> delete(int id);
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\main.dart ===
import 'dart:ui';

import 'package:fluent_ui/fluent_ui.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:sqflite_common_ffi/sqflite_ffi.dart';

import 'core/router.dart';
import 'core/theme/app_theme.dart';
import 'core/logger/app_logger.dart';

Future<void> initDatabaseFactory() async {
  AppLogger.info('Initializing database factory...');
  sqfliteFfiInit();
  databaseFactory = databaseFactoryFfi;
  AppLogger.info('‚úÖ Database factory initialized using FFI');
}

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  AppLogger.info('Flutter bindings initialized');

  await initDatabaseFactory();

  FlutterError.onError = (FlutterErrorDetails details) {
    AppLogger.error('Flutter framework error', details.exception, details.stack);
  };

  PlatformDispatcher.instance.onError = (error, stack) {
    AppLogger.error('Uncaught async error', error, stack);
    return true;
  };

  AppLogger.info('üöÄ Application starting...');
  runApp(const ProviderScope(child: StartupApp()));
}

class StartupApp extends StatelessWidget {
  const StartupApp({super.key});

  @override
  Widget build(BuildContext context) {
    AppLogger.info('üèóÔ∏è Building StartupApp widget tree');
    return FluentApp.router(
      title: 'Novo Cogni',
      debugShowCheckedModeBanner: false,
      themeMode: ThemeMode.system,
      theme: AppTheme.light,
      darkTheme: AppTheme.dark,
      routerConfig: router,
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\providers\providers.dart ===
import 'package:hooks_riverpod/hooks_riverpod.dart';

import '../features/evaluator/data/evaluator_model.dart';

enum AppEnv { local, remote }

final environmentProvider = Provider<AppEnv>((_) => AppEnv.local);


final currentUserProvider =
NotifierProvider<CurrentUserNotifier, EvaluatorModel?>(CurrentUserNotifier.new);

class CurrentUserNotifier extends Notifier<EvaluatorModel?> {
  @override
  EvaluatorModel? build() => null; // initial state is null

  void setUser(EvaluatorModel user) => state = user;

  void clearUser() => state = null;
}



=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\providers\startup_provider.dart ===
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/database_helper.dart';
import '../../core/logger/app_logger.dart';
import '../../features/evaluator/data/evaluator_local_datasource.dart';

enum StartupState { ready }

final startupProvider =
FutureProvider<StartupState>((ref) async {
  AppLogger.info('[STARTUP] Checking evaluator presence...');
  final db = await DatabaseHelper.instance.database;
  final evaluatorDS = EvaluatorLocalDataSource(db);

  final evaluators = await evaluatorDS.getAll();

  if (evaluators.isEmpty) {
    AppLogger.warning(
        '[STARTUP] No evaluators found ‚Äî seeder might not have run yet');
  } else {
    AppLogger.info(
        '[STARTUP] Found ${evaluators.length} evaluator(s), proceeding to login');
  }

  return StartupState.ready;
});


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\evaluators\evaluator_seed.dart ===
import '../../core/database_helper.dart';
import '../../core/logger/app_logger.dart';
import '../../features/evaluator/data/evaluator_model.dart';
import '../../features/evaluator/data/evaluator_local_datasource.dart';
import '../../features/evaluator/domain/evaluator_entity.dart';

Future<void> seedDummyEvaluator() async {
  AppLogger.seed('[EVALUATOR] Checking for existing evaluators...');
  final db = await DatabaseHelper.instance.database;
  final datasource = EvaluatorLocalDataSource(db);

  final exists = await datasource.existsByEmail('dummy@local');
  if (exists) {
    AppLogger.seed('[EVALUATOR] Dummy evaluator already exists.');
    return;
  }


  final dummy = EvaluatorEntity(
    name: 'Dummy',
    surname: 'Evaluator',
    email: 'dummy@local',
    birthDate: '1990-01-01',
    specialty: 'Neuropsychology',
    cpfOrNif: '00000000000',
    username: 'dummy',
    password: '123456',
    firstLogin: false,
  );

  await datasource.insert(EvaluatorModel.fromEntity(dummy));
  AppLogger.seed('[EVALUATOR] ‚úÖ Dummy evaluator created successfully.');
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\modules\modules_seeds.dart ===
library module_seeds;

import 'package:sqflite_common_ffi/sqflite_ffi.dart';

import '../../core/logger/app_logger.dart';
import '../../features/module/data/module_constants.dart';
import '../../features/module/data/module_model.dart';
import '../../features/module/domain/module_entity.dart';
part 'modules_seeds_constants.dart';

Future<void> seedModules(Database db) async {
  AppLogger.seed('[MODULES] Seeding modules...');
  final modules = [
    ModuleEntity(moduleID: 1, title: 'Sociodemographic Info'),
    ModuleEntity(moduleID: 2, title: 'Cognitive Functions'),
    ModuleEntity(moduleID: 3, title: 'Functionality'),
    ModuleEntity(moduleID: 4, title: 'Depression Symptoms'),
    ModuleEntity(moduleID: 5, title: 'Tests'),
  ];

  for (final module in modules) {
    final result = await db.query(
      'modules',
      where: '${ModuleFields.id} = ?',
      whereArgs: [module.moduleID],
    );
    if (result.isEmpty) {
      await db.insert('modules', module.toModel().toMap());
      AppLogger.seed('[MODULES] Seeded module: ${module.moduleID} ‚Üí ${module.title}');
    } else {
      AppLogger.debug('[MODULES] Skipped existing module: ${module.moduleID}');
    }
  }
  AppLogger.seed('[MODULES] Done seeding modules.');
}

extension ModuleEntityMapper on ModuleEntity {
  ModuleModel toModel() => ModuleModel(
    moduleID: moduleID,
    title: title,
  );
}

=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\modules\modules_seeds_constants.dart ===
part of module_seeds;

String sociodemographicInfo = 'Dados Pessoais';
int sociodemographicInfoId = 1;

String cognitiveFunctions = 'Fun√ß√µes Cognitivas';
int cognitiveFunctionsId = 2;

String functionality = 'Funcionalidade';
int functionalityId = 3;

String depressionSymptoms = 'Sintomas de Depress√£o';
int depressionSymptomsId = 4;

String testsModuleTitle = 'Teste de √Åudio e Grava√ß√£o';
int testsModuleId = 9001;


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\prompts\prompts_seed.dart ===
library prompts_seeds;

import 'package:sqflite_common_ffi/sqflite_ffi.dart';

import '../../core/constants/database_constants.dart';
import '../../core/logger/app_logger.dart';
import '../../features/task_prompt/data/task_prompt_constants.dart';
import '../../features/task_prompt/data/task_prompt_model.dart';
import '../../features/task_prompt/domain/task_prompt_entity.dart';
import '../../core/constants/audio_file_paths.dart';
import '../tasks/task_seeds.dart';

part 'prompts_seeds_constants.dart';
part 'prompts_seeds_list.dart';

extension TaskPromptEntityMapper on TaskPromptEntity {
  TaskPromptModel toModel() {
    return TaskPromptModel(
      promptID: promptID,
      taskID: taskID,
      filePath: filePath,
      transcription: transcription,
    );
  }
}

Future<void> seedPrompts(Database db) async {
  AppLogger.seed('[PROMPTS] Seeding prompts...');

  for (final prompt in tasksPromptsList) {
    final result = await db.query(
      Tables.taskPrompts,
      where: '${TaskPromptFields.promptID} = ?',
      whereArgs: [prompt.promptID],
    );
    if (result.isEmpty) {
      await db.insert('task_prompts', prompt.toModel().toMap());
      AppLogger.seed('[PROMPTS] Seeded prompt: ${prompt.promptID} ‚Üí ${prompt.filePath}');
    } else {
      AppLogger.debug('[PROMPTS] Skipped existing prompt: ${prompt.promptID}');
    }
  }

  AppLogger.seed('[PROMPTS] Done seeding prompts.');
}

=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\prompts\prompts_seeds_constants.dart ===
part of prompts_seeds;

var helloHowAreYouTaskPromptID = 1;
var whatsYourNameTaskPromptID = 2;
var whatsYourDOBTaskPromptID = 3;
var whatsYourEducationLevelTaskPromptID = 4;
var whatWasYourProfessionTaskPromptID = 5;

var whoDoYouLiveWithTaskPromptID = 6;
var doYouExerciseFrequentlyTaskPromptID = 7;
var doYouReadFrequentlyTaskPromptID = 8;
var doYouPlayPuzzlesOrVideoGamesFrequentlyTaskPromptID = 9;
var doYouHaveAnyDiseaseTaskPromptID = 10;

var payCloseAttentionTaskPromptID = 11;
var subtracting3AndAgainTaskPromptID = 12;
var whatYearAreWeInTaskPromptID = 13;
var whatMonthAreWeInTaskPromptID = 14;
var whatDayOfTheMonthIsItTaskPromptID = 15;

var whatDayOfTheWeekIsItTaskPromptID = 16;
var howOldAreYouTaskPromptID = 17;
var whereAreWeNowTaskPromptID = 18;
var currentPresidentOfBrazilTaskPromptID = 19;
var formerPresidentOfBrazilTaskPromptID = 20;

var repeatWordsAfterListeningFirstTimeTaskPromptID = 21;
var recallWordsFromListFirstTimeTaskPromptID = 22;
var repeatWordsAfterListeningSecondTimeTaskPromptID = 23;
var recallWordsFromListSecondTimeTaskPromptID = 24;
var repeatWordsAfterListeningThirdTimeTaskPromptID = 25;

var recallWordsFromListThirdTimeTaskPromptID = 26;
var whatDidYouDoYesterdayTaskPromptID = 27;
var favoriteChildhoodGameTaskPromptID = 28;
var retellWordsHeardBeforeTaskPromptID = 29;
var payCloseAttentionToTheStoryTaskPromptID = 30;

var anasCatStoryTaskPromptID = 31;
var howManyAnimalsCanYouThinkOfTaskPromptID = 32;
var wordsStartingWithFTaskPromptID = 33;
var wordsStartingWithATaskPromptID = 34;
var wordsStartingWithSTaskPromptID = 35;

var describeWhatYouSeeTaskPromptID = 36;
var retellStoryTaskPromptID = 37;
var yesOrNoQuestionsTaskPromptID = 38;
var canYouBatheAloneTaskPromptID = 39;
var canYouDressAloneTaskPromptID = 40;

var canYouUseToiletAloneTaskPromptID = 41;
var canYouUsePhoneAloneTaskPromptID = 42;
var canYouShopAloneTaskPromptID = 43;
var canYouHandleMoneyAloneTaskPromptID = 44;
var canYouManageMedicationAloneTaskPromptID = 45;

var canYouUseTransportAloneTaskPromptID = 46;
var feelingsInPastTwoWeeksTaskPromptID = 47;
var feelingSadFrequentlyTaskPromptID = 48;
var feelingTiredOrLackingEnergyTaskPromptID = 49;
var troubleSleepingTaskPromptID = 50;

var preferringToStayHomeTaskPromptID = 51;
var feelingUselessOrGuiltyTaskPromptID = 52;
var lostInterestInActivitiesTaskPromptID = 53;
var hopefulAboutFutureTaskPromptID = 54;
var feelingLifeIsWorthLivingTaskPromptID = 55;
var thankingForParticipationTaskPromptID = 56;

// Validation
final aPressaEhInimigaTaskPromptId = 9001;
final conteAte5taskPromptID = 9004;


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\prompts\prompts_seeds_list.dart ===
part of prompts_seeds;

final helloHowAreYouPrompt = TaskPromptEntity(
  promptID: helloHowAreYouTaskPromptID,
  taskID: helloHowAreYouTask.taskID!,
  filePath: AudioFilePaths.hello_how_are_you,
  transcription: "Ol√°, tudo bem! Agora vou fazer algumas perguntas para conhecer voc√™ melhor.",
);

final whatsYourNamePrompt = TaskPromptEntity(
  promptID: whatsYourNameTaskPromptID,
  taskID: whatsYourNameTask.taskID!,
  filePath: AudioFilePaths.whats_your_name,
  transcription: "Qual o seu nome?",
);

final whatsYourDOBPrompt = TaskPromptEntity(
  promptID: whatsYourDOBTaskPromptID,
  taskID: whatsYourDOBTask.taskID!,
  filePath: AudioFilePaths.whats_your_dob,
  transcription: "Qual a sua data de nascimento?",
);

final whatsYourEducationLevelPrompt = TaskPromptEntity(
  promptID: whatsYourEducationLevelTaskPromptID,
  taskID: whatsYourEducationLevelTask.taskID!,
  filePath: AudioFilePaths.whats_your_education_level,
  transcription: "Qual a sua escolaridade? Me diga at√© quando voc√™ estudou:",
);

final whatWasYourProfessionPrompt = TaskPromptEntity(
  promptID: whatWasYourProfessionTaskPromptID,
  taskID: whatWasYourProfessionTask.taskID!,
  filePath: AudioFilePaths.what_was_your_profession,
  transcription: "Qual era a sua profiss√£o?",
);

final whoDoYouLiveWithPrompt = TaskPromptEntity(
  promptID: whoDoYouLiveWithTaskPromptID,
  taskID: whoDoYouLiveWithTask.taskID!,
  filePath: AudioFilePaths.who_do_you_live_with,
  transcription: "Com quem voc√™ mora atualmente?",
);

final doYouExerciseFrequentlyPrompt = TaskPromptEntity(
  promptID: doYouExerciseFrequentlyTaskPromptID,
  taskID: doYouExerciseFrequentlyTask.taskID!,
  filePath: AudioFilePaths.do_you_exercise_frequently,
  transcription: "Voc√™ faz alguma atividade f√≠sica com frequ√™ncia?",
);

final doYouReadFrequentlyPrompt = TaskPromptEntity(
  promptID: doYouReadFrequentlyTaskPromptID,
  taskID: doYouReadFrequentlyTask.taskID!,
  filePath: AudioFilePaths.do_you_read_frequently,
  transcription: "Voc√™ costuma ler com frequ√™ncia?",
);

final doYouPlayPuzzlesOrVideoGamesFrequentlyPrompt = TaskPromptEntity(
  promptID: doYouPlayPuzzlesOrVideoGamesFrequentlyTaskPromptID,
  taskID: doYouPlayPuzzlesOrVideoGamesFrequentlyTask.taskID!,
  filePath: AudioFilePaths.do_you_play_puzzles_or_video_games_frequently,
  transcription:
  "Voc√™ costuma jogar palavras-cruzadas, ca√ßa-palavras ou jogos eletr√¥nicos com frequ√™ncia?",
);

final doYouHaveAnyDiseasesPrompt = TaskPromptEntity(
  promptID: doYouHaveAnyDiseaseTaskPromptID,
  taskID: doYouHaveAnyDiseasesTask.taskID!,
  filePath: AudioFilePaths.do_you_have_any_diseases,
  transcription: "Algum m√©dico j√° disse que voc√™ tem alguma doen√ßa? Me diga quais s√£o essas doen√ßas:",
);

final aPressaEhInimigaTaskPrompt = TaskPromptEntity(
  promptID: aPressaEhInimigaTaskPromptId,
  taskID: pressaInimigaTask.taskID!,
  filePath: AudioFilePaths.aPressaEhInimiga,
);

final conteAteh5TaskPrompt = TaskPromptEntity(
  promptID: conteAte5taskPromptID,
  taskID: conteAte5Task.taskID!,
  filePath: AudioFilePaths.conteAte5,
);

List<TaskPromptEntity> tasksPromptsList = [
  helloHowAreYouPrompt,
  whatsYourNamePrompt,
  whatsYourDOBPrompt,
  whatsYourEducationLevelPrompt,
  whatWasYourProfessionPrompt,
  whoDoYouLiveWithPrompt,
  doYouExerciseFrequentlyPrompt,
  doYouReadFrequentlyPrompt,
  doYouPlayPuzzlesOrVideoGamesFrequentlyPrompt,
  doYouHaveAnyDiseasesPrompt,
  aPressaEhInimigaTaskPrompt,
  conteAteh5TaskPrompt,
];


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\seed_runner.dart ===
import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import '../core/logger/app_logger.dart';
import '../core/database_helper.dart';
import 'modules/modules_seeds.dart';
import 'tasks/task_seeds.dart';
import 'prompts/prompts_seed.dart';
import 'evaluators/evaluator_seed.dart';

class SeedRunner {
  /// Runs all database seeders in a controlled order.
  /// You can call this without parameters ‚Äî it will automatically open the DB.
  Future<void> run({Database? db}) async {
    AppLogger.seed('Starting database seeding...');
    final database = db ?? await DatabaseHelper.instance.database;

    try {
      await seedModules(database);
      await seedTasks(database);
      await seedPrompts(database);
      await seedDummyEvaluator();

      AppLogger.seed('‚úÖ Database seeding complete.');
    } catch (e, s) {
      AppLogger.error('‚ùå Database seeding failed', e, s);
      rethrow;
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\tasks\task_seeds.dart ===
library task_seeds;

import 'package:sqflite_common_ffi/sqflite_ffi.dart';

import '../../core/constants/database_constants.dart';
import '../../core/logger/app_logger.dart';
import '../../core/constants/enums/task_mode.dart';
import '../../features/task/data/task_constants.dart';
import '../../features/task/data/task_model.dart';
import '../../features/task/domain/task_entity.dart';
import '../modules/modules_seeds.dart';

part 'task_seeds_constants.dart';
part 'task_seeds_list.dart';

Future<void> seedTasks(Database db) async {
  AppLogger.seed('[TASKS] Seeding tasks...');

  for (final task in tasksList) {
    final result = await db.query(
      Tables.tasks,
      where: '${TaskFields.id} = ?',
      whereArgs: [task.taskID],
    );

    if (result.isEmpty) {
      await db.insert(Tables.tasks, task.toModel().toMap());
      AppLogger.seed(
        '[TASKS] Seeded task: ${task.title} (module ${task.moduleID})',
      );
    } else {
      AppLogger.debug('[TASKS] Skipped existing task: ${task.title}');
    }
  }

  AppLogger.seed('[TASKS] Done seeding tasks.');
}

extension TaskEntityMapper on TaskEntity {
  TaskModel toModel() {
    return TaskModel(
      taskID: taskID,
      moduleID: moduleID,
      title: title,
      transcript: transcript,
      taskMode: taskMode,
      position: position,
      imagePath: imagePath,
      timeForCompletion: timeForCompletion,
      mayRepeatPrompt: mayRepeatPrompt,
      testOnly: testOnly,
    );
  }
}

=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\tasks\task_seeds_constants.dart ===
part of task_seeds;

// Sociodemographic Info Module
int helloHowAreYouTaskId = 1;
String helloHowAreYouTaskTitle = "Seja bem-vindo";
String helloHowAreYouTaskSnakeCaseTranscript = "hello_how_are_you";

int whatsYourNameTaskId = 2;
String whatsYourNameTaskTitle = "Dados Pessoais - Nome";
String whatsYourNameTaskSnakeCaseTranscript = "whats_your_name";

int whatsYourDOBTaskId = 3;
String whatsYourDOBTaskTitle = "Dados Pessoais - Nascimento";
String whatsYourDOBTaskSnakeCaseTranscript = "whats_your_dob";

int whatsYourEducationLevelTaskId = 4;
String whatsYourEducationLevelTaskTitle = "Escolaridade";
String whatsYourEducationLevelTaskSnakeCaseTranscript = "whats_your_education_level";

int whatWasYourProfessionTaskId = 5;
String whatWasYourProfessionTaskTitle = "Profiss√£o";
String whatWasYourProfessionTaskSnakeCaseTranscript = "what_was_your_profession";

int whoDoYouLiveWithTaskId = 6;
String whoDoYouLiveWithTaskTitle = "Com quem mora";
String whoDoYouLiveWithTaskSnakeCaseTranscript = "who_do_you_live_with";

int doYouExerciseFrequentlyTaskId = 7;
String doYouExerciseFrequentlyTaskTitle = "Exerc√≠cios f√≠sicos";
String doYouExerciseFrequentlyTaskSnakeCaseTranscript = "do_you_exercise_frequently";

int doYouReadFrequentlyTaskId = 8;
String doYouReadFrequentlyTaskTitle = "Leitura";
String doYouReadFrequentlyTaskSnakeCaseTranscript = "do_you_read_frequently";

int doYouPlayPuzzlesOrVideoGamesFrequentlyTaskId = 9;
String doYouPlayPuzzlesOrVideoGamesFrequentlyTaskTitle = "Jogos & passatempos";
String doYouPlayPuzzlesOrVideoGamesFrequentlyTaskSnakeCaseTranscript = "do_you_play_puzzles_or_video_games_frequently";

int doYouHaveAnyDiseasesTaskId = 10;
String doYouHaveAnyDiseasesTaskTitle = "Doen√ßas diagnosticadas";
String doYouHaveAnyDiseasesTaskSnakeCaseTranscript = "do_you_have_any_diseases";

// Validation
int pressaInimigaTaskId = 9001;
String pressaInimigaTaskTitle = "A pressa √© inimiga da perfei√ß√£o";
String pressaInimigaTaskSnakeCaseTranscript = "a_pressa_eh_inimiga";

int conteAte5TaskId = 9002;
String conteAte5TaskTitle = "Conte at√© 5";
String conteAte5TaskSnakeCaseTranscript = "conte_ate_5";


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\tasks\task_seeds_list.dart ===
part of task_seeds;

// === Sociodemographic Module Tasks ===


TaskEntity helloHowAreYouTask = TaskEntity(
  taskID: helloHowAreYouTaskId,
  title: helloHowAreYouTaskTitle,
  transcript: helloHowAreYouTaskSnakeCaseTranscript,
  moduleID: sociodemographicInfoId,
  taskMode: TaskMode.play,
  timeForCompletion: 60,
  mayRepeatPrompt: true,
  position: 1,
);

TaskEntity whatsYourNameTask = TaskEntity(
  taskID: whatsYourNameTaskId,
  title: whatsYourNameTaskTitle,
  transcript: whatsYourNameTaskSnakeCaseTranscript,
  moduleID: sociodemographicInfoId,
  taskMode: TaskMode.record,
  timeForCompletion: 60,
  mayRepeatPrompt: true,
  position: 2,
);

TaskEntity whatsYourDOBTask = TaskEntity(
  taskID: whatsYourDOBTaskId,
  title: whatsYourDOBTaskTitle,
  transcript: whatsYourDOBTaskSnakeCaseTranscript,
  moduleID: sociodemographicInfoId,
  taskMode: TaskMode.record,
  timeForCompletion: 60,
  mayRepeatPrompt: true,
  position: 3,
);

TaskEntity whatsYourEducationLevelTask = TaskEntity(
  taskID: whatsYourEducationLevelTaskId,
  title: whatsYourEducationLevelTaskTitle,
  transcript: whatsYourEducationLevelTaskSnakeCaseTranscript,
  moduleID: sociodemographicInfoId,
  taskMode: TaskMode.record,
  timeForCompletion: 60,
  mayRepeatPrompt: true,
  position: 4,
);

TaskEntity whatWasYourProfessionTask = TaskEntity(
  taskID: whatWasYourProfessionTaskId,
  title: whatWasYourProfessionTaskTitle,
  transcript: whatWasYourProfessionTaskSnakeCaseTranscript,
  moduleID: sociodemographicInfoId,
  taskMode: TaskMode.record,
  timeForCompletion: 60,
  mayRepeatPrompt: true,
  position: 5,
);

TaskEntity whoDoYouLiveWithTask = TaskEntity(
  taskID: whoDoYouLiveWithTaskId,
  title: whoDoYouLiveWithTaskTitle,
  transcript: whoDoYouLiveWithTaskSnakeCaseTranscript,
  moduleID: sociodemographicInfoId,
  taskMode: TaskMode.record,
  timeForCompletion: 60,
  mayRepeatPrompt: true,
  position: 6,
);

TaskEntity doYouExerciseFrequentlyTask = TaskEntity(
  taskID: doYouExerciseFrequentlyTaskId,
  title: doYouExerciseFrequentlyTaskTitle,
  transcript: doYouExerciseFrequentlyTaskSnakeCaseTranscript,
  moduleID: sociodemographicInfoId,
  taskMode: TaskMode.record,
  timeForCompletion: 60,
  mayRepeatPrompt: true,
  position: 7,
);

TaskEntity doYouReadFrequentlyTask = TaskEntity(
  taskID: doYouReadFrequentlyTaskId,
  title: doYouReadFrequentlyTaskTitle,
  transcript: doYouReadFrequentlyTaskSnakeCaseTranscript,
  moduleID: sociodemographicInfoId,
  taskMode: TaskMode.record,
  timeForCompletion: 60,
  mayRepeatPrompt: true,
  position: 8,
);

TaskEntity doYouPlayPuzzlesOrVideoGamesFrequentlyTask = TaskEntity(
  taskID: doYouPlayPuzzlesOrVideoGamesFrequentlyTaskId,
  title: doYouPlayPuzzlesOrVideoGamesFrequentlyTaskTitle,
  transcript: doYouPlayPuzzlesOrVideoGamesFrequentlyTaskSnakeCaseTranscript,
  moduleID: sociodemographicInfoId,
  taskMode: TaskMode.record,
  timeForCompletion: 60,
  mayRepeatPrompt: true,
  position: 9,
);

TaskEntity doYouHaveAnyDiseasesTask = TaskEntity(
  taskID: doYouHaveAnyDiseasesTaskId,
  title: doYouHaveAnyDiseasesTaskTitle,
  transcript: doYouHaveAnyDiseasesTaskSnakeCaseTranscript,
  moduleID: sociodemographicInfoId,
  taskMode: TaskMode.record,
  timeForCompletion: 60,
  mayRepeatPrompt: true,
  position: 10,
);

// === Validation Tasks ===

TaskEntity pressaInimigaTask = TaskEntity(
  taskID: pressaInimigaTaskId,
  title: pressaInimigaTaskTitle,
  transcript: pressaInimigaTaskSnakeCaseTranscript,
  moduleID: testsModuleId,
  taskMode: TaskMode.play,
  timeForCompletion: 60,
  mayRepeatPrompt: true,
  position: 1,
);

TaskEntity conteAte5Task = TaskEntity(
  taskID: conteAte5TaskId,
  title: conteAte5TaskTitle,
  transcript: conteAte5TaskSnakeCaseTranscript,
  moduleID: testsModuleId,
  taskMode: TaskMode.record,
  timeForCompletion: 60,
  mayRepeatPrompt: true,
  position: 2,
);

List<TaskEntity> tasksList = [
  helloHowAreYouTask,
  whatsYourNameTask,
  whatsYourDOBTask,
  whatsYourEducationLevelTask,
  whatWasYourProfessionTask,
  whoDoYouLiveWithTask,
  doYouExerciseFrequentlyTask,
  doYouReadFrequentlyTask,
  doYouPlayPuzzlesOrVideoGamesFrequentlyTask,
  doYouHaveAnyDiseasesTask,
  pressaInimigaTask,
  conteAte5Task,
];


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\database_test.dart ===
import 'package:flutter_test/flutter_test.dart';
import 'package:segundo_cogni/core/database/test_database_helper.dart';
import 'package:sqflite_common/sqlite_api.dart';

void main() {
  late Database db;

  setUp(() async {
    db = await TestDatabaseHelper.instance.database;
  });

  tearDown(() async {
    await TestDatabaseHelper.instance.deleteDb();
  });

  group('Database basic operations', () {
    test('should create all expected tables', () async {
      final result = await db.rawQuery(
          "SELECT name FROM sqlite_master WHERE type='table';");
      final tableNames =
      result.map((e) => e['name'] as String).where((n) => n != 'android_metadata').toList();

      expect(tableNames, containsAll([
        'evaluators',
        'participants',
        'modules',
        'tasks',
        'task_prompts',
        'evaluations',
        'module_instances',
        'task_instances',
        'recordings',
      ]));
    });

    test('should insert and retrieve data', () async {
      await db.insert('evaluators', {'name': 'Unit Tester'});
      final result = await db.query('evaluators');
      expect(result.first['name'], equals('Unit Tester'));
    });
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\widget_test.dart ===
// // This is a basic Flutter widget test.
// //
// // To perform an interaction with a widget in your test, use the WidgetTester
// // utility in the flutter_test package. For example, you can send tap and scroll
// // gestures. You can also use WidgetTester to find child widgets in the widget
// // tree, read text, and verify that the values of widget properties are correct.
//
// import 'package:flutter/material.dart';
// import 'package:flutter_test/flutter_test.dart';
//
// import 'package:segundo_cogni/main.dart';
//
// void main() {
//   testWidgets('Counter increments smoke test', (WidgetTester tester) async {
//     // Build our app and trigger a frame.
//     await tester.pumpWidget(const MyApp());
//
//     // Verify that our counter starts at 0.
//     expect(find.text('0'), findsOneWidget);
//     expect(find.text('1'), findsNothing);
//
//     // Tap the '+' icon and trigger a frame.
//     await tester.tap(find.byIcon(Icons.add));
//     await tester.pump();
//
//     // Verify that our counter has incremented.
//     expect(find.text('0'), findsNothing);
//     expect(find.text('1'), findsOneWidget);
//   });
// }


