=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\evaluation_provider.dart ===
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:segundo_cogni/core/database/prod_database_helper.dart';
import 'package:segundo_cogni/core/logger/app_logger.dart';
import 'package:segundo_cogni/features/evaluation/data/evaluation_local_datasource.dart';
import 'package:segundo_cogni/features/evaluation/data/evaluation_repository_impl.dart';
import 'package:segundo_cogni/features/evaluation/domain/evaluation_repository.dart';

final evaluationDbHelperProvider = Provider<ProdDatabaseHelper>((ref) {
  AppLogger.db('Providing ProdDatabaseHelper.instance for evaluations');
  return ProdDatabaseHelper.instance;
});

final evaluationRepositoryProvider = Provider<EvaluationRepository>((ref) {
  final dbHelper = ref.watch(evaluationDbHelperProvider);
  AppLogger.info('Creating EvaluationRepositoryImpl in evaluationProvider');
  return EvaluationRepositoryImpl(
    local: EvaluationLocalDataSource(dbHelper: dbHelper),
  );
});


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\config\environment.dart ===


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\constants\audio_file_paths.dart ===
class AudioFilePaths {

  static String get hello_how_are_you => 'assets/task_prompts/audio_01.wav';
  static String get whats_your_name => 'assets/task_prompts/audio_02.wav';
  static String get whats_your_dob => 'assets/task_prompts/audio_03.wav';
  static String get whats_your_education_level => 'assets/task_prompts/audio_04.wav';
  static String get what_was_your_profession => 'assets/task_prompts/audio_05.wav';

  static String get who_do_you_live_with => 'assets/task_prompts/audio_06.wav';
  static String get do_you_exercise_frequently => 'assets/task_prompts/audio_07.wav';
  static String get do_you_read_frequently => 'assets/task_prompts/audio_08.wav';
  static String get do_you_play_puzzles_or_video_games_frequently => 'assets/task_prompts/audio_09.wav';
  static String get do_you_have_any_diseases => 'assets/task_prompts/audio_10.wav';

  static String get pay_close_attention => 'assets/task_prompts/audio_11.wav';
  static String get subtracting_3_and_again => 'assets/task_prompts/audio_12.wav';
  static String get what_year_are_we_in => 'assets/task_prompts/audio_13.wav';
  static String get what_month_are_we_in => 'assets/task_prompts/audio_14.wav';
  static String get what_day_of_the_month_is_it => 'assets/task_prompts/audio_15.wav';

  static String get what_day_of_the_week_is_it => 'assets/task_prompts/audio_16.wav';
  static String get how_old_are_you => 'assets/task_prompts/audio_17.wav';
  static String get where_are_we_now => 'assets/task_prompts/audio_18.wav';
  static String get current_president_of_brazil => 'assets/task_prompts/audio_19.wav';
  static String get former_president_of_brazil => 'assets/task_prompts/audio_20.wav';

  static String get repeat_words_after_listening_first_time => 'assets/task_prompts/audio_21.wav';
  static String get recall_words_from_list_first_time => 'assets/task_prompts/audio_22.wav';
  static String get repeat_words_after_listening_second_time => 'assets/task_prompts/audio_23.wav';
  static String get recall_words_from_list_second_time => 'assets/task_prompts/audio_24.wav';
  static String get repeat_words_after_listening_third_time => 'assets/task_prompts/audio_25.wav';

  static String get recall_words_from_list_third_time => 'assets/task_prompts/audio_26.wav';
  static String get what_did_you_do_yesterday => 'assets/task_prompts/audio_27.wav';
  static String get favorite_childhood_game => 'assets/task_prompts/audio_28.wav';
  static String get retell_words_heard_before => 'assets/task_prompts/audio_29.wav';
  static String get pay_close_attention_to_the_story => 'assets/task_prompts/audio_30.wav';

  static String get anas_cat_story => 'assets/task_prompts/audio_31.wav';
  static String get how_many_animals_can_you_think_of => 'assets/task_prompts/audio_32.wav';
  static String get words_starting_with_f => 'assets/task_prompts/audio_33.wav';
  static String get words_starting_with_a => 'assets/task_prompts/audio_34.wav';
  static String get words_starting_with_s => 'assets/task_prompts/audio_35.wav';

  static String get describe_what_you_see => 'assets/task_prompts/audio_36.wav';
  static String get retell_story => 'assets/task_prompts/audio_37.wav';
  static String get yes_or_no_questions => 'assets/task_prompts/audio_38.wav';
  static String get can_you_bathe_alone => 'assets/task_prompts/audio_39.wav';
  static String get can_you_dress_alone => 'assets/task_prompts/audio_40.wav';

  static String get can_you_use_toilet_alone => 'assets/task_prompts/audio_41.wav';
  static String get can_you_use_phone_alone => 'assets/task_prompts/audio_42.wav';
  static String get can_you_shop_alone => 'assets/task_prompts/audio_43.wav';
  static String get can_you_handle_money_alone => 'assets/task_prompts/audio_44.wav';
  static String get can_you_manage_medication_alone => 'assets/task_prompts/audio_45.wav';

  static String get can_you_use_transport_alone => 'assets/task_prompts/audio_46.wav';
  static String get feelings_in_past_two_weeks => 'assets/task_prompts/audio_47.wav';
  static String get feeling_sad_frequently => 'assets/task_prompts/audio_48.wav';
  static String get feeling_tired_or_lacking_energy => 'assets/task_prompts/audio_49.wav';
  static String get trouble_sleeping => 'assets/task_prompts/audio_50.wav';

  static String get preferring_to_stay_home => 'assets/task_prompts/audio_51.wav';
  static String get feeling_useless_or_guilty => 'assets/task_prompts/audio_52.wav';
  static String get lost_interest_in_activities => 'assets/task_prompts/audio_53.wav';
  static String get hopeful_about_future => 'assets/task_prompts/audio_54.wav';
  static String get feeling_life_is_worth_living => 'assets/task_prompts/audio_55.wav';
  static String get thanking_for_participation => 'assets/task_prompts/audio_56.wav';

  static String get audioPlaceholder => 'assets/audio/audio_placeholder.mp3';

  static String get aPressaEhInimiga => 'assets/test_prompts/a_pressa_eh_inimiga_da_perfeicao.mp3';
  static String get ehMelhorUmPassaro => 'assets/test_prompts/eh_melhor_um_passaro_na_mao.mp3';
  static String get nemTudoQueReluz => 'assets/test_prompts/nem_tudo_que_reluz_eh_ouro.mp3';

  static String get conteAte5 => 'assets/test_prompts/conte_ateh_5.mp3';
  static String get digaDoisAnimais => 'assets/test_prompts/diga_dois_animais_4_patas.mp3';
  static String get repitaAFrase => 'assets/test_prompts/repita_a_frase.mp3';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\constants\database_constants.dart ===
class DatabaseConfig {
  static const name = "cognivoice_db.db";
  static const version = 1;
}

class Tables {
  static const evaluators = "evaluators";
  static const participants = "participants";
  static const evaluations = "evaluations";
  static const modules = "modules";
  static const tasks = "tasks";
  static const evaluationModules = "evaluation_modules";
  static const taskInstances = "task_instances";
  static const moduleInstances = "module_instances";
  static const taskPrompts = "task_prompts";
  static const recordings = "recordings";
  static const currentUser = "current_user";
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\constants\enums\laterality_enums.dart ===
enum Laterality {
  rightHanded(1, "Right-handed"),
  leftHanded(2, "Left-handed"),
  ambidextrous(3, "Ambidextrous");

  final int numericValue;
  final String description;

  const Laterality(this.numericValue, this.description);

  static Laterality fromValue(int value) {
    return Laterality.values.firstWhere(
          (l) => l.numericValue == value,
      orElse: () => Laterality.rightHanded,
    );
  }

  static Laterality fromLabel(String label) {
    switch (label.toLowerCase()) {
      case 'destro':
        return Laterality.rightHanded;
      case 'canhoto':
        return Laterality.leftHanded;
      case 'ambidestro':
        return Laterality.ambidextrous;
      default:
        return Laterality.rightHanded;
    }
  }

  String get label {
    switch (this) {
      case Laterality.rightHanded:
        return 'Destro';
      case Laterality.leftHanded:
        return 'Canhoto';
      case Laterality.ambidextrous:
        return 'Ambidestro';
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\constants\enums\person_enums.dart ===
enum EducationLevel {
  incompleteElementary(1, "Incomplete Elementary"),
  completeElementary(2, "Complete Elementary"),
  incompleteHighSchool(3, "Incomplete High School"),
  completeHighSchool(4, "Complete High School"),
  incompleteCollege(5, "Incomplete College"),
  completeCollege(6, "Complete College"),
  postgraduate(7, "Postgraduate"),
  master(8, "Master's Degree"), // Optional
  doctorate(9, "Doctorate");    // Optional

  final int numericValue;
  final String description;

  const EducationLevel(this.numericValue, this.description);

  static EducationLevel fromValue(int value) {
    return EducationLevel.values.firstWhere(
          (level) => level.numericValue == value,
      orElse: () => EducationLevel.completeElementary,
    );
  }

  static EducationLevel fromLabel(String label) {
    switch (label.toLowerCase()) {
      case 'gradua√ß√£o':
        return EducationLevel.completeCollege;
      case 'mestrado':
        return EducationLevel.master;
      case 'doutorado':
        return EducationLevel.doctorate;
      default:
        return EducationLevel.completeElementary;
    }
  }

  String get label {
    switch (this) {
      case EducationLevel.master:
        return 'Mestrado';
      case EducationLevel.doctorate:
        return 'Doutorado';
      case EducationLevel.completeCollege:
        return 'Gradua√ß√£o';
      default:
        return description;
    }
  }
}

enum Sex {
  male(1, "Male"),
  female(2, "Female"),
  other(3, "Other");

  final int numericValue;
  final String description;

  const Sex(this.numericValue, this.description);

  static Sex fromValue(int value) {
    return Sex.values.firstWhere(
          (s) => s.numericValue == value,
      orElse: () => Sex.other,
    );
  }

  static Sex fromString(String str) {
    switch (str.toLowerCase()) {
      case 'male':
        return Sex.male;
      case 'female':
        return Sex.female;
      case 'other':
        return Sex.other;
      default:
        return Sex.other;
    }
  }

  static Sex fromLabel(String label) {
    switch (label.toLowerCase()) {
      case 'masculino':
        return Sex.male;
      case 'feminino':
        return Sex.female;
      case 'outro':
        return Sex.other;
      default:
        return Sex.other;
    }
  }

  String get label {
    switch (this) {
      case Sex.male:
        return 'Masculino';
      case Sex.female:
        return 'Feminino';
      case Sex.other:
        return 'Outro';
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\constants\enums\progress_status.dart ===
enum ProgressStatus {
  pending(1, "Pending"),
  inProgress(2, "In Progress"),
  completed(3, "Completed");

  final int numericValue;
  final String description;

  const ProgressStatus(this.numericValue, this.description);

  static ProgressStatus fromValue(int value) {
    return ProgressStatus.values.firstWhere(
          (s) => s.numericValue == value,
      orElse: () => ProgressStatus.pending,
    );
  }
}

/// Type aliases for semantic clarity
typedef EvaluationStatus = ProgressStatus;
typedef ModuleStatus = ProgressStatus;
typedef TaskStatus = ProgressStatus;

=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\constants\enums\task_mode.dart ===
enum TaskMode {
  play(0, "Play"),
  record(1, "Record");

  final int numericValue;
  final String description;

  const TaskMode(this.numericValue, this.description);

  static TaskMode fromValue(int value) {
    return TaskMode.values.firstWhere(
          (mode) => mode.numericValue == value,
      orElse: () => TaskMode.play,
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\database\base_database_helper.dart ===
import 'package:path/path.dart' as p;
import 'package:segundo_cogni/core/logger/app_logger.dart';
import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import 'package:meta/meta.dart';


abstract class BaseDatabaseHelper {
  BaseDatabaseHelper(this.dbName);

  final String dbName;
  Database? _db;

  int get dbVersion => 1;

  Future<void> onCreate(Database db, int version);
  Future<void> onUpgrade(Database db, int oldVersion, int newVersion) async {}

  Future<Database> get database async {
    if (_db != null && _db!.isOpen) {
      AppLogger.db('Database already initialized.');
      return _db!;
    }
    _db = await initDb();
    return _db!;
  }

  Future<Database> initDb() async {
    AppLogger.db('Initializing database: $dbName');

    final dbPath = await databaseFactory.getDatabasesPath();
    final path = p.join(dbPath, dbName);
    AppLogger.db('Database path resolved: $path');

    final db = await databaseFactory.openDatabase(
      path,
      options: OpenDatabaseOptions(
        version: dbVersion,
        onCreate: (db, version) async {
          AppLogger.db('Creating database schema.');
          await onCreate(db, version);
        },
        onUpgrade: (db, oldV, newV) async {
          AppLogger.db('Upgrading database from $oldV to $newV.');
          await onUpgrade(db, oldV, newV);
        },
      ),
    );

    AppLogger.db('Database opened successfully.');
    return db;
  }

  Future<void> close() async {
    if (_db != null) {
      await _db!.close();
      _db = null;
      AppLogger.db('Database closed and reset.');
    }
  }

  Future<void> deleteDb() async {
    final dbPath = await databaseFactory.getDatabasesPath();
    final path = p.join(dbPath, dbName);
    await databaseFactory.deleteDatabase(path);
    _db = null;
    AppLogger.db('Database deleted: $dbName');
  }

  @protected
  Database? get dbInstance => _db;

  @protected
  void setDbInstance(Database? db) {
    _db = db;
  }

}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\database\database_schema.dart ===
import 'package:sqflite_common/sqlite_api.dart';
import '../../features/evaluator/data/current_user_constants.dart';
import '../constants/database_constants.dart';
import 'package:segundo_cogni/core/logger/app_logger.dart';

// Import table scripts
import '../../features/evaluator/data/evaluator_constants.dart';
import '../../features/module/data/module_constants.dart';
import '../../features/module_instance/data/module_instance_constants.dart';
import '../../features/participant/data/participant_constants.dart';
import '../../features/evaluation/data/evaluation_constants.dart';
import '../../features/recording_file/data/recording_file_constants.dart';
import '../../features/task/data/task_constants.dart';
import '../../features/task_instance/data/task_instance_constants.dart';
import '../../features/task_prompt/data/task_prompt_constants.dart';

class DatabaseSchema {
  static final List<String> _createScripts = [
    scriptCreateTableEvaluators,
    scriptCreateTableParticipants,
    scriptCreateTableModules,
    scriptCreateTableTasks,
    scriptCreateTableTaskPrompts,
    scriptCreateTableEvaluations,
    scriptCreateTableModuleInstances,
    scriptCreateTableTaskInstances,
    scriptCreateTableRecordings,
    scriptCreateTableCurrentUser
  ];

  static final List<String> _tableNames = [
    Tables.evaluators,
    Tables.participants,
    Tables.modules,
    Tables.tasks,
    Tables.taskPrompts,
    Tables.evaluations,
    Tables.moduleInstances,
    Tables.taskInstances,
    Tables.recordings,
    Tables.currentUser
  ];

  /// Creates all tables and verifies that they were created successfully.
  static Future<void> createAll(Database db) async {
    for (int i = 0; i < _createScripts.length; i++) {
      final tableName = _tableNames[i];
      final script = _createScripts[i];
      try {
        await db.execute(script);
        AppLogger.db('‚úÖ Created table: $tableName');
      } catch (e) {
        AppLogger.db('‚ö†Ô∏è Skipping table "$tableName" ‚Äî possibly already exists: $e');
      }
    }
    await _verifySchema(db);
  }

  /// Drops all tables (for upgrades or tests).
  static Future<void> dropAll(Database db) async {
    for (final name in _tableNames.reversed) {
      try {
        await db.execute('DROP TABLE IF EXISTS $name');
        AppLogger.db('üóëÔ∏è Dropped table: $name');
      } catch (e) {
        AppLogger.db('‚ö†Ô∏è Failed to drop $name: $e');
      }
    }
  }

  /// Confirms that all expected tables exist in the DB.
  static Future<void> _verifySchema(Database db) async {
    final result = await db.rawQuery(
      "SELECT name FROM sqlite_master WHERE type='table';",
    );
    final existing = result.map((e) => e['name']).toSet();

    for (final expected in _tableNames) {
      if (existing.contains(expected)) {
        AppLogger.db('‚úÖ Verified: $expected');
      } else {
        AppLogger.error('‚ùå Missing table: $expected');
      }
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\database\prod_database_helper.dart ===
import 'package:sqflite_common/sqlite_api.dart';
import 'package:segundo_cogni/core/database/base_database_helper.dart';
import 'package:segundo_cogni/core/database/database_schema.dart';
import 'package:segundo_cogni/core/logger/app_logger.dart';

class ProdDatabaseHelper extends BaseDatabaseHelper {
  ProdDatabaseHelper._() : super('cognivoice_db.db');

  static final ProdDatabaseHelper instance = ProdDatabaseHelper._();

  @override
  Future<void> onCreate(Database db, int version) async {
    AppLogger.db('Creating production schema...');
    await DatabaseSchema.createAll(db);
  }

  @override
  Future<void> onUpgrade(Database db, int oldVersion, int newVersion) async {
    AppLogger.db('Upgrading DB $oldVersion ‚Üí $newVersion');
    await DatabaseSchema.dropAll(db);
    await DatabaseSchema.createAll(db);
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\database\test_database_helper.dart ===
import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import 'package:segundo_cogni/core/database/base_database_helper.dart';
import 'package:segundo_cogni/core/database/database_schema.dart';
import 'package:segundo_cogni/core/logger/app_logger.dart';

class TestDatabaseHelper extends BaseDatabaseHelper {
  TestDatabaseHelper._() : super('test_cognivoice_db.db');

  static final TestDatabaseHelper instance = TestDatabaseHelper._();

  @override
  Future<Database> initDb() async {
    if (dbInstance != null && dbInstance!.isOpen) {
      AppLogger.db('‚úÖ Test DB already initialized.');
      return dbInstance!;
    }

    sqfliteFfiInit();
    databaseFactory = databaseFactoryFfi;

    AppLogger.db('üõ†Ô∏è Creating in-memory test database...');

    final db = await databaseFactory.openDatabase(
      inMemoryDatabasePath,
      options: OpenDatabaseOptions(
        version: dbVersion,
        onCreate: (db, version) async {
          AppLogger.db('üì¶ Creating test schema...');
          await onCreate(db, version);
        },
        onUpgrade: (db, oldV, newV) async {
          AppLogger.db('üîÑ Upgrading test DB $oldV ‚Üí $newV (recreating schema)');
          await onUpgrade(db, oldV, newV);
        },
      ),
    );

    // Use protected setter to store the opened DB
    setDbInstance(db);

    return db;
  }

  @override
  Future<void> onCreate(Database db, int version) async {
    await DatabaseSchema.createAll(db);
  }
  static Future<void> delete() async {
    if (instance.dbInstance != null && instance.dbInstance!.isOpen) {
      await instance.dbInstance!.close();
      instance.setDbInstance(null);
      AppLogger.db('üßπ In-memory test DB reset.');
    }
  }

  @override
  Future<void> onUpgrade(Database db, int oldVersion, int newVersion) async {
    await DatabaseSchema.dropAll(db);
    await DatabaseSchema.createAll(db);
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\database_helper.dart ===
import 'package:path/path.dart';
import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import '../features/evaluation/data/evaluation_constants.dart';
import '../features/evaluator/data/current_user_constants.dart';
import '../features/evaluator/data/evaluator_constants.dart';
import '../features/module/data/module_constants.dart';
import '../features/participant/data/participant_constants.dart';
import '../features/task/data/task_constants.dart';
import '../features/task_prompt/data/task_prompt_constants.dart';
import 'constants/database_constants.dart';
import 'logger/app_logger.dart';

class DatabaseHelper {
  static final DatabaseHelper instance = DatabaseHelper._init();
  static Database? _database;

  DatabaseHelper._init();

  Future<Database> get database async {
    if (_database != null) {
      AppLogger.db('Database already initialized.');
      return _database!;
    }
    _database = await _initDB(DatabaseConfig.name);
    return _database!;
  }

  Future<Database> _initDB(String filePath) async {
    AppLogger.db('Initializing database: $filePath');
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, filePath);

    AppLogger.db('Database path resolved: $path');
    final db = await openDatabase(
      path,
      version: 1,
      onCreate: _createDB,
      onOpen: (db) => AppLogger.db('Database opened successfully.'),
    );
    AppLogger.db('Database openDatabase() completed.');
    return db;
  }

  Future _createDB(Database db, int version) async {
    AppLogger.db('Creating database schema, version=$version');
    try {
      await db.execute(scriptCreateTableEvaluators);
      await db.execute(scriptCreateTableParticipants);
      await db.execute(scriptCreateTableEvaluations);
      await db.execute(scriptCreateTableModules);
      await db.execute(scriptCreateTableTasks);
      await db.execute(scriptCreateTableTaskPrompts);
      await db.execute(scriptCreateTableCurrentUser);
      AppLogger.db('‚úÖ Database schema created successfully.');
    } catch (e, s) {
      AppLogger.error('‚ùå Error creating DB schema', e, s);
    }
  }


  Future<int> insert(String table, Map<String, dynamic> values) async {
    final db = await instance.database;
    AppLogger.db('Inserting into $table: $values');
    try {
      final id = await db.insert(table, values);
      AppLogger.db('Insert success [$table]: id=$id');
      return id;
    } catch (e, s) {
      AppLogger.error('Insert failed [$table]', e, s);
      rethrow;
    }
  }

  Future<List<Map<String, dynamic>>> query(String table,
      {String? where, List<Object?>? whereArgs}) async {
    final db = await instance.database;
    AppLogger.db('Querying table=$table where=$where args=$whereArgs');
    try {
      final result = await db.query(table, where: where, whereArgs: whereArgs);
      AppLogger.db('Query success [$table]: ${result.length} rows');
      return result;
    } catch (e, s) {
      AppLogger.error('Query failed [$table]', e, s);
      rethrow;
    }
  }

  Future<int> update(String table, Map<String, dynamic> values,
      {String? where, List<Object?>? whereArgs}) async {
    final db = await instance.database;
    AppLogger.db('Updating $table set=$values where=$where');
    try {
      final count =
      await db.update(table, values, where: where, whereArgs: whereArgs);
      AppLogger.db('Update success [$table]: $count rows affected');
      return count;
    } catch (e, s) {
      AppLogger.error('Update failed [$table]', e, s);
      rethrow;
    }
  }

  Future<int> delete(String table,
      {String? where, List<Object?>? whereArgs}) async {
    final db = await instance.database;
    AppLogger.db('Deleting from $table where=$where');
    try {
      final count =
      await db.delete(table, where: where, whereArgs: whereArgs);
      AppLogger.db('Delete success [$table]: $count rows removed');
      return count;
    } catch (e, s) {
      AppLogger.error('Delete failed [$table]', e, s);
      rethrow;
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\environment.dart ===
enum AppEnv {
  local,
  remote,
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\logger\app_logger.dart ===
import 'package:flutter/foundation.dart';
import 'package:logger/logger.dart';

class AppLogger {
  static final bool _isRelease = kReleaseMode;

  static final Logger _logger = Logger(
    printer: PrettyPrinter(
      methodCount: 2,
      errorMethodCount: 5,
      lineLength: 100,
      colors: true,
      printEmojis: true,
      printTime: true,
    ),
  );

  static void info(String message) {
    if (_isRelease) return;
    _logger.i(message);
  }

  static void debug(String message) {
    if (_isRelease) return;
    _logger.d(message);
  }

  static void warning(String message) {
    if (_isRelease) return;
    _logger.w(message);
  }

  static void error(String message, [dynamic error, StackTrace? stack]) {
    if (_isRelease) return;
    _logger.e(
      message,
      error: error,
      stackTrace: stack,
    );
  }

  static void db(String message) {
    if (_isRelease) return;
    _logger.d('[DB] $message');
  }

  static void nav(String message) {
    if (_isRelease) return;
    _logger.i('[NAV] $message');
  }

  static void trace(String message) {
    if (_isRelease) return;
    _logger.t(message);
  }

  static void seed(String message) {
    if (_isRelease) return;
    _logger.i('[SEED] $message');
  }

}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\network.dart ===
import 'dart:convert';

import 'package:http/http.dart' as http;

import 'logger/app_logger.dart';

class NetworkService {
  final String baseUrl = 'https://api.example.com';

  Future<http.Response> get(String endpoint) async {
    final url = Uri.parse('$baseUrl$endpoint');
    AppLogger.info('HTTP GET ‚Üí $url');

    try {
      final response = await http.get(url);
      AppLogger.info('HTTP ${response.statusCode} ‚Üê $url');
      if (response.statusCode >= 400) {
        AppLogger.warning('HTTP error ${response.statusCode}: ${response.body}');
      }
      return response;
    } catch (e, s) {
      AppLogger.error('HTTP GET failed for $url', e, s);
      rethrow;
    }
  }

  Future<http.Response> post(String endpoint, Map<String, dynamic> body) async {
    final url = Uri.parse('$baseUrl$endpoint');
    AppLogger.info('HTTP POST ‚Üí $url body=$body');

    try {
      final response = await http.post(url,
          headers: {'Content-Type': 'application/json'},
          body: jsonEncode(body));
      AppLogger.info('HTTP ${response.statusCode} ‚Üê $url');
      if (response.statusCode >= 400) {
        AppLogger.warning('HTTP error ${response.statusCode}: ${response.body}');
      }
      return response;
    } catch (e, s) {
      AppLogger.error('HTTP POST failed for $url', e, s);
      rethrow;
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\router.dart ===
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';

import '../features/auth/presentation/login_screen.dart';
import '../features/evaluator/presentation/evaluator_registration_screen.dart';
import '../features/home/home_screen.dart';
import '../features/splash/splash_screen.dart';
import 'logger/app_logger.dart';

final router = GoRouter(
  initialLocation: '/',
  observers: [
    LoggingNavigatorObserver(),
  ],
  routes: [
    GoRoute(
      path: '/',
      name: 'splash',
      builder: (BuildContext context, GoRouterState state) =>
      const SplashScreen(),
    ),
    GoRoute(
      path: '/login',
      name: 'login',
      builder: (BuildContext context, GoRouterState state) =>
      const LoginScreen(),
    ),
    GoRoute(
      path: '/home',
      name: 'home',
      builder: (BuildContext context, GoRouterState state) =>
      const HomeScreen(),
    ),
    GoRoute(
      path: '/register',
      name: 'evaluator_registration',
      builder: (context, state) => const EvaluatorRegistrationScreen(),
    ),
  ],
);

class LoggingNavigatorObserver extends NavigatorObserver {
  @override
  void didPush(Route route, Route? previousRoute) {
    AppLogger.nav('PUSHED: ${route.settings.name}');
  }

  @override
  void didPop(Route route, Route? previousRoute) {
    AppLogger.nav('POPPED: ${route.settings.name}');
  }

  @override
  void didReplace({Route? newRoute, Route? oldRoute}) {
    AppLogger.nav(
        'REPLACED: ${oldRoute?.settings.name} ‚Üí ${newRoute?.settings.name}');
  }

  @override
  void didRemove(Route route, Route? previousRoute) {
    AppLogger.nav('REMOVED: ${route.settings.name}');
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\theme\app_colors.dart ===
import 'package:flutter/material.dart';

class AppColors {
  // Y2K Palette (already defined)
  static const Color lightCyan = Color(0xFFB3DDE5);
  static const Color aquaBlue = Color(0xFF02D3D2);
  static const Color chromeBlue = Color(0xFF4073A0);
  static const Color skyBlue = Color(0xFF7AC9F2);
  static const Color mistTeal = Color(0xFF5F9C9D);

  static const List<Color> y2kPalette = [
    lightCyan,
    aquaBlue,
    chromeBlue,
    skyBlue,
    mistTeal,
  ];

  // Neutrals
  static const Color pureWhite = Color(0xFFFFFFFF);
  static const Color softWhite = Color(0xFFF5F5F5);
  static const Color coolGray100 = Color(0xFFE5E7EB);
  static const Color coolGray500 = Color(0xFF6B7280);
  static const Color coolGray900 = Color(0xFF111827);
  static const Color trueBlack = Color(0xFF000000);

  // FluentUI Base
  static const Color primary = Color(0xFF0063B1); // azul Microsoft
  static const Color secondary = Color(0xFF107C10); // verde
  static const Color accent = Color(0xFFB4009E); // roxo
  static const Color neutralLight = Color(0xFFF3F2F1);
  static const Color neutralDark = Color(0xFF201F1E);

  // === New Dark Blue Shades ===
  static const Color midnightBlue = Color(0xFF0D1B2A);   // Very dark navy
  static const Color deepSeaBlue = Color(0xFF1B263B);    // Muted deep blue
  static const Color steelBlue = Color(0xFF2C3E50);      // Grayish blue
  static const Color indigoBlue = Color(0xFF283593);     // Rich indigo
  static const Color navyBlue = Color(0xFF001F54);       // Classic navy
  static const Color darkCyanBlue = Color(0xFF0A3D62);   // Cyan-tinted navy

  static const List<Color> darkBluePalette = [
    midnightBlue,
    deepSeaBlue,
    steelBlue,
    indigoBlue,
    navyBlue,
    darkCyanBlue,
  ];
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\theme\app_theme.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import 'app_colors.dart';

class AppTheme {
  static final AccentColor accent = AccentColor.swatch({
    'darkest': AppColors.chromeBlue,
    'darker': AppColors.primary,
    'dark': AppColors.skyBlue,
    'normal': AppColors.skyBlue,
    'light': AppColors.aquaBlue,
    'lighter': AppColors.lightCyan,
    'lightest': AppColors.softWhite,
    'secondary': AppColors.mistTeal,
    'tertiary': AppColors.accent,
    'transparent': const Color(0x00000000),
  });

  /// Light mode Fluent theme
  static final FluentThemeData light = FluentThemeData(
    brightness: Brightness.light,
    accentColor: accent,
    scaffoldBackgroundColor: AppColors.softWhite,
    cardColor: AppColors.pureWhite,
    menuColor: AppColors.lightCyan,
  );

  /// Dark mode Fluent theme
  static final FluentThemeData dark = FluentThemeData(
    brightness: Brightness.dark,
    accentColor: accent,
    scaffoldBackgroundColor: AppColors.coolGray900,
    cardColor: AppColors.coolGray500,
    menuColor: AppColors.neutralDark,
  );
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\utils\encryption_helper.dart ===
import 'dart:convert';
import 'dart:typed_data';
import 'package:encrypt/encrypt.dart' as encrypt;

class EncryptionHelper {
  static final _key = encrypt.Key.fromUtf8('my32lengthsupersecretnooneknows1');

  static String encryptText(String plainText) {
    if (plainText.isEmpty) return '';
    final iv = encrypt.IV.fromSecureRandom(16);
    final encrypter = encrypt.Encrypter(encrypt.AES(_key));
    final encrypted = encrypter.encrypt(plainText, iv: iv);
    final combined = Uint8List.fromList(iv.bytes + encrypted.bytes);
    return base64Encode(combined);
  }

  static String decryptText(String encryptedText) {
    if (encryptedText.isEmpty) return '';
    try {
      final raw = base64Decode(encryptedText);
      final iv = encrypt.IV(Uint8List.fromList(raw.sublist(0, 16)));
      final ciphertext = raw.sublist(16);
      final encrypter = encrypt.Encrypter(encrypt.AES(_key));
      return encrypter.decrypt(
        encrypt.Encrypted(Uint8List.fromList(ciphertext)),
        iv: iv,
      );
    } catch (e) {
      return '[DECRYPTION_FAILED]';
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\utils\error_parser.dart ===
String parseLoginError(dynamic error) {
  final errStr = error.toString();

  if (errStr.contains('no such table: current_user')) {
    return 'Erro interno: tabela de usu√°rio n√£o encontrada. Tente reinstalar o app.';
  }

  if (errStr.contains('no column named')) {
    return 'Erro no banco de dados. Contate o suporte t√©cnico.';
  }

  if (errStr.contains('DatabaseException')) {
    return 'Erro ao acessar o banco de dados. Tente novamente.';
  }

  if (errStr.contains('Credenciais inv√°lidas')) {
    return 'E-mail ou senha incorretos.';
  }

  if (errStr.contains('Exception:')) {
    return errStr.replaceFirst('Exception:', '').trim();
  }

  // Default fallback
  return 'Erro inesperado. Verifique sua conex√£o ou tente novamente.';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\core\utils\validation_helper.dart ===
class ValidationHelper {
  static bool isValidEmail(String email) {
    final regex = RegExp(r'^[\w\.-]+@[\w\.-]+\.\w+$');
    return regex.hasMatch(email);
  }

  static bool isValidPassword(String password) {
    return password.length >= 8;
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\auth\application\login_notifier.dart ===
import 'package:hooks_riverpod/hooks_riverpod.dart';
import '../../../core/logger/app_logger.dart';
import '../../../core/utils/error_parser.dart';
import '../../../providers/auth_providers.dart';

class LoginNotifier extends AsyncNotifier<bool> {
  @override
  Future<bool> build() async {
    return false;
  }

  Future<void> login(String email, String password) async {
    state = const AsyncLoading();
    AppLogger.info('Login attempt started for $email');

    if (email.isEmpty || password.isEmpty) {
      state = AsyncError('E-mail e senha s√£o obrigat√≥rios', StackTrace.current);
      return;
    }

    try {
      /// ‚úÖ Await the repository instance from the FutureProvider
      final repo = await ref.read(authRepositoryProvider.future);

      final user = await repo.login(email, password);

      if (user == null) {
        state = AsyncError('Credenciais inv√°lidas', StackTrace.current);
      } else {
        await repo.saveCurrentUserToDB(user);
        state = const AsyncData(true);
      }

    } catch (e, st) {
      AppLogger.error('Login exception',  e,  st);
      final userFriendly = parseLoginError(e);
      state = AsyncError(userFriendly, st);
    } finally {
      AppLogger.info('Login attempt finished for $email');
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\auth\data\auth_local_datasource.dart ===
import 'package:sqflite_common/sqlite_api.dart';
import '../../../core/constants/database_constants.dart';
import '../../../core/logger/app_logger.dart';
import '../../evaluator/application/evaluator_secure_service.dart';
import '../../evaluator/data/evaluator_model.dart';
import '../../evaluator/data/evaluator_constants.dart';

class AuthLocalDataSource {
  final Database _db;
  AuthLocalDataSource(this._db);

  Future<EvaluatorModel?> getEvaluatorByEmail(String email) async {
    AppLogger.db('Query evaluator by email: $email');
    final result = await _db.query(
      Tables.evaluators,
      where: '${EvaluatorFields.email} = ?',
      whereArgs: [email],
      limit: 1,
    );
    if (result.isEmpty) {
      AppLogger.db('No evaluator found for $email');
      return null;
    }
    AppLogger.db('Evaluator found for $email');
    return EvaluatorModel.fromMap(result.first);
  }

  Future<void> clearCurrentUser() async {
    AppLogger.db('Clearing current user from DB');
    await _db.delete('current_user');
  }

  Future<EvaluatorModel?> getCachedUser() async {
    AppLogger.db('Fetching cached user from DB');
    final result = await _db.query('current_user', limit: 1);
    if (result.isEmpty) return null;

    final encrypted = EvaluatorModel.fromMap(result.first);
    return EvaluatorSecureService.decrypt(encrypted);
  }

  Future<void> saveCurrentUser(EvaluatorModel user) async {
    AppLogger.db('Encrypting and saving current user to DB');
    final encrypted = EvaluatorSecureService.encrypt(user);
    await _db.delete('current_user');
    await _db.insert('current_user', encrypted.toMap());
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\auth\data\auth_model.dart ===
class AuthModel {
  final int id;
  final String email;
  final String password;

  AuthModel({required this.id, required this.email, required this.password});

  factory AuthModel.fromMap(Map<String, dynamic> map) {
    return AuthModel(
      id: map['id'] as int,
      email: map['email'] as String,
      password: map['password'] as String,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'email': email,
      'password': password,
    };
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\auth\data\auth_repository_impl.dart ===
import '../../auth/domain/auth_repository.dart';
import '../../evaluator/data/evaluator_model.dart';
import 'auth_local_datasource.dart';

class AuthRepositoryImpl implements AuthRepository {
  final AuthLocalDataSource _local;

  AuthRepositoryImpl(this._local);

  @override
  Future<EvaluatorModel?> login(String email, String password) {
    return _local.getEvaluatorByEmail(email);
  }

  @override
  Future<void> saveCurrentUserToDB(EvaluatorModel user) {
    return _local.saveCurrentUser(user);
  }

  @override
  Future<EvaluatorModel?> getCachedUser() {
    return _local.getCachedUser();
  }

  @override
  Future<void> clearCurrentUser() {
    return _local.clearCurrentUser();
  }

  @override
  Future<void> clearCurrentUserFromDB() {
    return _local.clearCurrentUser();
  }

  @override
  Future<void> cacheUser(EvaluatorModel user) {
    // Optional: implement this if different from saveCurrentUserToDB
    return _local.saveCurrentUser(user);
  }

  @override
  Future<void> clearCachedUser() {
    return _local.clearCurrentUser();
  }

  @override
  Future<EvaluatorModel?> fetchCurrentUserOrNull() {
    return _local.getCachedUser();
  }

  @override
  Future<void> signOut() {
    return _local.clearCurrentUser();
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\auth\domain\auth_repository.dart ===
import '../../evaluator/data/evaluator_model.dart';

abstract class AuthRepository {
  Future<EvaluatorModel?> login(String email, String password);
  Future<void> signOut();
  Future<void> cacheUser(EvaluatorModel user);
  Future<void> clearCachedUser();
  Future<EvaluatorModel?> getCachedUser();
  Future<EvaluatorModel?> fetchCurrentUserOrNull();
  Future<void> saveCurrentUserToDB(EvaluatorModel user);
  Future<void> clearCurrentUserFromDB();
  Future<void> clearCurrentUser();
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\auth\presentation\login_form.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../core/logger/app_logger.dart';
import '../../../core/theme/app_colors.dart';
import '../../../providers/auth_providers.dart';

class LoginForm extends HookConsumerWidget {
  const LoginForm({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final emailController = useTextEditingController();
    final passwordController = useTextEditingController();
    final showPassword = useState(false);

    final loginState = ref.watch(loginProvider);
    final showInfoBar = useState(false);
    final infoBarMsg = useState('');
    final isSuccess = useState(false);

    ref.listen<AsyncValue<bool>>(loginProvider, (previous, next) {
      next.when(
        data: (success) {
          if (success) {
            AppLogger.nav('Login successful ‚Üí navigating to /home');
            isSuccess.value = true;
            infoBarMsg.value = 'Login successful!';
            showInfoBar.value = true;
            Future.delayed(const Duration(seconds: 1), () {
              if (context.mounted) context.go('/home');
            });
          }
        },
        error: (err, _) {
          AppLogger.warning('Login error: $err');
          isSuccess.value = false;
          infoBarMsg.value = err.toString();
          showInfoBar.value = true;
        },
        loading: () {
          AppLogger.debug('Login loading...');
        },
      );
    });

    void onLoginPressed() {
      final email = emailController.text.trim();
      final password = passwordController.text;
      AppLogger.info('Login pressed: $email');
      ref.read(loginProvider.notifier).login(email, password);
    }

    return Center(
      child: Container(
        padding: const EdgeInsets.all(24),
        constraints: const BoxConstraints(maxWidth: 400),
        decoration: BoxDecoration(
          color: AppColors.coolGray900,
          borderRadius: BorderRadius.circular(16),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Text(
              "Login",
              style: TextStyle(
                fontSize: 28,
                fontWeight: FontWeight.bold,
                color: AppColors.softWhite,
              ),
            ),
            const SizedBox(height: 24),

            // Email
            InfoLabel(
              label: "Email",
              child: TextBox(
                placeholder: "email@exemplo.com",
                controller: emailController,
              ),
            ),
            const SizedBox(height: 16),

            // Password + visibility toggle
            InfoLabel(
              label: "Password",
              child: Stack(
                alignment: Alignment.centerRight,
                children: [
                  TextBox(
                    controller: passwordController,
                    obscureText: !showPassword.value,
                    placeholder: "Sua senha",
                  ),
                  IconButton(
                    icon: Icon(
                      showPassword.value ? FluentIcons.hide3 : FluentIcons.view,
                    ),
                    onPressed: () => showPassword.value = !showPassword.value,
                  ),
                ],
              ),
            ),
            const SizedBox(height: 16),

            Align(
              alignment: Alignment.centerLeft,
              child: Text(
                "Forgot password?",
                style: TextStyle(
                  color: AppColors.skyBlue,
                  decoration: TextDecoration.underline,
                ),
              ),
            ),
            const SizedBox(height: 16),

            // Login button with loading
            FilledButton(
              child: loginState.isLoading
                  ? const ProgressRing()
                  : const Text("Sign in"),
              onPressed: loginState.isLoading ? null : onLoginPressed,
            ),
            const SizedBox(height: 12),

// üëá New: Register link
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Text(
                  "Don't have an account?",
                  style: TextStyle(
                    color: AppColors.softWhite,
                  ),
                ),
                const SizedBox(width: 6),
                HyperlinkButton(
                  onPressed: () {
                    context.go('/register'); // must match your router
                  },
                  child: const Text(
                    "Create one",
                    style: TextStyle(
                      color: AppColors.skyBlue,
                      decoration: TextDecoration.underline,
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),


            // Info bar
            if (showInfoBar.value)
              InfoBar(
                title: Text(isSuccess.value ? "Success" : "Error"),
                content: Text(infoBarMsg.value),
                severity: isSuccess.value
                    ? InfoBarSeverity.success
                    : InfoBarSeverity.error,
                isLong: true,
                onClose: () => showInfoBar.value = false,
              ),
          ],
        ),
      ),
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\auth\presentation\login_screen.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:go_router/go_router.dart';
import '../../../core/logger/app_logger.dart';
import '../../../core/theme/app_colors.dart';
import '../../../providers/auth_providers.dart';
import 'login_form.dart';

class LoginScreen extends HookConsumerWidget {
  const LoginScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    AppLogger.nav('LoginScreen initialized');

    final showInfoBar = useState(false);
    final infoBarMsg = useState('');
    final isSuccess = useState(false);

    ref.listen<AsyncValue<bool>>(loginProvider, (previous, next) {
      next.when(
        data: (success) {
          if (success) {
            AppLogger.nav('Login successful ‚Üí navigating to /home');
            Future.delayed(const Duration(seconds: 1), () {
              if (context.mounted) context.go('/home');
            });
          }
        },
        error: (err, _) {
          AppLogger.warning('Login error displayed: $err');
          isSuccess.value = false;
          infoBarMsg.value = err.toString();
          showInfoBar.value = true;
        },
        loading: () => AppLogger.debug('Login process loading...'),
      );
    });

    return NavigationView(
      content: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [AppColors.aquaBlue, AppColors.skyBlue, AppColors.chromeBlue],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: const Center(child: LoginForm()),
      ),
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluation\application\notifier\evaluation_notifier.dart ===
import 'dart:async';
import 'package:riverpod/riverpod.dart';
import '../../../../core/logger/app_logger.dart';
import '../../domain/evaluation_entity.dart';
import '../../domain/evaluation_repository.dart';
import '../../presentation/provider.dart';

class EvaluationNotifier extends AsyncNotifier<List<EvaluationEntity>> {
  late final EvaluationRepository _repository;

  @override
  FutureOr<List<EvaluationEntity>> build() async {
    _repository = ref.read(evaluationRepositoryProvider);
    AppLogger.info('EvaluationNotifier.build ‚Üí loading evaluations');
    try {
      final evaluations = await _repository.getAllEvaluations();
      AppLogger.info('EvaluationNotifier.build ‚Üí loaded ${evaluations.length} evaluations');
      return evaluations;
    } catch (e, s) {
      AppLogger.error('EvaluationNotifier.build ‚Üí failed to load evaluations', e, s);
      rethrow;
    }
  }

  Future<void> refresh() async {
    AppLogger.info('EvaluationNotifier.refresh ‚Üí reloading evaluations');
    state = const AsyncLoading();
    try {
      final evaluations = await _repository.getAllEvaluations();
      AppLogger.info('EvaluationNotifier.refresh ‚Üí loaded ${evaluations.length} evaluations');
      state = AsyncData(evaluations);
    } catch (e, s) {
      AppLogger.error('EvaluationNotifier.refresh ‚Üí error', e, s);
      state = AsyncError(e, s);
    }
  }

  Future<void> addEvaluation(EvaluationEntity evaluation) async {
    AppLogger.info(
      'EvaluationNotifier.addEvaluation ‚Üí participantId=${evaluation.participantID}, evaluatorId=${evaluation.evaluatorID}',
    );
    state = const AsyncLoading();
    try {
      await _repository.insertEvaluation(evaluation);
      final updated = await _repository.getAllEvaluations();
      AppLogger.info('EvaluationNotifier.addEvaluation ‚Üí now ${updated.length} evaluations');
      state = AsyncData(updated);
    } catch (e, s) {
      AppLogger.error('EvaluationNotifier.addEvaluation ‚Üí error', e, s);
      state = AsyncError(e, s);
    }
  }

  Future<EvaluationEntity?> getEvaluationById(int id) async {
    AppLogger.info('EvaluationNotifier.getEvaluationById ‚Üí id=$id');
    try {
      final evaluation = await _repository.getById(id);
      if (evaluation == null) {
        AppLogger.warning('EvaluationNotifier.getEvaluationById ‚Üí no evaluation found for id=$id');
      }
      return evaluation;
    } catch (e, s) {
      AppLogger.error('EvaluationNotifier.getEvaluationById ‚Üí error', e, s);
      rethrow;
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluation\data\evaluation_constants.dart ===
import '../../../core/constants/database_constants.dart';
import '../../evaluator/data/evaluator_constants.dart';
import '../../participant/data/participant_constants.dart';

class EvaluationFields {
    static const id = "evaluation_id";
    static const date = "evaluation_date";
    static const evaluatorId = "evaluator_id"; // FK
    static const participantId = "participant_id"; // FK
    static const status = "status";
    static const language = "language";

    static const values = [
        id,
        date,
        evaluatorId,
        participantId,
        status,
        language,
    ];
}

const scriptCreateTableEvaluations = '''
CREATE TABLE ${Tables.evaluations} (
  ${EvaluationFields.id} INTEGER PRIMARY KEY AUTOINCREMENT,
  ${EvaluationFields.date} TIMESTAMP NOT NULL,
  ${EvaluationFields.evaluatorId} INTEGER NOT NULL,
  ${EvaluationFields.participantId} INTEGER UNIQUE NOT NULL,
  ${EvaluationFields.status} INT CHECK(${EvaluationFields.status} >= 0 AND ${EvaluationFields.status} <= 3) NOT NULL,
  ${EvaluationFields.language} INT CHECK(${EvaluationFields.language} >= 1 AND ${EvaluationFields.language} <= 3),
  FOREIGN KEY (${EvaluationFields.evaluatorId}) REFERENCES ${Tables.evaluators}(${EvaluatorFields.id}),
  FOREIGN KEY (${EvaluationFields.participantId}) REFERENCES ${Tables.participants}(${ParticipantFields.id})
);
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluation\data\evaluation_local_datasource.dart ===
import 'package:sqflite_common/sqlite_api.dart';
import '../../../core/constants/database_constants.dart';
import '../../../core/database/base_database_helper.dart';
import '../../../core/logger/app_logger.dart';
import '../domain/evaluation_entity.dart';

class EvaluationLocalDataSource {
  final BaseDatabaseHelper dbHelper;

  EvaluationLocalDataSource({required this.dbHelper});

  Future<Database> get _db async => dbHelper.database;

  Future<int?> insertEvaluation(DatabaseExecutor txn, Map<String, dynamic> data) async {
    AppLogger.db('Inserting evaluation for participantId=${data['participant_id']}');
    try {
      final id = await txn.insert(Tables.evaluations, data);
      AppLogger.db('Inserted evaluation with ID=$id');
      return id;
    } catch (e, s) {
      AppLogger.error('Error inserting evaluation', e, s);
      return null;
    }
  }

  Future<List<EvaluationEntity>> getAllEvaluations() async {
    final db = await _db;
    final maps = await db.query(Tables.evaluations);
    return maps.map(EvaluationEntity.fromMap).toList();
  }

  Future<EvaluationEntity?> getById(Database db, int id) async {
    final maps = await db.query(
      Tables.evaluations,
      where: 'id = ?',
      whereArgs: [id],
    );

    if (maps.isNotEmpty) {
      return EvaluationEntity.fromMap(maps.first);
    } else {
      return null;
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluation\data\evaluation_repository_impl.dart ===
import '../../../core/logger/app_logger.dart';
import '../domain/evaluation_entity.dart';
import '../domain/evaluation_repository.dart';
import 'evaluation_local_datasource.dart';

class EvaluationRepositoryImpl implements EvaluationRepository {
  final EvaluationLocalDataSource local;

  EvaluationRepositoryImpl({required this.local});

  @override
  Future<void> insertEvaluation(EvaluationEntity evaluation) async {
    AppLogger.db(
      'EvaluationRepositoryImpl.insertEvaluation ‚Üí participantId=${evaluation.participantID}, evaluatorId=${evaluation.evaluatorID}',
    );
    final db = await local.dbHelper.database;
    await local.insertEvaluation(db, evaluation.toMap());
  }

  @override
  Future<List<EvaluationEntity>> getAllEvaluations() async {
    AppLogger.db('EvaluationRepositoryImpl.getAllEvaluations ‚Üí fetching');
    final db = await local.dbHelper.database;
    final list = await local.getAllEvaluations();
    AppLogger.db('EvaluationRepositoryImpl.getAllEvaluations ‚Üí fetched ${list.length} evaluations');
    return list;
  }

  @override
  Future<EvaluationEntity?> getById(int id) async {
    AppLogger.db('EvaluationRepositoryImpl.getById ‚Üí id=$id');
    final db = await local.dbHelper.database;
    final evaluation = await local.getById(db, id);
    if (evaluation == null) {
      AppLogger.warning('EvaluationRepositoryImpl.getById ‚Üí not found id=$id');
    }
    return evaluation;
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluation\domain\evaluation_entity.dart ===
import 'dart:convert';

import '../../../core/constants/enums/progress_status.dart';
import '../data/evaluation_constants.dart';

class EvaluationEntity {
  final int? evaluationID;
  final int evaluatorID;
  final int participantID;
  final EvaluationStatus status;
  final DateTime evaluationDate;
  final int language;

  EvaluationEntity({
    this.evaluationID,
    DateTime? evaluationDate,
    this.status = EvaluationStatus.pending,
    required this.evaluatorID,
    required this.participantID,
    required this.language,
  }) : evaluationDate = evaluationDate ?? DateTime.now();

  Map<String, dynamic> toMap() => {
    EvaluationFields.id: evaluationID,
    EvaluationFields.date: evaluationDate.toIso8601String(),
    EvaluationFields.evaluatorId: evaluatorID,
    EvaluationFields.participantId: participantID,
    EvaluationFields.status: status.numericValue,
    EvaluationFields.language: language,
  };

  static EvaluationEntity fromMap(Map<String, dynamic> map) {
    return EvaluationEntity(
      evaluationID: map[EvaluationFields.id] as int?,
      evaluatorID: map[EvaluationFields.evaluatorId] as int,
      participantID: map[EvaluationFields.participantId] as int,
      language: map[EvaluationFields.language] as int,
      status: EvaluationStatus.fromValue(
        map[EvaluationFields.status] ?? 1,
      ),
      evaluationDate: map[EvaluationFields.date] != null
          ? DateTime.tryParse(map[EvaluationFields.date]) ?? DateTime.now()
          : DateTime.now(),
    );
  }

  String toJson() => jsonEncode(toMap());

  static EvaluationEntity fromJson(String jsonString) =>
      EvaluationEntity.fromMap(jsonDecode(jsonString));

  @override
  String toString() =>
      'EvaluationEntity(evaluationID: $evaluationID, evaluatorID: $evaluatorID, participantID: $participantID, status: ${status.description})';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluation\domain\evaluation_repository.dart ===
import 'evaluation_entity.dart';

abstract class EvaluationRepository {
  Future<void> insertEvaluation(EvaluationEntity evaluation);
  Future<List<EvaluationEntity>> getAllEvaluations();
  Future<EvaluationEntity?> getById(int id);
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluation\domain\usecases\create_participant_evaluation_usecase.dart ===
import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import '../../../../core/logger/app_logger.dart';
import '../../../../core/constants/enums/progress_status.dart';
import '../../../participant/domain/participant_entity.dart';
import '../../../participant/data/participant_local_datasource.dart';
import '../../../evaluation/data/evaluation_local_datasource.dart';
import '../../../evaluation/domain/evaluation_entity.dart';
import '../../../module/data/module_local_datasource.dart';
import '../../../module_instance/domain/module_instance_entity.dart';
import '../../../module_instance/domain/module_instance_repository.dart';
import '../../../task/data/task_local_datasource.dart';
import '../../../task_instance/domain/task_instance_entity.dart';
import '../../../task_instance/domain/task_instance_repository.dart';

class CreateParticipantEvaluationUseCase {
  final ParticipantLocalDataSource participantDataSource;
  final EvaluationLocalDataSource evaluationDataSource;
  final ModuleLocalDataSource moduleDataSource;
  final ModuleInstanceRepository moduleInstanceRepository;
  final TaskLocalDataSource taskDataSource;
  final TaskInstanceRepository taskInstanceRepository;
  final Database db;

  CreateParticipantEvaluationUseCase({
    required this.participantDataSource,
    required this.evaluationDataSource,
    required this.moduleDataSource,
    required this.moduleInstanceRepository,
    required this.taskDataSource,
    required this.taskInstanceRepository,
    required this.db,
  });

  Future<ParticipantEntity> execute({
    required ParticipantEntity participant,
    required int evaluatorId,
    int language = 1,
  }) async {
    AppLogger.info('[USECASE] Starting participant creation: ${participant.name}');

    late final ParticipantEntity createdParticipant;

    await db.transaction((txn) async {
      // 1Ô∏è‚É£ Create participant
      final participantId =
      await participantDataSource.insertParticipant(txn, participant.toMap());
      AppLogger.db('Participant inserted: id=$participantId');

      // 2Ô∏è‚É£ Create evaluation linking evaluator & participant
      final evaluation = EvaluationEntity(
        evaluatorID: evaluatorId,
        participantID: participantId!,
        status: EvaluationStatus.pending,
        language: language,
      );
      final evaluationId =
      await evaluationDataSource.insertEvaluation(txn, evaluation.toMap());
      AppLogger.db('Evaluation created: id=$evaluationId');

      // 3Ô∏è‚É£ Fetch modules and create module instances
      final modules = await moduleDataSource.getAllModules();
      for (final module in modules) {
        final moduleInstance = ModuleInstanceEntity(
          moduleId: module.moduleID!,
          evaluationId: evaluationId!,
          status: ModuleStatus.pending,
        );
        final moduleInstanceId = await moduleInstanceRepository
            .createModuleInstance(moduleInstance)
            .then((m) => m?.id);

        // 4Ô∏è‚É£ For each module, create task instances
        final tasks = await taskDataSource.getTasksByModuleId(module.moduleID!);
        for (final task in tasks) {
          final taskInstance = TaskInstanceEntity(
            taskId: task.taskID!,
            moduleInstanceId: moduleInstanceId!,
            status: TaskStatus.pending,
          );
          await taskInstanceRepository.insert(taskInstance);
        }
      }

      createdParticipant = participant.copyWith(participantID: participantId);
      AppLogger.info('[USECASE] ‚úÖ Participant + Evaluation hierarchy created.');
    });


    return createdParticipant;
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluation\presentation\provider.dart ===
import 'package:hooks_riverpod/hooks_riverpod.dart';
import '../../../core/database/prod_database_helper.dart';
import '../../../core/logger/app_logger.dart';
import '../data/evaluation_local_datasource.dart';
import '../data/evaluation_repository_impl.dart';
import '../domain/evaluation_repository.dart';

final evaluationDbHelperProvider = Provider((ref) {
  AppLogger.db('Providing ProdDatabaseHelper.instance for evaluation (presentation)');
  return ProdDatabaseHelper.instance;
});

final evaluationLocalDataSourceProvider = Provider((ref) {
  final dbHelper = ref.watch(evaluationDbHelperProvider);
  AppLogger.db('Creating EvaluationLocalDataSource');
  return EvaluationLocalDataSource(dbHelper: dbHelper);
});

final evaluationRepositoryProvider = Provider<EvaluationRepository>((ref) {
  final local = ref.watch(evaluationLocalDataSourceProvider);
  AppLogger.info('Creating EvaluationRepositoryImpl (presentation/provider)');
  return EvaluationRepositoryImpl(local: local);
});


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\application\evaluator_notifier.dart ===
import 'package:hooks_riverpod/hooks_riverpod.dart';
import '../../../core/database_helper.dart';
import '../../../core/environment.dart';
import '../../../core/logger/app_logger.dart';
import '../../../providers/providers.dart';
import '../data/evaluator_local_datasource.dart';
import '../data/evaluator_remote_datasource.dart';
import '../data/evaluator_repository_impl.dart';
import '../domain/evaluator_repository.dart';

class EvaluatorRepositoryNotifier extends AsyncNotifier<EvaluatorRepository> {
  @override
  Future<EvaluatorRepository> build() async {
    try {
      final env = ref.watch(environmentProvider);
      AppLogger.info('EvaluatorRepositoryNotifier started (env=$env)');

      if (env == AppEnv.local) {
        final db = await DatabaseHelper.instance.database;
        AppLogger.db('Initializing local EvaluatorRepository...');
        return EvaluatorRepositoryImpl.local(EvaluatorLocalDataSource(db));
      } else {
        AppLogger.info('Initializing remote EvaluatorRepository...');
        return EvaluatorRepositoryImpl.remote(EvaluatorRemoteDataSource());
      }
    } catch (e, s) {
      AppLogger.error('EvaluatorRepository initialization failed', e, s);
      rethrow;
    }
  }
}

final evaluatorRepositoryProvider =
AsyncNotifierProvider<EvaluatorRepositoryNotifier, EvaluatorRepository>(
  EvaluatorRepositoryNotifier.new,
);


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\application\evaluator_secure_service.dart ===
import 'dart:convert';
import 'package:crypto/crypto.dart';
import '../../../core/utils/encryption_helper.dart';
import '../data/evaluator_model.dart';

class EvaluatorSecureService {
  static EvaluatorModel encrypt(EvaluatorModel model) {
    return model.copyWith(
      name: EncryptionHelper.encryptText(model.name),
      surname: EncryptionHelper.encryptText(model.surname),
      email: EncryptionHelper.encryptText(model.email),
      birthDate: EncryptionHelper.encryptText(model.birthDate),
      specialty: EncryptionHelper.encryptText(model.specialty),
      cpfOrNif: EncryptionHelper.encryptText(model.cpfOrNif),
      username: EncryptionHelper.encryptText(model.username),
      password: hash(model.password),
    );
  }

  static EvaluatorModel decrypt(EvaluatorModel model) {
    return model.copyWith(
      name: EncryptionHelper.decryptText(model.name),
      surname: EncryptionHelper.decryptText(model.surname),
      email: EncryptionHelper.decryptText(model.email),
      birthDate: EncryptionHelper.decryptText(model.birthDate),
      specialty: EncryptionHelper.decryptText(model.specialty),
      cpfOrNif: EncryptionHelper.decryptText(model.cpfOrNif),
      username: EncryptionHelper.decryptText(model.username),
    );
  }

  static String hash(String input) {
    return sha256.convert(utf8.encode(input)).toString();
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\data\current_user_constants.dart ===
const scriptCreateTableCurrentUser = '''
CREATE TABLE current_user (
  evaluator_id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  surname TEXT NOT NULL,
  email TEXT NOT NULL,
  birth_date TEXT,
  specialty TEXT,
  cpf TEXT,
  username TEXT,
  password TEXT,
  first_login INTEGER NOT NULL DEFAULT 1,
  is_admin INTEGER NOT NULL DEFAULT 0
)
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\data\evaluator_constants.dart ===
import '../../../core/constants/database_constants.dart';

class EvaluatorFields {
  static const id = "evaluator_id";
  static const name = "name";
  static const surname = "surname";
  static const email = "email";
  static const birthDate = "birth_date";
  static const specialty = "specialty";
  static const cpf = "cpf";
  static const username = "username";
  static const password = "password";
  static const firstLogin = "first_login";
  static const isAdmin = "is_admin";

  static const all = [
    id,
    name,
    surname,
    email,
    birthDate,
    specialty,
    cpf,
    username,
    password,
    firstLogin,
    isAdmin,
  ];
}

const scriptCreateTableEvaluators = '''
CREATE TABLE ${Tables.evaluators} (
  ${EvaluatorFields.id} INTEGER PRIMARY KEY AUTOINCREMENT,
  ${EvaluatorFields.name} TEXT NOT NULL,
  ${EvaluatorFields.surname} TEXT NOT NULL,
  ${EvaluatorFields.email} TEXT NOT NULL,
  ${EvaluatorFields.birthDate} TIMESTAMP,
  ${EvaluatorFields.specialty} TEXT,
  ${EvaluatorFields.cpf} TEXT,
  ${EvaluatorFields.username} TEXT NOT NULL UNIQUE,
  ${EvaluatorFields.password} TEXT NOT NULL DEFAULT '0000',
  ${EvaluatorFields.firstLogin} INTEGER NOT NULL DEFAULT 0,
  ${EvaluatorFields.isAdmin} INTEGER NOT NULL DEFAULT 0
);
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\data\evaluator_local_datasource.dart ===

import 'package:sqflite_common/sqlite_api.dart';
import '../../../core/constants/database_constants.dart';
import '../../../core/logger/app_logger.dart';
import '../../../core/utils/encryption_helper.dart';
import '../application/evaluator_secure_service.dart';
import 'evaluator_model.dart';
import 'evaluator_constants.dart';

class EvaluatorLocalDataSource {
  final Database _db;
  EvaluatorLocalDataSource(this._db);

  /// Fetch all evaluators
  Future<List<EvaluatorModel>> getAll() async {
    AppLogger.db('[EVALUATOR] Fetching all evaluators');
    final result = await _db.query(Tables.evaluators);
    return result.map(EvaluatorModel.fromMap).toList();
  }

  /// Insert evaluator (replace on conflict)
  Future<void> insert(EvaluatorModel evaluator) async {
    AppLogger.db('[EVALUATOR] Inserting evaluator: ${evaluator.email}');
    await _db.insert(
      Tables.evaluators,
      evaluator.toMap(),
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
  }

  /// Get evaluator by ID
  Future<EvaluatorModel?> getById(int id) async {
    final result = await _db.query(
      Tables.evaluators,
      where: '${EvaluatorFields.id} = ?',
      whereArgs: [id],
      limit: 1,
    );
    return result.isNotEmpty ? EvaluatorModel.fromMap(result.first) : null;
  }

  Future<EvaluatorModel?> getFirstEvaluator() async {
    final result = await _db.query(
      Tables.evaluators,
      orderBy: '${EvaluatorFields.id} ASC',
      limit: 1,
    );
    return result.isNotEmpty ? EvaluatorModel.fromMap(result.first) : null;
  }


  /// ‚úÖ NEW: Check if there is any evaluator admin (legacy support)
  Future<bool> hasAnyEvaluatorAdmin() async {
    AppLogger.db('[EVALUATOR] Checking if any admin evaluator exists...');
    final result = await _db.query(
      Tables.evaluators,
      where: '${EvaluatorFields.isAdmin} = ?',
      whereArgs: [1],
      limit: 1,
    );
    return result.isNotEmpty;
  }

  /// Delete evaluator
  Future<int> deleteById(int id) async {
    return await _db.delete(
      Tables.evaluators,
      where: '${EvaluatorFields.id} = ?',
      whereArgs: [id],
    );
  }

  Future<bool> existsByEmail(String email) async {
    AppLogger.db('[EVALUATOR] Checking if evaluator exists for email: $email');
    try {
      final result = await _db.query(
        Tables.evaluators,
        where: '${EvaluatorFields.email} = ?',
        whereArgs: [email],
        limit: 1,
      );
      final exists = result.isNotEmpty;
      AppLogger.db('[EVALUATOR] existsByEmail($email) ‚Üí $exists');
      return exists;
    } catch (e, s) {
      AppLogger.error('[EVALUATOR] Error checking existsByEmail', e, s);
      return false;
    }
  }



  Future<EvaluatorModel?> login(String username, String password) async {
    final encryptedUsername = EncryptionHelper.encryptText(username);
    final hashedPassword = EvaluatorSecureService.hash(password);

    final result = await _db.query(
      Tables.evaluators,
      where: '${EvaluatorFields.username} = ? AND ${EvaluatorFields.password} = ?',
      whereArgs: [encryptedUsername, hashedPassword],
      limit: 1,
    );

    return result.isNotEmpty ? EvaluatorModel.fromMap(result.first) : null;
  }

}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\data\evaluator_model.dart ===
import 'package:segundo_cogni/features/evaluator/domain/evaluator_registration_data.dart';
import '../../../core/utils/encryption_helper.dart';
import '../domain/evaluator_entity.dart';
import 'evaluator_constants.dart';

class EvaluatorModel extends EvaluatorEntity {
  const EvaluatorModel({
    super.evaluatorId,
    required super.name,
    required super.surname,
    required super.email,
    required super.birthDate,
    required super.specialty,
    required super.cpfOrNif,
    required super.username,
    required super.password,
    super.firstLogin = true,
  });

  factory EvaluatorModel.fromMap(Map<String, dynamic> map) =>
      EvaluatorModel(
        evaluatorId: map[EvaluatorFields.id] as int?,
        name: map[EvaluatorFields.name],
        surname: map[EvaluatorFields.surname],
        email: map[EvaluatorFields.email],
        birthDate: map[EvaluatorFields.birthDate],
        specialty: map[EvaluatorFields.specialty],
        cpfOrNif: map[EvaluatorFields.cpf],
        username: map[EvaluatorFields.username],
        password: map[EvaluatorFields.password],
        firstLogin: (map[EvaluatorFields.firstLogin] as int) == 1,
      );

  Map<String, dynamic> toMap() =>
      {
        EvaluatorFields.id: evaluatorId,
        EvaluatorFields.name: name,
        EvaluatorFields.surname: surname,
        EvaluatorFields.email: email,
        EvaluatorFields.birthDate: birthDate,
        EvaluatorFields.specialty: specialty,
        EvaluatorFields.cpf: cpfOrNif,
        EvaluatorFields.username: username,
        EvaluatorFields.password: password,
        EvaluatorFields.firstLogin: firstLogin ? 1 : 0,
      };

  Map<String, dynamic> toJson() =>
      {
        'evaluator_id': evaluatorId,
        'name': name,
        'surname': surname,
        'email': email,
        'birthDate': birthDate,
        'specialty': specialty,
        'cpfOrNif': cpfOrNif,
        'username': username,
        'password': password,
        'firstLogin': firstLogin,
      };

  factory EvaluatorModel.fromEntity(EvaluatorEntity entity) =>
      EvaluatorModel(
        evaluatorId: entity.evaluatorId,
        name: entity.name,
        surname: entity.surname,
        email: entity.email,
        birthDate: entity.birthDate,
        specialty: entity.specialty,
        cpfOrNif: entity.cpfOrNif,
        username: entity.username,
        password: entity.password,
        firstLogin: entity.firstLogin,
      );

  factory EvaluatorModel.fromDTO(EvaluatorRegistrationData dto) {
    return EvaluatorModel(
      name: dto.name,
      surname: dto.surname,
      email: dto.email,
      birthDate: dto.birthDate,
      specialty: dto.specialty,
      cpfOrNif: dto.cpf,
      username: dto.username,
      password: dto.password,
      firstLogin: dto.firstLogin,
    );
  }

  EvaluatorModel encrypted() {
    return EvaluatorModel(
      evaluatorId: evaluatorId,
      name: EncryptionHelper.encryptText(name),
      surname: EncryptionHelper.encryptText(surname),
      email: EncryptionHelper.encryptText(email),
      birthDate: EncryptionHelper.encryptText(birthDate),
      specialty: EncryptionHelper.encryptText(specialty),
      cpfOrNif: EncryptionHelper.encryptText(cpfOrNif),
      username: EncryptionHelper.encryptText(username),
      password: password,
      // already hashed
      firstLogin: firstLogin,
    );
  }

  static EvaluatorModel decrypt(EvaluatorModel model) {
    return model.copyWith(
      name: EncryptionHelper.decryptText(model.name),
      surname: EncryptionHelper.decryptText(model.surname),
      email: EncryptionHelper.decryptText(model.email),
      birthDate: EncryptionHelper.decryptText(model.birthDate),
      specialty: EncryptionHelper.decryptText(model.specialty),
      cpfOrNif: EncryptionHelper.decryptText(model.cpfOrNif),
      username: EncryptionHelper.decryptText(model.username),
      password: model.password,
    );
  }


  EvaluatorModel copyWith({
    int? evaluatorId,
    String? name,
    String? surname,
    String? email,
    String? birthDate,
    String? specialty,
    String? cpfOrNif,
    String? username,
    String? password,
    bool? firstLogin,
  }) {
    return EvaluatorModel(
      evaluatorId: evaluatorId ?? this.evaluatorId,
      name: name ?? this.name,
      surname: surname ?? this.surname,
      email: email ?? this.email,
      birthDate: birthDate ?? this.birthDate,
      specialty: specialty ?? this.specialty,
      cpfOrNif: cpfOrNif ?? this.cpfOrNif,
      username: username ?? this.username,
      password: password ?? this.password,
      firstLogin: firstLogin ?? this.firstLogin,
    );
  }

}

=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\data\evaluator_model_extensions.dart ===
import 'dart:convert';
import 'package:crypto/crypto.dart';
import 'package:segundo_cogni/core/utils/encryption_helper.dart';
import 'evaluator_model.dart';

extension EvaluatorModelSecurity on EvaluatorModel {
  EvaluatorModel encryptedAndHashed() {
    return EvaluatorModel(
      evaluatorId: evaluatorId,
      name: EncryptionHelper.encryptText(name),
      surname: EncryptionHelper.encryptText(surname),
      email: EncryptionHelper.encryptText(email),
      birthDate: EncryptionHelper.encryptText(birthDate),
      specialty: EncryptionHelper.encryptText(specialty),
      cpfOrNif: EncryptionHelper.encryptText(cpfOrNif),
      username: EncryptionHelper.encryptText(username),
      password: _hash(password),
      firstLogin: firstLogin,
    );
  }

  static String _hash(String input) =>
      sha256.convert(utf8.encode(input)).toString();
}

extension EvaluatorModelDecryption on EvaluatorModel {
  EvaluatorModel decrypted() {
    return EvaluatorModel(
      evaluatorId: evaluatorId,
      name: EncryptionHelper.decryptText(name),
      surname: EncryptionHelper.decryptText(surname),
      email: EncryptionHelper.decryptText(email),
      birthDate: EncryptionHelper.decryptText(birthDate),
      specialty: EncryptionHelper.decryptText(specialty),
      cpfOrNif: EncryptionHelper.decryptText(cpfOrNif),
      username: EncryptionHelper.decryptText(username),
      password: password, // leave hashed
      firstLogin: firstLogin,
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\data\evaluator_remote_datasource.dart ===
import 'dart:convert';
import 'package:http/http.dart' as http;
import '../../../core/logger/app_logger.dart';
import 'evaluator_model.dart';

class EvaluatorRemoteDataSource {
  final String baseUrl = 'https://api.example.com/evaluators';

  Future<List<EvaluatorModel>> fetchAllEvaluators() async {
    final url = Uri.parse(baseUrl);
    AppLogger.info('HTTP GET ‚Üí $url');
    try {
      final response = await http.get(url);
      AppLogger.info('HTTP ${response.statusCode} ‚Üê $url');
      if (response.statusCode == 200) {
        final List<dynamic> data = jsonDecode(response.body);
        return data.map((e) => EvaluatorModel.fromMap(e)).toList();
      } else {
        AppLogger.warning('Failed to fetch evaluators: ${response.body}');
        return [];
      }
    } catch (e, s) {
      AppLogger.error('Error fetching evaluators from API', e, s);
      return [];
    }
  }

  Future<void> createEvaluator(EvaluatorModel evaluator) async {
    final url = Uri.parse(baseUrl);
    final body = jsonEncode(evaluator.toMap());
    AppLogger.info('HTTP POST ‚Üí $url | body: $body');
    try {
      final response = await http.post(
        url,
        headers: {'Content-Type': 'application/json'},
        body: body,
      );
      AppLogger.info('HTTP ${response.statusCode} ‚Üê $url');
      if (response.statusCode >= 400) {
        AppLogger.warning('Error creating evaluator: ${response.body}');
      }
    } catch (e, s) {
      AppLogger.error('HTTP POST failed for evaluator ${evaluator.email}', e, s);
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\data\evaluator_repository_impl.dart ===
import '../../../core/logger/app_logger.dart';
import '../domain/evaluator_repository.dart';
import '../domain/evaluator_registration_data.dart';
import 'evaluator_local_datasource.dart';
import 'evaluator_remote_datasource.dart';
import 'evaluator_model.dart';

class EvaluatorRepositoryImpl implements EvaluatorRepository {
  final EvaluatorLocalDataSource? _local;
  final EvaluatorRemoteDataSource? _remote;
  final bool _isLocal;

  EvaluatorRepositoryImpl.local(this._local)
      : _remote = null,
        _isLocal = true {
    AppLogger.info('[REPO] EvaluatorRepositoryImpl running in LOCAL mode');
  }

  EvaluatorRepositoryImpl.remote(this._remote)
      : _local = null,
        _isLocal = false {
    AppLogger.info('[REPO] EvaluatorRepositoryImpl running in REMOTE mode');
  }

  String get _mode => _isLocal ? 'LOCAL' : 'REMOTE';

  Future<List<EvaluatorModel>> getAllEvaluators() async {
    AppLogger.info('[REPO] Fetching all evaluators ($_mode)');
    try {
      if (_isLocal) {
        final list = await _local!.getAll();
        AppLogger.db('Fetched ${list.length} evaluators from local DB');
        return list;
      } else {
        final list = await _remote!.fetchAllEvaluators();
        AppLogger.info('Fetched ${list.length} evaluators from API');
        return list;
      }
    } catch (e, s) {
      AppLogger.error('[REPO] Error fetching all evaluators ($_mode)', e, s);
      rethrow;
    }
  }

  Future<void> addEvaluator(EvaluatorModel evaluator) async {
    AppLogger.info('[REPO] Adding evaluator ${evaluator.email} ($_mode)');
    try {
      if (_isLocal) {
        await _local!.insert(evaluator);
        AppLogger.db('[REPO] Evaluator inserted into local DB');
      } else {
        await _remote!.createEvaluator(evaluator);
        AppLogger.info('[REPO] Evaluator created remotely');
      }
    } catch (e, s) {
      AppLogger.error('[REPO] Failed to add evaluator', e, s);
      rethrow;
    }
  }

  @override
  Future<void> insertEvaluator(EvaluatorRegistrationData data) async {
    final model = EvaluatorModel.fromDTO(data);
    await _local!.insert(model);
  }

  @override
  Future<bool> hasAnyEvaluatorAdmin() async {
    return await _local!.hasAnyEvaluatorAdmin();
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\domain\evaluator_entity.dart ===
class EvaluatorEntity {
  final int? evaluatorId;
  final String name;
  final String surname;
  final String email;
  final String birthDate;
  final String specialty;
  final String cpfOrNif;
  final String username;
  final String password;
  final bool firstLogin;

  const EvaluatorEntity({
    this.evaluatorId,
    required this.name,
    required this.surname,
    required this.email,
    required this.birthDate,
    required this.specialty,
    required this.cpfOrNif,
    required this.username,
    required this.password,
    this.firstLogin = true,
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\domain\evaluator_registration_data.dart ===
class EvaluatorRegistrationData {
  final String name;
  final String surname;
  final String email;
  final String birthDate;
  final String specialty;
  final String cpf;
  final String username;
  final String password;
  final bool isAdmin;
  final bool firstLogin;

  EvaluatorRegistrationData({
    required this.name,
    required this.surname,
    required this.email,
    required this.birthDate,
    required this.specialty,
    required this.cpf,
    required this.username,
    required this.password,
    this.isAdmin = false,
    this.firstLogin = true,
  });

  Map<String, dynamic> toMap() => {
    'name': name,
    'surname': surname,
    'email': email,
    'birthDate': birthDate,
    'specialty': specialty,
    'cpfOrNif': cpf,
    'username': username,
    'password': password,
    'isAdmin': isAdmin,
    'firstLogin': firstLogin,
  };
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\domain\evaluator_repository.dart ===
import 'evaluator_registration_data.dart';

abstract class EvaluatorRepository {
  Future<void> insertEvaluator(EvaluatorRegistrationData data);
  Future<bool> hasAnyEvaluatorAdmin();
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\presentation\evaluator_registration_form.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:intl/intl.dart';
import 'package:syncfusion_flutter_datepicker/datepicker.dart';
import 'package:go_router/go_router.dart';

import '../../../../core/logger/app_logger.dart';
import '../../../../core/theme/app_colors.dart';
import '../domain/evaluator_registration_data.dart';
import 'evaluator_registration_provider.dart';

class EvaluatorRegistrationForm extends HookConsumerWidget {
  const EvaluatorRegistrationForm({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    AppLogger.nav('Opened EvaluatorRegistrationForm');

    final formKey = useMemoized(() => GlobalKey<FormState>());
    final nameController = useTextEditingController();
    final surnameController = useTextEditingController();
    final emailController = useTextEditingController();
    final usernameController = useTextEditingController();
    final cpfController = useTextEditingController();
    final passwordController = useTextEditingController();
    final confirmPasswordController = useTextEditingController();
    final specialtyController = useTextEditingController();

    final selectedDate = useState<DateTime?>(null);
    final showPassword = useState(false);
    final showConfirmPassword = useState(false);
    final manualUsername = useState(false);
    final isDateExpanded = useState(false);
    final isRedirecting = useState(false);

    final state = ref.watch(evaluatorRegistrationProvider);
    final notifier = ref.read(evaluatorRegistrationProvider.notifier);

    // auto-generate username
    useEffect(() {
      void listener() {
        if (!manualUsername.value) {
          final name = nameController.text.trim();
          final surname = surnameController.text.trim();
          if (name.isNotEmpty && surname.isNotEmpty) {
            usernameController.text =
            "${name.toLowerCase()}_${surname.toLowerCase()}";
          } else {
            usernameController.clear();
          }
        }
      }

      nameController.addListener(listener);
      surnameController.addListener(listener);
      return () {
        nameController.removeListener(listener);
        surnameController.removeListener(listener);
      };
    }, [manualUsername.value]);

    // Listen for registration result
    ref.listen<AsyncValue<EvaluatorRegistrationState>>(
      evaluatorRegistrationProvider,
          (prev, next) {
        next.whenData((value) async {
          if (value == EvaluatorRegistrationState.success) {
            AppLogger.info('Evaluator registered successfully ‚Äî redirecting');
            isRedirecting.value = true;

            displayInfoBar(
              context,
              builder: (ctx, close) => InfoBar(
                title: const Text("Avaliador registrado!"),
                content:
                const Text("Voc√™ ser√° redirecionado para o home!"),
                severity: InfoBarSeverity.success,
                isLong: true,
                onClose: close,
              ),
            );

            await Future.delayed(const Duration(seconds: 2));
            if (context.mounted) {
              AppLogger.nav('Navigating to /home after registration');
              context.go('/login');
            }
          }
        });
      },
    );

    Future<void> _submit() async {
      if (!formKey.currentState!.validate() || selectedDate.value == null) {
        AppLogger.warning('Registration form validation failed');
        return;
      }

      final data = EvaluatorRegistrationData(
        name: nameController.text,
        surname: surnameController.text,
        email: emailController.text,
        birthDate: DateFormat('yyyy-MM-dd').format(selectedDate.value!),
        cpf: cpfController.text,
        username: usernameController.text,
        password: passwordController.text,
        specialty: specialtyController.text,
        isAdmin: false,
      );

      AppLogger.info('Submitting evaluator registration for ${data.email}');
      await notifier.registerEvaluator(data);
    }

    return Container(
      padding: const EdgeInsets.all(24),
      decoration: BoxDecoration(
        gradient: const LinearGradient(
          colors: [Color(0xFF141E30), Color(0xFF243B55)],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        borderRadius: BorderRadius.circular(16),
      ),
      child: Form(
        key: formKey,
        child: ListView(
          shrinkWrap: true,
          children: [
            const Text(
              "Registro de Administrador",
              textAlign: TextAlign.center,
              style: TextStyle(
                fontSize: 28,
                fontWeight: FontWeight.bold,
                color: AppColors.softWhite,
              ),
            ),
            const SizedBox(height: 24),

            // name + surname
            Row(
              children: [
                Expanded(child: _buildTextField("Nome", nameController)),
                const SizedBox(width: 12),
                Expanded(child: _buildTextField("Sobrenome", surnameController)),
              ],
            ),

            // email + cpf
            Row(
              children: [
                Expanded(child: _buildTextField("Email", emailController)),
                const SizedBox(width: 12),
                Expanded(child: _buildTextField("CPF/NIF", cpfController)),
              ],
            ),

            // username + checkbox
            Padding(
              padding: const EdgeInsets.only(bottom: 16),
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.end,
                children: [
                  Expanded(
                    child: InfoLabel(
                      label: "Usu√°rio",
                      child: TextFormBox(
                        controller: usernameController,
                        enabled: manualUsername.value,
                        validator: (v) =>
                        v!.isEmpty ? "Campo obrigat√≥rio" : null,
                      ),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Padding(
                    padding: const EdgeInsets.only(bottom: 8),
                    child: Checkbox(
                      content: const Text("Definir usu√°rio manualmente"),
                      checked: manualUsername.value,
                      onChanged: (v) {
                        manualUsername.value = v ?? false;
                        AppLogger.debug(
                            'Manual username mode: ${manualUsername.value}');
                      },
                    ),
                  ),
                ],
              ),
            ),

            // password + confirm password
            Row(
              children: [
                Expanded(
                  child: _buildPasswordField(
                    "Senha",
                    passwordController,
                    showPassword,
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: _buildPasswordField(
                    "Confirmar Senha",
                    confirmPasswordController,
                    showConfirmPassword,
                    confirm: passwordController,
                  ),
                ),
              ],
            ),

            const SizedBox(height: 16),

            // date picker
            InfoLabel(
              label: "Data de Nascimento",
              child: Expander(
                key: ValueKey(isDateExpanded.value),
                initiallyExpanded: isDateExpanded.value,
                onStateChanged: (open) =>
                isDateExpanded.value = open,
                header: Text(
                  selectedDate.value != null
                      ? DateFormat('dd/MM/yyyy')
                      .format(selectedDate.value!)
                      : "Selecionar data",
                ),
                content: SfDateRangePicker(
                  onSelectionChanged: (args) {
                    selectedDate.value = args.value;
                    isDateExpanded.value = false;
                    AppLogger.debug(
                        'Selected birth date: ${selectedDate.value}');
                  },
                  selectionMode: DateRangePickerSelectionMode.single,
                  initialSelectedDate: selectedDate.value,
                  showNavigationArrow: true,
                  todayHighlightColor: AppColors.primary,
                  selectionColor: AppColors.primary,
                ),
              ),
            ),

            const SizedBox(height: 16),
            _buildTextField("Especialidade", specialtyController),
            const SizedBox(height: 24),

            FilledButton(
              style: ButtonStyle(
                backgroundColor: ButtonState.all(AppColors.primary),
              ),
              onPressed: state.isLoading || isRedirecting.value ? null : _submit,
              child: (state.isLoading || isRedirecting.value)
                  ? const ProgressRing()
                  : const Text("Registrar"),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildTextField(String label, TextEditingController controller) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12),
      child: InfoLabel(
        label: label,
        child: TextFormBox(
          controller: controller,
          validator: (v) => v!.isEmpty ? "Campo obrigat√≥rio" : null,
        ),
      ),
    );
  }

  Widget _buildPasswordField(String label, TextEditingController controller,
      ValueNotifier<bool> show, {TextEditingController? confirm}) {
    return InfoLabel(
      label: label,
      child: TextFormBox(
        controller: controller,
        obscureText: !show.value,
        placeholder: label == "Senha"
            ? "Digite a senha"
            : "Repita a senha",
        validator: (v) {
          if (v == null || v.isEmpty) return "Campo obrigat√≥rio";
          if (label == "Confirmar Senha" &&
              v != confirm?.text) {
            return "As senhas n√£o coincidem";
          }
          if (label == "Senha" && v.length < 6) {
            return "M√≠nimo 6 caracteres";
          }
          return null;
        },
        suffix: IconButton(
          icon: Icon(show.value
              ? FluentIcons.hide3
              : FluentIcons.view),
          onPressed: () => show.value = !show.value,
        ),
      ),
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\presentation\evaluator_registration_provider.dart ===
import 'package:hooks_riverpod/hooks_riverpod.dart';
import '../../../core/logger/app_logger.dart';
import '../application/evaluator_notifier.dart';
import '../domain/evaluator_registration_data.dart';
import '../domain/evaluator_repository.dart';

enum EvaluatorRegistrationState { initial, loading, success, error }

class EvaluatorRegistrationNotifier
    extends AsyncNotifier<EvaluatorRegistrationState> {
  late final EvaluatorRepository _repository;

  @override
  Future<EvaluatorRegistrationState> build() async {
    _repository = await ref.watch(evaluatorRepositoryProvider.future);
    AppLogger.info('EvaluatorRegistrationNotifier initialized');
    return EvaluatorRegistrationState.initial;
  }

  Future<void> registerEvaluator(EvaluatorRegistrationData data) async {
    AppLogger.info('Starting evaluator registration for ${data.email}');
    state = const AsyncValue.loading();

    try {
      await _repository.insertEvaluator(data);
      AppLogger.info('Evaluator ${data.email} registered successfully');
      state = const AsyncValue.data(EvaluatorRegistrationState.success);
    } catch (e, s) {
      AppLogger.error('Error registering evaluator ${data.email}', e, s);
      state = const AsyncValue.data(EvaluatorRegistrationState.error);
    }
  }
}

final evaluatorRegistrationProvider =
AsyncNotifierProvider<EvaluatorRegistrationNotifier,
    EvaluatorRegistrationState>(
  EvaluatorRegistrationNotifier.new,
);


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\presentation\evaluator_registration_screen.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import '../../../../core/logger/app_logger.dart';
import '../../../../core/theme/app_colors.dart';
import 'evaluator_registration_form.dart';

class EvaluatorRegistrationScreen extends StatelessWidget {
  const EvaluatorRegistrationScreen({super.key});

  @override
  Widget build(BuildContext context) {
    AppLogger.nav('Opened EvaluatorRegistrationScreen');
    return NavigationView(
      content: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [
              AppColors.midnightBlue,
              AppColors.deepSeaBlue,
              AppColors.steelBlue,
            ],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: Center(
          child: Padding(
            padding: const EdgeInsets.all(24),
            child: ConstrainedBox(
              constraints: const BoxConstraints(maxWidth: 700),
              child: const EvaluatorRegistrationForm(),
            ),
          ),
        ),
      ),
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\evaluator\presentation\providers\evaluator_provider.dart ===
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../../core/database_helper.dart';
import '../../data/evaluator_local_datasource.dart';
import '../../data/evaluator_model.dart';

final currentEvaluatorProvider = FutureProvider<EvaluatorModel?>((ref) async {
  final db = await DatabaseHelper.instance.database;
  final ds = EvaluatorLocalDataSource(db);
  return await ds.getFirstEvaluator();
});


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\home\home_screen.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

import '../../core/database_helper.dart';
import '../../providers/providers.dart';
import '../auth/data/auth_local_datasource.dart';
import '../auth/data/auth_repository_impl.dart';
import '../participant/presentation/create_participant_screen.dart';

class HomeScreen extends HookConsumerWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final user = ref.watch(currentUserProvider);

    return NavigationView(
      appBar: const NavigationAppBar(
        title: Text('CogniVoice Home'),
      ),
      pane: NavigationPane(
        selected: 0,
        onChanged: (index) {
          // Optional: Add logic for selected index
        },
        displayMode: PaneDisplayMode.auto,
        items: [
          PaneItem(
            icon: const Icon(FluentIcons.home),
            title: const Text('Dashboard'),
            body: const DashboardContent(),
          ),
          PaneItem(
            icon: const Icon(FluentIcons.contact),
            title: const Text('Participantes'),
            body: const Placeholder(),
          ),
          PaneItem(
            icon: const Icon(FluentIcons.add_friend),
            title: const Text('Criar Paciente'),
            body: const CreatePatientScreen(),
          ),
        ],

        footerItems: [
          PaneItemSeparator(),
          PaneItem(
            icon: const Icon(FluentIcons.sign_out),
            title: const Text('Sair'),
            onTap: () async {
              final repository = AuthRepositoryImpl(AuthLocalDataSource(
                await DatabaseHelper.instance.database,
              ));

              await repository.signOut(); // üî• clears DB

              ref.read(currentUserProvider.notifier).setUser(null);
              if (context.mounted) context.go('/login');
            },

            body: const SizedBox.shrink(), // Required, can't be null
          ),
        ],
      ),
    );
  }
}

class DashboardContent extends StatelessWidget {
  const DashboardContent({super.key});

  @override
  Widget build(BuildContext context) {
    return ScaffoldPage.scrollable(
      header: PageHeader(
        title: Text(
          'Bem-vindo!',
          style: FluentTheme.of(context).typography.title,
        ),
      ),
      children: const [
        Text('Aqui √© o conte√∫do principal do dashboard.'),
      ],
    );
  }
}

class ParticipantsPage extends StatelessWidget {
  const ParticipantsPage({super.key});

  @override
  Widget build(BuildContext context) {
    return const ScaffoldPage(
      content: Text('Lista de participantes (em breve)'),
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module\data\module_constants.dart ===
import '../../../core/constants/database_constants.dart';

class ModuleFields {
  static const id = 'module_id';
  static const title = 'title';

  static const values = [id, title];
}

const scriptCreateTableModules = '''
CREATE TABLE ${Tables.modules} (
  ${ModuleFields.id} INTEGER PRIMARY KEY AUTOINCREMENT,
  ${ModuleFields.title} TEXT NOT NULL
)
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module\data\module_local_datasource.dart ===
import 'package:sqflite_common/sqlite_api.dart';
import '../../../core/constants/database_constants.dart';
import '../../../core/database/base_database_helper.dart';
import '../../../core/logger/app_logger.dart';
import 'module_constants.dart';
import 'module_model.dart';

class ModuleLocalDataSource {
  final BaseDatabaseHelper dbHelper;
  ModuleLocalDataSource({required this.dbHelper});

  Future<Database> get _db async => dbHelper.database;

  Future<int?> insertModule(ModuleModel module) async {
    AppLogger.db('Inserting module: ${module.title}');
    try {
      final db = await _db;
      final id = await db.insert(
        Tables.modules,
        module.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
      AppLogger.db('Module inserted successfully (id=$id)');
      return id;
    } catch (e, s) {
      AppLogger.error('Error inserting module ${module.title}', e, s);
      return null;
    }
  }

  Future<List<ModuleModel>> getAllModules() async {
    final db = await _db;
    final maps = await db.query(Tables.modules);
    return maps.map(ModuleModel.fromMap).toList();
  }

  Future<ModuleModel?> getModuleById(int id) async {
    final db = await _db;
    final result = await db.query(
      Tables.modules,
      where: '${ModuleFields.id} = ?',
      whereArgs: [id],
    );
    return result.isNotEmpty ? ModuleModel.fromMap(result.first) : null;
  }

  Future<ModuleModel?> getModuleByTitle(String title) async {
    final db = await _db;
    final result = await db.query(
      Tables.modules,
      where: '${ModuleFields.title} = ?',
      whereArgs: [title],
    );
    return result.isNotEmpty ? ModuleModel.fromMap(result.first) : null;
  }

  Future<int> updateModule(ModuleModel module) async {
    final db = await _db;
    return db.update(
      Tables.modules,
      module.toMap(),
      where: '${ModuleFields.id} = ?',
      whereArgs: [module.moduleID],
    );
  }

  Future<int> deleteModule(int id) async {
    final db = await _db;
    return db.delete(
      Tables.modules,
      where: '${ModuleFields.id} = ?',
      whereArgs: [id],
    );
  }

  Future<int> getNumberOfModules() async {
    final db = await _db;
    final result = await db.rawQuery('SELECT COUNT(*) AS count FROM ${Tables.modules}');
    return (result.first['count'] as int?) ?? 0;
  }

  Future<bool> exists(String moduleId) async {
    final db = await _db;
    final result = await db.query(
      Tables.modules,
      where: '${ModuleFields.id} = ?',
      whereArgs: [moduleId],
      limit: 1,
    );
    return result.isNotEmpty;
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module\data\module_model.dart ===
import '../../../features/module/domain/module_entity.dart';
import '../../../features/module/data/module_constants.dart';

class ModuleModel extends ModuleEntity {
  const ModuleModel({
    super.moduleID,
    required super.title,
    super.tasks = const [],
  });

  factory ModuleModel.fromMap(Map<String, dynamic> map) {
    return ModuleModel(
      moduleID: map[ModuleFields.id] as int?,
      title: map[ModuleFields.title] as String,
    );
  }

  Map<String, dynamic> toMap() => {
    ModuleFields.id: moduleID,
    ModuleFields.title: title,
  };

  factory ModuleModel.fromEntity(ModuleEntity entity) {
    return ModuleModel(
      moduleID: entity.moduleID,
      title: entity.title,
      tasks: entity.tasks,
    );
  }

  ModuleEntity toEntity() => ModuleEntity(
    moduleID: moduleID,
    title: title,
    tasks: tasks,
  );
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module\data\module_repository_impl.dart ===
import '../../task/data/task_local_datasource.dart';
import '../domain/module_entity.dart';
import '../domain/module_repository.dart';
import 'module_local_datasource.dart';
import 'module_model.dart';

class ModuleRepositoryImpl implements ModuleRepository {
  final ModuleLocalDataSource localDataSource;
  final TaskLocalDataSource taskLocalDataSource;

  ModuleRepositoryImpl({
    required this.localDataSource,
    required this.taskLocalDataSource,
  });

  @override
  Future<int?> insertModule(ModuleEntity module) async {
    final model = ModuleModel.fromEntity(module);
    return await localDataSource.insertModule(model);
  }

  @override
  Future<List<ModuleEntity>> getAllModules() async {
    final modules = await localDataSource.getAllModules();
    return modules.map((m) => m.toEntity()).toList();
  }

  @override
  Future<ModuleEntity?> getModuleById(int id) async {
    final module = await localDataSource.getModuleById(id);
    if (module == null) return null;

    final tasks = await taskLocalDataSource.getTasksByModuleId(id);
    return module.toEntity().copyWith(tasks: tasks);
  }

  @override
  Future<ModuleEntity?> getModuleByTitle(String title) async {
    final module = await localDataSource.getModuleByTitle(title);
    if (module == null) return null;

    final tasks = await taskLocalDataSource.getTasksByModuleId(module.moduleID!);
    return module.toEntity().copyWith(tasks: tasks);
  }


  @override
  Future<int> updateModule(ModuleEntity module) async {
    final model = ModuleModel.fromEntity(module);
    return await localDataSource.updateModule(model);
  }

  @override
  Future<int> deleteModule(int id) async {
    return await localDataSource.deleteModule(id);
  }

  @override
  Future<int> getNumberOfModules() async {
    return await localDataSource.getNumberOfModules();
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module\domain\module_entity.dart ===
import '../../task/domain/task_entity.dart';

class ModuleEntity {
  final int? moduleID;
  final String title;
  final List<TaskEntity> tasks;

  const ModuleEntity({
    this.moduleID,
    required this.title,
    this.tasks = const [],
  });

  Map<String, dynamic> toMap() => {
    'module_id': moduleID,
    'title': title,
  };

  factory ModuleEntity.fromMap(Map<String, dynamic> map) {
    return ModuleEntity(
      moduleID: map['module_id'] as int?,
      title: map['title'] as String,
    );
  }

  ModuleEntity copyWith({
    int? moduleID,
    String? title,
    List<TaskEntity>? tasks,
  }) {
    return ModuleEntity(
      moduleID: moduleID ?? this.moduleID,
      title: title ?? this.title,
      tasks: tasks ?? this.tasks,
    );
  }

  @override
  String toString() => 'ModuleEntity(id: $moduleID, title: $title, tasks: $tasks)';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module\domain\module_repository.dart ===
import 'module_entity.dart';

abstract class ModuleRepository {
  Future<int?> insertModule(ModuleEntity module);
  Future<List<ModuleEntity>> getAllModules();
  Future<ModuleEntity?> getModuleById(int id);
  Future<ModuleEntity?> getModuleByTitle(String title);
  Future<int> updateModule(ModuleEntity module);
  Future<int> deleteModule(int id);
  Future<int> getNumberOfModules();
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module_instance\data\module_instance_constants.dart ===
import '../../../core/constants/database_constants.dart';
import '../../evaluation/data/evaluation_constants.dart';
import '../../module/data/module_constants.dart';

class ModuleInstanceFields {
  static const id = 'module_inst_id';
  static const moduleId = ModuleFields.id;
  static const evaluationId = EvaluationFields.id;
  static const status = 'status';

  static const values = [id, moduleId, evaluationId, status];
}

const scriptCreateTableModuleInstances = '''
CREATE TABLE ${Tables.moduleInstances} (
  ${ModuleInstanceFields.id} INTEGER PRIMARY KEY AUTOINCREMENT,
  ${ModuleInstanceFields.moduleId} INTEGER NOT NULL,
  ${ModuleInstanceFields.evaluationId} INTEGER NOT NULL,
  ${ModuleInstanceFields.status} INT NOT NULL CHECK(${ModuleInstanceFields.status} >= 1 AND ${ModuleInstanceFields.status} <= 3),
  FOREIGN KEY (${ModuleInstanceFields.moduleId}) REFERENCES ${Tables.modules}(${ModuleFields.id}),
  FOREIGN KEY (${ModuleInstanceFields.evaluationId}) REFERENCES ${Tables.evaluations}(${EvaluationFields.id})
)
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module_instance\data\module_instance_local_datasource.dart ===
import 'package:sqflite_common/sqlite_api.dart';
import '../../../core/constants/database_constants.dart';
import '../../../core/constants/enums/progress_status.dart';
import '../../../core/database/base_database_helper.dart';
import '../../../core/logger/app_logger.dart';
import 'module_instance_constants.dart';
import 'module_instance_model.dart';

class ModuleInstanceLocalDataSource {
  final BaseDatabaseHelper dbHelper;

  ModuleInstanceLocalDataSource({required this.dbHelper});

  Future<Database> get _db async => dbHelper.database;

  Future<int?> insertModuleInstance(ModuleInstanceModel instance) async {
    AppLogger.db('Inserting module instance for evaluationId=${instance.evaluationId}');
    try {
      final db = await _db;
      final id = await db.insert(
        Tables.moduleInstances,
        instance.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
      AppLogger.db('Module instance inserted (id=$id)');
      return id;
    } catch (e, s) {
      AppLogger.error('Error inserting module instance', e, s);
      return null;
    }
  }

  Future<ModuleInstanceModel?> getModuleInstanceById(int id) async {
    AppLogger.db('Fetching module instance ID=$id');
    try {
      final db = await _db;
      final maps = await db.query(
        Tables.moduleInstances,
        where: '${ModuleInstanceFields.id} = ?',
        whereArgs: [id],
      );
      return maps.isNotEmpty ? ModuleInstanceModel.fromMap(maps.first) : null;
    } catch (e, s) {
      AppLogger.error('Error fetching module instance ID=$id', e, s);
      return null;
    }
  }

  Future<List<ModuleInstanceModel>> getAllModuleInstances() async {
    AppLogger.db('Fetching all module instances');
    try {
      final db = await _db;
      final maps = await db.query(Tables.moduleInstances);
      AppLogger.db('Fetched ${maps.length} module instances');
      return maps.map(ModuleInstanceModel.fromMap).toList();
    } catch (e, s) {
      AppLogger.error('Error fetching all module instances', e, s);
      return [];
    }
  }

  Future<List<ModuleInstanceModel>> getModuleInstancesByEvaluationId(
      int evaluationId) async {
    AppLogger.db('Fetching module instances by evaluationId=$evaluationId');
    try {
      final db = await _db;
      final maps = await db.query(
        Tables.moduleInstances,
        where: '${ModuleInstanceFields.evaluationId} = ?',
        whereArgs: [evaluationId],
      );
      AppLogger.db('Fetched ${maps.length} instances for evaluationId=$evaluationId');
      return maps.map(ModuleInstanceModel.fromMap).toList();
    } catch (e, s) {
      AppLogger.error('Error fetching instances by evaluationId=$evaluationId', e, s);
      return [];
    }
  }

  Future<int> updateModuleInstance(ModuleInstanceModel instance) async {
    AppLogger.db('Updating module instance ID=${instance.id}');
    try {
      final db = await _db;
      final rows = await db.update(
        Tables.moduleInstances,
        instance.toMap(),
        where: '${ModuleInstanceFields.id} = ?',
        whereArgs: [instance.id],
      );
      AppLogger.db('Updated $rows row(s)');
      return rows;
    } catch (e, s) {
      AppLogger.error('Error updating module instance ID=${instance.id}', e, s);
      return 0;
    }
  }

  Future<int> deleteModuleInstance(int id) async {
    AppLogger.db('Deleting module instance ID=$id');
    try {
      final db = await _db;
      final count = await db.delete(
        Tables.moduleInstances,
        where: '${ModuleInstanceFields.id} = ?',
        whereArgs: [id],
      );
      AppLogger.db('Deleted $count module instance(s)');
      return count;
    } catch (e, s) {
      AppLogger.error('Error deleting module instance ID=$id', e, s);
      return 0;
    }
  }

  Future<int> getCount() async {
    AppLogger.db('Counting module instances');
    try {
      final db = await _db;
      final result = await db
          .rawQuery('SELECT COUNT(*) AS count FROM ${Tables.moduleInstances}');
      final count = (result.first['count'] as int?) ?? 0;
      AppLogger.db('Module instance count: $count');
      return count;
    } catch (e, s) {
      AppLogger.error('Error counting module instances', e, s);
      return 0;
    }
  }

  Future<int> setStatus(int instanceId, ModuleStatus status) async {
    AppLogger.db('Setting status=${status.name} for moduleInstanceId=$instanceId');
    try {
      final db = await _db;
      final rows = await db.update(
        Tables.moduleInstances,
        {ModuleInstanceFields.status: status.numericValue},
        where: '${ModuleInstanceFields.id} = ?',
        whereArgs: [instanceId],
      );
      AppLogger.db('Updated status for $rows row(s)');
      return rows;
    } catch (e, s) {
      AppLogger.error('Error setting status for moduleInstanceId=$instanceId', e, s);
      return 0;
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module_instance\data\module_instance_model.dart ===
import '../../../core/constants/enums/progress_status.dart';
import '../../module_instance/domain/module_instance_entity.dart';
import 'module_instance_constants.dart';

class ModuleInstanceModel extends ModuleInstanceEntity {
  const ModuleInstanceModel({
    super.id,
    required super.moduleId,
    required super.evaluationId,
    required super.status,
    super.module,
  });

  factory ModuleInstanceModel.fromMap(Map<String, dynamic> map) {
    return ModuleInstanceModel(
      id: map[ModuleInstanceFields.id] as int?,
      moduleId: map[ModuleInstanceFields.moduleId] as int,
      evaluationId: map[ModuleInstanceFields.evaluationId] as int,
      status: ModuleStatus.fromValue(map[ModuleInstanceFields.status] as int),
    );
  }

  Map<String, dynamic> toMap() => {
    ModuleInstanceFields.id: id,
    ModuleInstanceFields.moduleId: moduleId,
    ModuleInstanceFields.evaluationId: evaluationId,
    ModuleInstanceFields.status: status.numericValue,
  };

  factory ModuleInstanceModel.fromEntity(ModuleInstanceEntity entity) {
    return ModuleInstanceModel(
      id: entity.id,
      moduleId: entity.moduleId,
      evaluationId: entity.evaluationId,
      status: entity.status,
      module: entity.module,
    );
  }

  ModuleInstanceEntity toEntity() {
    return ModuleInstanceEntity(
      id: id,
      moduleId: moduleId,
      evaluationId: evaluationId,
      status: status,
      module: module,
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module_instance\data\module_instance_repository_impl.dart ===
import '../../../core/constants/enums/progress_status.dart';
import '../domain/module_instance_repository.dart';
import '../domain/module_instance_entity.dart';
import 'module_instance_model.dart';
import 'module_instance_local_datasource.dart';

class ModuleInstanceRepositoryImpl implements ModuleInstanceRepository {
  final ModuleInstanceLocalDataSource localDataSource;

  ModuleInstanceRepositoryImpl({required this.localDataSource});

  @override
  Future<ModuleInstanceEntity?> createModuleInstance(
      ModuleInstanceEntity instance) async {
    final model = ModuleInstanceModel.fromEntity(instance);
    final id = await localDataSource.insertModuleInstance(model);
    if (id == null) return null;
    final created = await localDataSource.getModuleInstanceById(id);
    return created?.toEntity();
  }

  @override
  Future<ModuleInstanceEntity?> getModuleInstanceById(int id) async {
    final model = await localDataSource.getModuleInstanceById(id);
    return model?.toEntity();
  }

  @override
  Future<List<ModuleInstanceEntity>> getAllModuleInstances() async {
    final models = await localDataSource.getAllModuleInstances();
    return models.map((m) => m.toEntity()).toList();
  }

  @override
  Future<List<ModuleInstanceEntity>> getModuleInstancesByEvaluationId(
      int evaluationId) async {
    final models =
    await localDataSource.getModuleInstancesByEvaluationId(evaluationId);
    return models.map((m) => m.toEntity()).toList();
  }

  @override
  Future<int> updateModuleInstance(ModuleInstanceEntity instance) async {
    final model = ModuleInstanceModel.fromEntity(instance);
    return await localDataSource.updateModuleInstance(model);
  }

  @override
  Future<int> deleteModuleInstance(int id) async {
    return await localDataSource.deleteModuleInstance(id);
  }

  @override
  Future<int> getCount() async {
    return await localDataSource.getCount();
  }

  @override
  Future<int> setModuleInstanceStatus(int instanceId, ModuleStatus status) async {
    return await localDataSource.setStatus(instanceId, status);
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module_instance\domain\module_instance_entity.dart ===
import '../../../core/constants/enums/progress_status.dart';
import '../../module/domain/module_entity.dart';

class ModuleInstanceEntity {
  final int? id;
  final int moduleId;
  final int evaluationId;
  final ModuleStatus status;
  final ModuleEntity? module;

  const ModuleInstanceEntity({
    this.id,
    required this.moduleId,
    required this.evaluationId,
    this.status = ModuleStatus.pending,
    this.module,
  });

  ModuleInstanceEntity copyWith({
    int? id,
    int? moduleId,
    int? evaluationId,
    ModuleStatus? status,
    ModuleEntity? module,
  }) {
    return ModuleInstanceEntity(
      id: id ?? this.id,
      moduleId: moduleId ?? this.moduleId,
      evaluationId: evaluationId ?? this.evaluationId,
      status: status ?? this.status,
      module: module ?? this.module,
    );
  }

  @override
  String toString() =>
      'ModuleInstanceEntity(id: $id, moduleId: $moduleId, evaluationId: $evaluationId, status: $status)';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\module_instance\domain\module_instance_repository.dart ===
import '../../../core/constants/enums/progress_status.dart';
import 'module_instance_entity.dart';

abstract class ModuleInstanceRepository {
  Future<ModuleInstanceEntity?> createModuleInstance(ModuleInstanceEntity instance);
  Future<ModuleInstanceEntity?> getModuleInstanceById(int id);
  Future<List<ModuleInstanceEntity>> getAllModuleInstances();
  Future<List<ModuleInstanceEntity>> getModuleInstancesByEvaluationId(int evaluationId);
  Future<int> updateModuleInstance(ModuleInstanceEntity instance);
  Future<int> deleteModuleInstance(int id);
  Future<int> getCount();
  Future<int> setModuleInstanceStatus(int instanceId, ModuleStatus status);
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\participant\data\participant_constants.dart ===
import '../../../core/constants/database_constants.dart';

class ParticipantFields {
  static const id = "participant_id";
  static const name = "name";
  static const surname = "surname";
  static const educationLevel = "education_level";
  static const sex = "sex";
  static const birthDate = "birth_date";
  static const laterality = "laterality";

  static const all = [
    id,
    name,
    surname,
    educationLevel,
    sex,
    birthDate,
    laterality
  ];
}

const scriptCreateTableParticipants = '''
CREATE TABLE ${Tables.participants} (
  ${ParticipantFields.id} INTEGER PRIMARY KEY AUTOINCREMENT,
  ${ParticipantFields.name} TEXT NOT NULL,
  ${ParticipantFields.surname} TEXT NOT NULL,
  ${ParticipantFields.educationLevel} INT CHECK(${ParticipantFields.educationLevel} BETWEEN 1 AND 7),
  ${ParticipantFields.sex} INT CHECK(${ParticipantFields.sex} IN (1, 2)),
  ${ParticipantFields.birthDate} TIMESTAMP,
  ${ParticipantFields.laterality} INT NOT NULL
);
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\participant\data\participant_local_datasource.dart ===
import 'package:sqflite_common/sqlite_api.dart';
import '../../../core/constants/database_constants.dart';
import '../../../core/database/base_database_helper.dart';
import '../../../core/logger/app_logger.dart';
import '../../../core/constants/enums/laterality_enums.dart';
import '../../../core/constants/enums/person_enums.dart';
import '../data/participant_constants.dart';
import '../domain/participant_entity.dart';

class ParticipantLocalDataSource {
  final BaseDatabaseHelper dbHelper;

  ParticipantLocalDataSource({required this.dbHelper});

  Future<Database> get _db async => dbHelper.database;

  Future<int?> insertParticipant(
      DatabaseExecutor txn,
      Map<String, dynamic> data,
      ) async {
    // Make a mutable copy so we don't mutate caller's map.
    final payload = Map<String, dynamic>.from(data);

    // Normalize enums / types to what SQLite understands.

    // laterality: required, stored as int
    if (payload.containsKey(ParticipantFields.laterality)) {
      final value = payload[ParticipantFields.laterality];
      if (value is Laterality) {
        payload[ParticipantFields.laterality] = value.numericValue;
      }
    } else {
      // Fallback for legacy tests/callers that didn't set laterality.
      // Pick a sensible default (or change to whatever your domain expects).
      payload[ParticipantFields.laterality] =
          Laterality.ambidextrous.numericValue;
    }

    // sex may be passed as enum or int
    if (payload[ParticipantFields.sex] is Sex) {
      payload[ParticipantFields.sex] =
          (payload[ParticipantFields.sex] as Sex).numericValue;
    }

    // education_level may be passed as enum or int
    if (payload[ParticipantFields.educationLevel] is EducationLevel) {
      payload[ParticipantFields.educationLevel] =
          (payload[ParticipantFields.educationLevel] as EducationLevel)
              .numericValue;
    }

    AppLogger.db(
      'ParticipantLocalDataSource.insertParticipant ‚Üí name=${payload[ParticipantFields.name]}',
    );

    try {
      final id = await txn.insert(Tables.participants, payload);
      AppLogger.db(
        'ParticipantLocalDataSource.insertParticipant ‚Üí inserted with ID=$id',
      );
      return id;
    } catch (e, s) {
      AppLogger.error(
        'ParticipantLocalDataSource.insertParticipant ‚Üí error inserting participant',
        e,
        s,
      );
      return null;
    }
  }

  Future<List<ParticipantEntity>> getAllParticipants() async {
    AppLogger.db('ParticipantLocalDataSource.getAllParticipants ‚Üí querying DB');
    final db = await _db;
    final maps = await db.query(Tables.participants);
    final participants = maps.map(ParticipantEntity.fromMap).toList();
    AppLogger.db(
      'ParticipantLocalDataSource.getAllParticipants ‚Üí mapped ${participants.length} participants',
    );
    return participants;
  }

  Future<ParticipantEntity?> getById(int id) async {
    AppLogger.db('ParticipantLocalDataSource.getById ‚Üí id=$id');
    final db = await _db;
    final result = await db.query(
      Tables.participants,
      where: '${ParticipantFields.id} = ?',
      whereArgs: [id],
    );

    if (result.isEmpty) {
      AppLogger.warning(
        'ParticipantLocalDataSource.getById ‚Üí no participant found for id=$id',
      );
      return null;
    }

    final participant = ParticipantEntity.fromMap(result.first);
    AppLogger.db(
      'ParticipantLocalDataSource.getById ‚Üí found participant id=$id',
    );
    return participant;
  }

  Future<void> deleteParticipant(int id) async {
    AppLogger.db('ParticipantLocalDataSource.deleteParticipant ‚Üí id=$id');
    final db = await _db;
    try {
      final count = await db.delete(
        Tables.participants,
        where: '${ParticipantFields.id} = ?',
        whereArgs: [id],
      );
      AppLogger.db(
        'ParticipantLocalDataSource.deleteParticipant ‚Üí affected rows=$count for id=$id',
      );
    } catch (e, s) {
      AppLogger.error(
        'ParticipantLocalDataSource.deleteParticipant ‚Üí error deleting id=$id',
        e,
        s,
      );
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\participant\data\participant_repository_impl.dart ===
import '../../../core/logger/app_logger.dart';
import '../../participant/domain/participant_entity.dart';
import '../../participant/domain/participant_repository.dart';
import 'participant_local_datasource.dart';

class ParticipantRepositoryImpl implements ParticipantRepository {
  final ParticipantLocalDataSource local;

  ParticipantRepositoryImpl({required this.local});

  @override
  Future<void> insertParticipant(ParticipantEntity participant) async {
    AppLogger.db(
      'ParticipantRepositoryImpl.insertParticipant ‚Üí name=${participant.name} ${participant.surname}',
    );
    // Uses a DB/txn-aware method in the local data source
    final db = await local.dbHelper.database;
    await local.insertParticipant(db, participant.toMap());
  }

  @override
  Future<List<ParticipantEntity>> getAllParticipants() async {
    AppLogger.db('ParticipantRepositoryImpl.getAllParticipants ‚Üí fetching');
    final result = await local.getAllParticipants();
    AppLogger.db(
      'ParticipantRepositoryImpl.getAllParticipants ‚Üí fetched ${result.length} participants',
    );
    return result;
  }

  @override
  Future<ParticipantEntity?> getById(int id) async {
    AppLogger.db('ParticipantRepositoryImpl.getById ‚Üí id=$id');
    final participant = await local.getById(id);
    if (participant == null) {
      AppLogger.warning(
        'ParticipantRepositoryImpl.getById ‚Üí not found id=$id',
      );
    }
    return participant;
  }

  @override
  Future<void> deleteParticipant(int id) async {
    AppLogger.db('ParticipantRepositoryImpl.deleteParticipant ‚Üí id=$id');
    await local.deleteParticipant(id);
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\participant\domain\participant_entity.dart ===
import '../../../core/constants/enums/laterality_enums.dart';
import '../../../core/constants/enums/person_enums.dart';
import '../data/participant_constants.dart';

class ParticipantEntity {
  final int? participantID;
  final String name;
  final String surname;
  final DateTime birthDate;
  final Sex sex;
  final EducationLevel educationLevel;
  final Laterality laterality;

  ParticipantEntity({
    this.participantID,
    required this.name,
    required this.surname,
    required this.birthDate,
    required this.sex,
    required this.educationLevel,
    required this.laterality
  });

  static ParticipantEntity fromMap(Map<String, dynamic> map) {
    return ParticipantEntity(
      participantID: map[ParticipantFields.id],
      name: map[ParticipantFields.name],
      surname: map[ParticipantFields.surname],
      birthDate: DateTime.parse(map[ParticipantFields.birthDate]),
      sex: Sex.fromValue(map[ParticipantFields.sex]),
      educationLevel: EducationLevel.fromValue(map[ParticipantFields.educationLevel]),
      laterality: Laterality.fromValue(map[ParticipantFields.laterality]),
    );
  }

  Map<String, dynamic> toMap() => {
    ParticipantFields.id: participantID,
    ParticipantFields.name: name,
    ParticipantFields.surname: surname,
    ParticipantFields.birthDate: birthDate.toIso8601String(),
    ParticipantFields.sex: sex.numericValue,
    ParticipantFields.educationLevel: educationLevel.numericValue,// üîß Add this
  };

  ParticipantEntity copyWith({
    int? participantID,
    String? name,
    String? surname,
    DateTime? birthDate,
    Sex? sex,
    EducationLevel? educationLevel,
    Laterality? laterality, // üîß Add this
  }) {
    return ParticipantEntity(
      participantID: participantID ?? this.participantID,
      name: name ?? this.name,
      surname: surname ?? this.surname,
      birthDate: birthDate ?? this.birthDate,
      sex: sex ?? this.sex,
      educationLevel: educationLevel ?? this.educationLevel,
      laterality: laterality ?? this.laterality,
    );
  }


  @override
  String toString() =>
      'ParticipantEntity(id: $participantID, name: $name, surname: $surname, sex: $sex, education: $educationLevel)';

  String get fullName => '$name $surname';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\participant\domain\participant_repository.dart ===
import 'participant_entity.dart';

abstract class ParticipantRepository {
  Future<void> insertParticipant(ParticipantEntity participant);
  Future<List<ParticipantEntity>> getAllParticipants();
  Future<ParticipantEntity?> getById(int id);
  Future<void> deleteParticipant(int id);
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\participant\presentation\create_participant_evaluation_notifier.dart ===
import 'dart:async';
import 'package:hooks_riverpod/hooks_riverpod.dart';

import '../../../core/logger/app_logger.dart';
import '../../../core/constants/enums/person_enums.dart';
import '../../../providers/participant_providers.dart';
import '../../evaluation/data/evaluation_local_datasource.dart';
import '../../evaluation/domain/usecases/create_participant_evaluation_usecase.dart';
import '../../module/data/module_local_datasource.dart';
import '../../module_instance/data/module_instance_local_datasource.dart';
import '../../module_instance/data/module_instance_repository_impl.dart';
import '../../task/data/task_local_datasource.dart';
import '../../task_instance/data/task_instance_local_datasource.dart';
import '../../task_instance/data/task_instance_repository_impl.dart';
import '../data/participant_local_datasource.dart';
import '../domain/participant_entity.dart';

class CreateParticipantEvaluationNotifier
    extends AsyncNotifier<ParticipantEntity?> {
  late final CreateParticipantEvaluationUseCase _useCase;

  @override
  FutureOr<ParticipantEntity?> build() async {
    final dbHelper = ref.read(participantDbHelperProvider);
    final db = await dbHelper.database;

    AppLogger.info(
        '[PROVIDER] Initializing CreateParticipantEvaluationUseCase in CreateParticipantEvaluationNotifier');

    _useCase = CreateParticipantEvaluationUseCase(
      participantDataSource: ParticipantLocalDataSource(dbHelper: dbHelper),
      evaluationDataSource: EvaluationLocalDataSource(dbHelper: dbHelper),
      moduleDataSource: ModuleLocalDataSource(dbHelper: dbHelper),
      moduleInstanceRepository: ModuleInstanceRepositoryImpl(
        localDataSource: ModuleInstanceLocalDataSource(dbHelper: dbHelper),
      ),
      taskDataSource: TaskLocalDataSource(dbHelper: dbHelper),
      taskInstanceRepository: TaskInstanceRepositoryImpl(
        localDataSource: TaskInstanceLocalDataSource(dbHelper: dbHelper),
      ),
      db: db,
    );

    return null;
  }

  Future<void> createParticipantWithEvaluation({
    required ParticipantEntity participant,
    required int evaluatorId,
  }) async {
    state = const AsyncLoading();
    AppLogger.info(
      '[PROVIDER] Creating participant with evaluation for evaluatorId=$evaluatorId',
    );

    try {
      final created = await _useCase.execute(
        participant: participant,
        evaluatorId: evaluatorId,
      );

      AppLogger.info(
        '[PROVIDER] ‚úÖ Participant + Evaluation hierarchy created successfully (participantId=${created.participantID})',
      );
      state = AsyncData(created);
    } catch (e, s) {
      AppLogger.error(
        '[PROVIDER] ‚ùå Failed to create participant with evaluation',
        e,
        s,
      );
      state = AsyncError(e, s);
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\participant\presentation\create_participant_form.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:intl/intl.dart';

import '../../../core/constants/enums/laterality_enums.dart';
import '../../../core/constants/enums/person_enums.dart';
import '../../../core/logger/app_logger.dart';
import '../../../providers/evaluator_providers.dart';
import '../../../providers/participant_providers.dart';
import '../domain/participant_entity.dart';

class ParticipantRegistrationForm extends HookConsumerWidget {
  const ParticipantRegistrationForm({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final nameController = useTextEditingController();
    final surnameController = useTextEditingController();
    final birthDate = useState<DateTime?>(null);
    final evaluationDate = useState<DateTime?>(null); // optional / future use

    final selectedGender = useState<Sex?>(null);
    final selectedEducation = useState<EducationLevel?>(null);
    final selectedLaterality = useState<Laterality?>(null);

    final flyoutController = useMemoized(() => FlyoutController());

    final createState = ref.watch(createParticipantEvaluationProvider);

    Future<void> _onSubmit() async {
      // 1) Validate fields
      if (nameController.text.trim().isEmpty ||
          surnameController.text.trim().isEmpty ||
          birthDate.value == null ||
          selectedGender.value == null ||
          selectedEducation.value == null ||
          selectedLaterality.value == null) {
        AppLogger.warning(
            '[UI] Participant form validation failed ‚Äî missing required fields');
        await showDialog(
          context: context,
          builder: (context) => ContentDialog(
            title: const Text('Dados incompletos'),
            content: const Text(
                'Por favor, preencha todos os campos obrigat√≥rios do paciente.'),
            actions: [
              FilledButton(
                child: const Text('OK'),
                onPressed: () => Navigator.pop(context),
              ),
            ],
          ),
        );
        return;
      }

      // 2) Get logged evaluator
      final evaluator = ref.read(currentUserProvider);
      if (evaluator == null || evaluator.evaluatorId == null) {
        AppLogger.error(
          '[UI] Tried to create participant without a logged evaluator',
        );
        await showDialog(
          context: context,
          builder: (context) => ContentDialog(
            title: const Text('Erro'),
            content: const Text(
                'Nenhum avaliador logado foi encontrado. Fa√ßa login novamente.'),
            actions: [
              FilledButton(
                child: const Text('OK'),
                onPressed: () => Navigator.pop(context),
              ),
            ],
          ),
        );
        return;
      }

      // 3) Build ParticipantEntity
      final participant = ParticipantEntity(
        name: nameController.text.trim(),
        surname: surnameController.text.trim(),
        birthDate: birthDate.value!,
        sex: selectedGender.value!,
        educationLevel: selectedEducation.value!,
        laterality: selectedLaterality.value!,
      );

      AppLogger.info(
        '[UI] Submitting participant creation ‚Üí '
            'name=${participant.name} ${participant.surname}, '
            'birthDate=${participant.birthDate}, '
            'sex=${participant.sex}, '
            'education=${participant.educationLevel}, '
            'laterality=${participant.laterality}, '
            'evaluatorId=${evaluator.evaluatorId}',
      );

      // 4) Call notifier
      await ref
          .read(createParticipantEvaluationProvider.notifier)
          .createParticipantWithEvaluation(
        participant: participant,
        evaluatorId: evaluator.evaluatorId!,
      );

      final state = ref.read(createParticipantEvaluationProvider);

      // 5) Handle result
      if (state.hasError) {
        AppLogger.error(
          '[UI] Participant creation failed',
          state.error,
          state.stackTrace,
        );
        await showDialog(
          context: context,
          builder: (context) => ContentDialog(
            title: const Text('Erro ao salvar'),
            content: const Text(
                'N√£o foi poss√≠vel registrar o paciente. Tente novamente.'),
            actions: [
              FilledButton(
                child: const Text('OK'),
                onPressed: () => Navigator.pop(context),
              ),
            ],
          ),
        );
        return;
      }

      AppLogger.info('[UI] ‚úÖ Participant created successfully ‚Äî showing flyout');

      // Optionally use the evaluationDate in the future; currently EvaluationEntity
      // sets its own date in the use case.

      await flyoutController.showFlyout(
        barrierDismissible: true,
        placementMode: FlyoutPlacementMode.bottomCenter,
        builder: (context) {
          return const FlyoutContent(
            child: Padding(
              padding: EdgeInsets.all(8.0),
              child: Text('‚úÖ Paciente registrado com sucesso!'),
            ),
          );
        },
      );

      // Clear form
      nameController.clear();
      surnameController.clear();
      birthDate.value = null;
      evaluationDate.value = null;
      selectedGender.value = null;
      selectedEducation.value = null;
      selectedLaterality.value = null;
    }

    return Form(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'üìã Registro do Paciente',
            style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 16),

          TextBox(
            controller: nameController,
            placeholder: 'Nome',
          ),
          const SizedBox(height: 12),

          TextBox(
            controller: surnameController,
            placeholder: 'Sobrenome',
          ),
          const SizedBox(height: 12),

          InfoLabel(
            label: 'Data de Nascimento',
            child: DatePicker(
              selected: birthDate.value,
              onChanged: (date) => birthDate.value = date,
            ),
          ),
          const SizedBox(height: 12),

          InfoLabel(
            label: 'Sexo',
            child: ComboBox<Sex>(
              isExpanded: true,
              value: selectedGender.value,
              items: Sex.values
                  .map((g) => ComboBoxItem(value: g, child: Text(g.label)))
                  .toList(),
              onChanged: (v) => selectedGender.value = v,
              placeholder: const Text('Selecione o sexo'),
            ),
          ),
          const SizedBox(height: 12),

          InfoLabel(
            label: 'N√≠vel de Educa√ß√£o',
            child: ComboBox<EducationLevel>(
              isExpanded: true,
              value: selectedEducation.value,
              items: EducationLevel.values
                  .map((e) => ComboBoxItem(value: e, child: Text(e.label)))
                  .toList(),
              onChanged: (v) => selectedEducation.value = v,
              placeholder: const Text('Selecione o n√≠vel'),
            ),
          ),
          const SizedBox(height: 12),

          InfoLabel(
            label: 'Lateralidade',
            child: ComboBox<Laterality>(
              isExpanded: true,
              value: selectedLaterality.value,
              items: Laterality.values
                  .map((h) => ComboBoxItem(value: h, child: Text(h.label)))
                  .toList(),
              onChanged: (v) => selectedLaterality.value = v,
              placeholder: const Text('Selecione a lateralidade'),
            ),
          ),
          const SizedBox(height: 12),

          InfoLabel(
            label: 'Data da Avalia√ß√£o (opcional)',
            child: DatePicker(
              selected: evaluationDate.value,
              onChanged: (date) => evaluationDate.value = date,
            ),
          ),
          if (evaluationDate.value != null) ...[
            const SizedBox(height: 8),
            Text(
              'üìÖ Dia da semana: '
                  '${DateFormat('EEEE', 'pt_BR').format(evaluationDate.value!)}',
            ),
          ],
          const SizedBox(height: 24),

          FlyoutTarget(
            controller: flyoutController,
            child: FilledButton(
              onPressed:
              createState.isLoading ? null : () => _onSubmit(),
              child: createState.isLoading
                  ? const ProgressRing()
                  : const Text('Salvar'),
            ),
          ),
        ],
      ),
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\participant\presentation\create_participant_screen.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import '../../../core/logger/app_logger.dart';
import 'create_participant_form.dart';

class CreatePatientScreen extends StatelessWidget {
  const CreatePatientScreen({super.key});

  @override
  Widget build(BuildContext context) {
    AppLogger.nav('Navigated to CreatePatientScreen');
    return ScaffoldPage.scrollable(
      header: PageHeader(title: Text('Criar Novo Paciente')),
      children: [
        ParticipantRegistrationForm(),
      ],
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\participant\presentation\participant_provider.dart ===
import 'package:hooks_riverpod/hooks_riverpod.dart';
import '../../../core/database/prod_database_helper.dart';
import '../../../core/logger/app_logger.dart';
import '../data/participant_local_datasource.dart';
import '../data/participant_repository_impl.dart';
import '../domain/participant_repository.dart';

final participantDbHelperProvider = Provider<ProdDatabaseHelper>((ref) {
  AppLogger.db('Providing ProdDatabaseHelper.instance for participants');
  return ProdDatabaseHelper.instance;
});

final participantRepositoryProvider = Provider<ParticipantRepository>((ref) {
  final dbHelper = ref.watch(participantDbHelperProvider);
  AppLogger.info('Creating ParticipantRepositoryImpl via participant_provider');
  return ParticipantRepositoryImpl(
    local: ParticipantLocalDataSource(dbHelper: dbHelper),
  );
});


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\recording_file\data\recording_file_constants.dart ===
import '../../../core/constants/database_constants.dart';
import '../../task_instance/data/task_instance_constants.dart';

class RecordingFileFields {
  static const id = 'recording_id';
  static const taskInstanceId = TaskInstanceFields.id;
  static const filePath = 'file_path';

  static const values = [id, taskInstanceId, filePath];
}

final scriptCreateTableRecordings = '''
CREATE TABLE ${Tables.recordings} (
  ${RecordingFileFields.id} INTEGER PRIMARY KEY AUTOINCREMENT,
  ${RecordingFileFields.taskInstanceId} INTEGER UNIQUE NOT NULL,
  ${RecordingFileFields.filePath} TEXT NOT NULL,
  FOREIGN KEY (${RecordingFileFields.taskInstanceId}) 
    REFERENCES ${Tables.taskInstances}(${TaskInstanceFields.id})
)
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\recording_file\data\recording_file_local_datasource.dart ===
import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import '../../../core/constants/database_constants.dart';
import '../../../core/database/base_database_helper.dart';
import '../../recording_file/data/recording_file_constants.dart';
import '../../recording_file/data/recording_file_model.dart';
import '../../../core/logger/app_logger.dart';

class RecordingFileLocalDataSource {
  final BaseDatabaseHelper dbHelper;

  RecordingFileLocalDataSource({required this.dbHelper});

  Future<Database> get _db async => dbHelper.database;

  Future<int?> insert(RecordingFileModel model) async {
    try {
      final db = await _db;
      final id = await db.insert(
        Tables.recordings,
        model.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
      AppLogger.db('Inserted RecordingFile (id=$id)');
      return id;
    } catch (e, s) {
      AppLogger.error('Error inserting RecordingFile', e, s);
      return null;
    }
  }

  Future<RecordingFileModel?> getById(int id) async {
    try {
      final db = await _db;
      final result = await db.query(
        Tables.recordings,
        where: '${RecordingFileFields.id} = ?',
        whereArgs: [id],
      );
      return result.isNotEmpty ? RecordingFileModel.fromMap(result.first) : null;
    } catch (e, s) {
      AppLogger.error('Error fetching RecordingFile by ID: $id', e, s);
      return null;
    }
  }

  Future<RecordingFileModel?> getByTaskInstanceId(int taskInstanceId) async {
    try {
      final db = await _db;
      final result = await db.query(
        Tables.recordings,
        where: '${RecordingFileFields.taskInstanceId} = ?',
        whereArgs: [taskInstanceId],
      );
      return result.isNotEmpty ? RecordingFileModel.fromMap(result.first) : null;
    } catch (e, s) {
      AppLogger.error('Error fetching RecordingFile by TaskInstanceId: $taskInstanceId', e, s);
      return null;
    }
  }

  Future<List<RecordingFileModel>> getAll() async {
    try {
      final db = await _db;
      final result = await db.query(Tables.recordings);
      return result.map(RecordingFileModel.fromMap).toList();
    } catch (e, s) {
      AppLogger.error('Error fetching all RecordingFiles', e, s);
      return [];
    }
  }

  Future<int> update(RecordingFileModel model) async {
    try {
      final db = await _db;
      return await db.update(
        Tables.recordings,
        model.toMap(),
        where: '${RecordingFileFields.id} = ?',
        whereArgs: [model.id],
      );
    } catch (e, s) {
      AppLogger.error('Error updating RecordingFile ID=${model.id}', e, s);
      return -1;
    }
  }

  Future<int> delete(int id) async {
    try {
      final db = await _db;
      return await db.delete(
        Tables.recordings,
        where: '${RecordingFileFields.id} = ?',
        whereArgs: [id],
      );
    } catch (e, s) {
      AppLogger.error('Error deleting RecordingFile ID=$id', e, s);
      return -1;
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\recording_file\data\recording_file_model.dart ===
import '../../recording_file/domain/recording_file_entity.dart';
import '../../recording_file/data/recording_file_constants.dart';

class RecordingFileModel extends RecordingFileEntity {
  const RecordingFileModel({
    super.id,
    required super.taskInstanceId,
    required super.filePath,
  });

  factory RecordingFileModel.fromMap(Map<String, dynamic> map) {
    return RecordingFileModel(
      id: map[RecordingFileFields.id] as int?,
      taskInstanceId: map[RecordingFileFields.taskInstanceId] as int,
      filePath: map[RecordingFileFields.filePath] as String,
    );
  }

  Map<String, dynamic> toMap() => {
    RecordingFileFields.id: id,
    RecordingFileFields.taskInstanceId: taskInstanceId,
    RecordingFileFields.filePath: filePath,
  };

  factory RecordingFileModel.fromEntity(RecordingFileEntity entity) =>
      RecordingFileModel(
        id: entity.id,
        taskInstanceId: entity.taskInstanceId,
        filePath: entity.filePath,
      );

  RecordingFileEntity toEntity() => RecordingFileEntity(
    id: id,
    taskInstanceId: taskInstanceId,
    filePath: filePath,
  );
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\recording_file\data\recording_file_repository_impl.dart ===
import '../../recording_file/domain/recording_file_entity.dart';
import '../../recording_file/domain/recording_file_repository.dart';
import '../../recording_file/data/recording_file_model.dart';
import '../../recording_file/data/recording_file_local_datasource.dart';

class RecordingFileRepositoryImpl implements RecordingFileRepository {
  final RecordingFileLocalDataSource localDataSource;

  RecordingFileRepositoryImpl({required this.localDataSource});

  @override
  Future<int?> insert(RecordingFileEntity entity) async {
    final model = RecordingFileModel.fromEntity(entity);
    return await localDataSource.insert(model);
  }

  @override
  Future<RecordingFileEntity?> getById(int id) async {
    final model = await localDataSource.getById(id);
    return model?.toEntity();
  }

  @override
  Future<RecordingFileEntity?> getByTaskInstanceId(int taskInstanceId) async {
    final model = await localDataSource.getByTaskInstanceId(taskInstanceId);
    return model?.toEntity();
  }

  @override
  Future<List<RecordingFileEntity>> getAll() async {
    final models = await localDataSource.getAll();
    return models.map((m) => m.toEntity()).toList();
  }

  @override
  Future<int> update(RecordingFileEntity entity) async {
    final model = RecordingFileModel.fromEntity(entity);
    return await localDataSource.update(model);
  }

  @override
  Future<int> delete(int id) async {
    return await localDataSource.delete(id);
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\recording_file\domain\recording_file_entity.dart ===
class RecordingFileEntity {
  final int? id;
  final int taskInstanceId;
  final String filePath;

  const RecordingFileEntity({
    this.id,
    required this.taskInstanceId,
    required this.filePath,
  });

  RecordingFileEntity copyWith({
    int? id,
    int? taskInstanceId,
    String? filePath,
  }) {
    return RecordingFileEntity(
      id: id ?? this.id,
      taskInstanceId: taskInstanceId ?? this.taskInstanceId,
      filePath: filePath ?? this.filePath,
    );
  }

  @override
  String toString() =>
      'RecordingFileEntity(id: $id, taskInstanceId: $taskInstanceId, filePath: $filePath)';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\recording_file\domain\recording_file_repository.dart ===
import 'recording_file_entity.dart';

abstract class RecordingFileRepository {
  Future<int?> insert(RecordingFileEntity entity);
  Future<RecordingFileEntity?> getById(int id);
  Future<RecordingFileEntity?> getByTaskInstanceId(int taskInstanceId);
  Future<List<RecordingFileEntity>> getAll();
  Future<int> update(RecordingFileEntity entity);
  Future<int> delete(int id);
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\splash\splash_screen.dart ===
import 'package:fluent_ui/fluent_ui.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

import '../../core/logger/app_logger.dart';
import '../../core/database_helper.dart';
import '../../features/evaluator/data/evaluator_local_datasource.dart';
import '../../seeders/seed_runner.dart';
import '../auth/data/auth_local_datasource.dart';
import '../auth/data/auth_repository_impl.dart';
import '../../providers/providers.dart';

class SplashScreen extends HookConsumerWidget {
  const SplashScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    Future.microtask(() async {
      if (!context.mounted) return; // üîê Ensure still mounted before async logic
      await _initializeApp(context, ref);
    });

    return NavigationView(
      content: ScaffoldPage(
        content: Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: const [
              ProgressRing(),
              SizedBox(height: 16),
              Text(
                'Inicializando o aplicativo...',
                style: TextStyle(fontSize: 16),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Future<void> _initializeApp(BuildContext context, WidgetRef ref) async {
    try {
      AppLogger.seed('[SPLASH] Starting database seeding...');
      await SeedRunner().run();

      final db = await DatabaseHelper.instance.database;

      final evaluatorDataSource = EvaluatorLocalDataSource(db);
      final auth = AuthLocalDataSource(db);
      final repository = AuthRepositoryImpl(auth);

      final currentUser = await repository.fetchCurrentUserOrNull();

      if (!context.mounted) return; // ‚úÖ Prevent context usage after unmount

      if (currentUser != null) {
        AppLogger.seed('[SPLASH] Auto-login success: ${currentUser.email}');
        ref.read(currentUserProvider.notifier).setUser(currentUser);
        context.go('/home');
        return;
      }

      final anyEvaluator = await evaluatorDataSource.getFirstEvaluator();

      if (!context.mounted) return;

      if (anyEvaluator != null) {
        AppLogger.seed('[SPLASH] Evaluator exists ‚Üí go to login');
        context.go('/login');
      } else {
        AppLogger.seed('[SPLASH] No evaluator found ‚Üí go to registration');
        context.go('/register');
      }
    } catch (e, s) {
      AppLogger.error('[SPLASH] Error during initialization', e, s);
      if (context.mounted) {
        _showErrorDialog(context, e.toString());
      }
    }
  }

  void _showErrorDialog(BuildContext context, String message) {
    showDialog(
      context: context,
      builder: (_) => ContentDialog(
        title: const Text('Erro ao iniciar'),
        content: Text(message),
        actions: [
          Button(
            child: const Text('Fechar'),
            onPressed: () => Navigator.pop(context),
          ),
        ],
      ),
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task\data\task_constants.dart ===
import '../../../core/constants/database_constants.dart';

class TaskFields {
  static const id = 'task_id';
  static const moduleId = 'module_id';
  static const title = 'title';
  static const transcript = 'transcript';
  static const mode = 'mode';
  static const position = 'position';
  static const imagePath = 'image_path';
  static const timeForCompletion = 'time_for_completion';
  static const mayRepeatPrompt = 'may_repeat_prompt';
  static const testOnly = 'test_only';

  static const values = [
    id,
    moduleId,
    title,
    transcript,
    mode,
    position,
    imagePath,
    timeForCompletion,
    mayRepeatPrompt,
    testOnly,
  ];
}

const scriptCreateTableTasks = '''
CREATE TABLE ${Tables.tasks} (
  ${TaskFields.id} INTEGER PRIMARY KEY AUTOINCREMENT,
  ${TaskFields.moduleId} INTEGER NOT NULL,
  ${TaskFields.title} TEXT NOT NULL,
  ${TaskFields.transcript} TEXT,
  ${TaskFields.mode} INTEGER NOT NULL,
  ${TaskFields.position} INTEGER NOT NULL,
  ${TaskFields.imagePath} TEXT NOT NULL,
  ${TaskFields.mayRepeatPrompt} INTEGER NOT NULL,
  ${TaskFields.testOnly} INTEGER NOT NULL,
  ${TaskFields.timeForCompletion} INTEGER NOT NULL,
  FOREIGN KEY (${TaskFields.moduleId}) REFERENCES ${Tables.modules}(${TaskFields.id}),
  CHECK(${TaskFields.mode} >= 0 AND ${TaskFields.mode} <= 1),
  CHECK(${TaskFields.mayRepeatPrompt} >= 0 AND ${TaskFields.mayRepeatPrompt} <= 1)
)
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task\data\task_local_datasource.dart ===
import 'package:sqflite_common/sqlite_api.dart';
import '../../../core/database/base_database_helper.dart';
import '../../../core/logger/app_logger.dart';
import '../../../core/constants/database_constants.dart';
import 'task_constants.dart';
import 'task_model.dart';

class TaskLocalDataSource {
  final BaseDatabaseHelper dbHelper;
  TaskLocalDataSource({required this.dbHelper});

  Future<Database> get _db async => dbHelper.database;
  Future<int?> insertTask(TaskModel task) async {
    AppLogger.db('Inserting task: ${task.title}');
    try {
      final db = await _db;
      final id = await db.insert(
        Tables.tasks,
        task.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
      AppLogger.db('Task inserted successfully (id=$id)');
      return id;
    } catch (e, s) {
      AppLogger.error('Error inserting task: ${task.title}', e, s);
      return null;
    }
  }

  Future<TaskModel?> getTaskById(int id) async {
    AppLogger.db('Fetching task by ID=$id');
    try {
      final db = await _db;
      final result = await db.query(
        Tables.tasks,
        where: '${TaskFields.id} = ?',
        whereArgs: [id],
      );
      if (result.isNotEmpty) {
        AppLogger.db('Task found (ID=$id)');
        return TaskModel.fromMap(result.first);
      }
      AppLogger.db('No task found (ID=$id)');
      return null;
    } catch (e, s) {
      AppLogger.error('Error fetching task by ID=$id', e, s);
      return null;
    }
  }

  Future<List<TaskModel>> getAllTasks() async {
    AppLogger.db('Fetching all tasks');
    try {
      final db = await _db;
      final maps = await db.query(Tables.tasks);
      AppLogger.db('Fetched ${maps.length} tasks');
      return maps.map(TaskModel.fromMap).toList();
    } catch (e, s) {
      AppLogger.error('Error fetching all tasks', e, s);
      return [];
    }
  }

  Future<List<TaskModel>> getTasksByModuleId(int moduleId) async {
    AppLogger.db('Fetching tasks for moduleId=$moduleId');
    try {
      final db = await _db;
      final maps = await db.query(
        Tables.tasks,
        where: '${TaskFields.moduleId} = ?',
        whereArgs: [moduleId],
      );
      AppLogger.db('Fetched ${maps.length} tasks for moduleId=$moduleId');
      return maps.map(TaskModel.fromMap).toList();
    } catch (e, s) {
      AppLogger.error('Error fetching tasks for moduleId=$moduleId', e, s);
      return [];
    }
  }

  Future<int> updateTask(TaskModel task) async {
    AppLogger.db('Updating task ID=${task.taskID}');
    try {
      final db = await _db;
      final rows = await db.update(
        Tables.tasks,
        task.toMap(),
        where: '${TaskFields.id} = ?',
        whereArgs: [task.taskID],
      );
      AppLogger.db('Updated $rows task(s) for ID=${task.taskID}');
      return rows;
    } catch (e, s) {
      AppLogger.error('Error updating task ID=${task.taskID}', e, s);
      return 0;
    }
  }

  Future<int> deleteTask(int id) async {
    AppLogger.db('Deleting task ID=$id');
    try {
      final db = await _db;
      final count = await db.delete(
        Tables.tasks,
        where: '${TaskFields.id} = ?',
        whereArgs: [id],
      );
      AppLogger.db('Deleted $count task(s)');
      return count;
    } catch (e, s) {
      AppLogger.error('Error deleting task ID=$id', e, s);
      return 0;
    }
  }

  Future<bool> exists(String taskId) async {
    final db = await _db;
    final result = await db.query(
      Tables.tasks,
      where: '${TaskFields.id} = ?',
      whereArgs: [taskId],
      limit: 1,
    );
    return result.isNotEmpty;
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task\data\task_model.dart ===
import '../../../core/constants/enums/task_mode.dart';
import '../../task/domain/task_entity.dart';
import '../../task/data/task_constants.dart';

class TaskModel extends TaskEntity {
  const TaskModel({
    super.taskID,
    required super.moduleID,
    required super.title,
    required super.taskMode,
    required super.position,
    super.imagePath = 'no_image',
    super.timeForCompletion = 60,
    super.mayRepeatPrompt = true,
    super.testOnly = false,
    super.transcript,
  });

  factory TaskModel.fromMap(Map<String, dynamic> map) {
    return TaskModel(
      taskID: map[TaskFields.id] as int?,
      moduleID: map[TaskFields.moduleId] as int,
      title: map[TaskFields.title] as String,
      transcript: map[TaskFields.transcript] as String?,
      taskMode: TaskMode.fromValue(map[TaskFields.mode] as int),
      position: map[TaskFields.position] as int,
      imagePath: map[TaskFields.imagePath] as String? ?? 'no_image',
      timeForCompletion: map[TaskFields.timeForCompletion] as int? ?? 60,
      mayRepeatPrompt: (map[TaskFields.mayRepeatPrompt] as int) == 1,
      testOnly: (map[TaskFields.testOnly] as int) == 1,
    );
  }

  Map<String, dynamic> toMap() => {
    TaskFields.id: taskID,
    TaskFields.moduleId: moduleID,
    TaskFields.title: title,
    TaskFields.transcript: transcript,
    TaskFields.mode: taskMode.numericValue,
    TaskFields.position: position,
    TaskFields.imagePath: imagePath,
    TaskFields.timeForCompletion: timeForCompletion,
    TaskFields.mayRepeatPrompt: mayRepeatPrompt ? 1 : 0,
    TaskFields.testOnly: testOnly ? 1 : 0,
  };

  factory TaskModel.fromEntity(TaskEntity entity) => TaskModel(
    taskID: entity.taskID,
    moduleID: entity.moduleID,
    title: entity.title,
    transcript: entity.transcript,
    taskMode: entity.taskMode,
    position: entity.position,
    imagePath: entity.imagePath,
    timeForCompletion: entity.timeForCompletion,
    mayRepeatPrompt: entity.mayRepeatPrompt,
    testOnly: entity.testOnly,
  );

  TaskEntity toEntity() => TaskEntity(
    taskID: taskID,
    moduleID: moduleID,
    title: title,
    transcript: transcript,
    taskMode: taskMode,
    position: position,
    imagePath: imagePath,
    timeForCompletion: timeForCompletion,
    mayRepeatPrompt: mayRepeatPrompt,
    testOnly: testOnly,
  );
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task\data\task_repository_impl.dart ===
import '../domain/task_repository.dart';
import '../domain/task_entity.dart';
import 'task_local_datasource.dart';
import 'task_model.dart';

class TaskRepositoryImpl implements TaskRepository {
  final TaskLocalDataSource localDataSource;

  TaskRepositoryImpl({required this.localDataSource});

  @override
  Future<int?> insertTask(TaskEntity task) async {
    final model = TaskModel.fromEntity(task);
    return await localDataSource.insertTask(model);
  }

  @override
  Future<TaskEntity?> getTaskById(int id) async {
    final model = await localDataSource.getTaskById(id);
    return model?.toEntity();
  }

  @override
  Future<List<TaskEntity>> getAllTasks() async {
    final models = await localDataSource.getAllTasks();
    return models.map((m) => m.toEntity()).toList();
  }

  @override
  Future<List<TaskEntity>> getTasksByModuleId(int moduleId) async {
    final models = await localDataSource.getTasksByModuleId(moduleId);
    return models.map((m) => m.toEntity()).toList();
  }

  @override
  Future<int> updateTask(TaskEntity task) async {
    final model = TaskModel.fromEntity(task);
    return await localDataSource.updateTask(model);
  }

  @override
  Future<int> deleteTask(int id) async {
    return await localDataSource.deleteTask(id);
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task\domain\task_entity.dart ===
import '../../../core/constants/enums/task_mode.dart';
import '../data/task_constants.dart';

class TaskEntity {
  final int? taskID;
  final int moduleID;
  final String title;
  final String? transcript;
  final TaskMode taskMode;
  final int position;
  final String imagePath;
  final int timeForCompletion;
  final bool mayRepeatPrompt;
  final bool testOnly;

  const TaskEntity({
    this.taskID,
    required this.moduleID,
    required this.title,
    required this.taskMode,
    required this.position,
    this.imagePath = 'no_image',
    this.timeForCompletion = 60,
    this.mayRepeatPrompt = true,
    this.testOnly = false,
    this.transcript,
  });

  Map<String, dynamic> toMap() => {
    TaskFields.id: taskID,
    TaskFields.moduleId: moduleID,
    TaskFields.title: title,
    TaskFields.transcript: transcript,
    TaskFields.mode: taskMode.index,
    TaskFields.position: position,
    TaskFields.imagePath: imagePath,
    TaskFields.timeForCompletion: timeForCompletion,
    TaskFields.mayRepeatPrompt: mayRepeatPrompt ? 1 : 0,
    TaskFields.testOnly: testOnly ? 1 : 0,
  };

  factory TaskEntity.fromMap(Map<String, dynamic> map) => TaskEntity(
    taskID: map[TaskFields.id] as int?,
    moduleID: map[TaskFields.moduleId] as int,
    title: map[TaskFields.title] as String,
    transcript: map[TaskFields.transcript] as String?,
    taskMode: TaskMode.values[map[TaskFields.mode] as int],
    position: map[TaskFields.position] as int,
    imagePath: map[TaskFields.imagePath] as String,
    timeForCompletion: map[TaskFields.timeForCompletion] as int,
    mayRepeatPrompt: (map[TaskFields.mayRepeatPrompt] as int) == 1,
    testOnly: (map[TaskFields.testOnly] as int) == 1,
  );

  TaskEntity copyWith({
    int? taskID,
    int? moduleID,
    String? title,
    String? transcript,
    TaskMode? taskMode,
    int? position,
    String? imagePath,
    int? timeForCompletion,
    bool? mayRepeatPrompt,
    bool? testOnly,
  }) {
    return TaskEntity(
      taskID: taskID ?? this.taskID,
      moduleID: moduleID ?? this.moduleID,
      title: title ?? this.title,
      transcript: transcript ?? this.transcript,
      taskMode: taskMode ?? this.taskMode,
      position: position ?? this.position,
      imagePath: imagePath ?? this.imagePath,
      timeForCompletion: timeForCompletion ?? this.timeForCompletion,
      mayRepeatPrompt: mayRepeatPrompt ?? this.mayRepeatPrompt,
      testOnly: testOnly ?? this.testOnly,
    );
  }

  @override
  String toString() =>
      'TaskEntity(id: $taskID, title: $title, mode: $taskMode, moduleId: $moduleID, pos: $position)';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task\domain\task_repository.dart ===
import 'task_entity.dart';

abstract class TaskRepository {
  Future<int?> insertTask(TaskEntity task);
  Future<TaskEntity?> getTaskById(int id);
  Future<List<TaskEntity>> getAllTasks();
  Future<List<TaskEntity>> getTasksByModuleId(int moduleId);
  Future<int> updateTask(TaskEntity task);
  Future<int> deleteTask(int id);
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_instance\data\task_instance_constants.dart ===
import '../../../core/constants/database_constants.dart';
import '../../module_instance/data/module_instance_constants.dart';
import '../../task/data/task_constants.dart';

class TaskInstanceFields {
  static const id = 'task_inst_id';
  static const taskId = TaskFields.id;
  static const moduleInstanceId = ModuleInstanceFields.id;
  static const status = 'status';
  static const completingTime = 'task_completing_time';

  static const values = [id, taskId, moduleInstanceId, status, completingTime];
}

final scriptCreateTableTaskInstances = '''
CREATE TABLE ${Tables.taskInstances} (
  ${TaskInstanceFields.id} INTEGER PRIMARY KEY AUTOINCREMENT,
  ${TaskInstanceFields.taskId} INTEGER NOT NULL,
  ${TaskInstanceFields.moduleInstanceId} INTEGER NOT NULL,
  ${TaskInstanceFields.status} INT NOT NULL CHECK(${TaskInstanceFields.status} IN (0, 1)),
  ${TaskInstanceFields.completingTime} TEXT,
  FOREIGN KEY (${TaskInstanceFields.taskId}) REFERENCES ${Tables.tasks}(${TaskFields.id}),
  FOREIGN KEY (${TaskInstanceFields.moduleInstanceId}) REFERENCES ${Tables.moduleInstances}(${ModuleInstanceFields.id})
)
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_instance\data\task_instance_local_datasource.dart ===
import 'package:sqflite_common/sqlite_api.dart';

import '../../../core/constants/database_constants.dart';
import '../../../core/constants/enums/progress_status.dart';
import '../../../core/database/base_database_helper.dart';
import '../../../core/logger/app_logger.dart';
import '../../task/data/task_constants.dart';
import '../../task_instance/data/task_instance_constants.dart';
import '../../task_instance/data/task_instance_model.dart';

class TaskInstanceLocalDataSource {
  final BaseDatabaseHelper dbHelper;

  TaskInstanceLocalDataSource({required this.dbHelper});

  Future<Database> get _db async => dbHelper.database;

  Future<int?> create(TaskInstanceModel model) async {
    AppLogger.db('Creating task instance for taskId=${model.taskId}');
    try {
      final db = await _db;
      final id = await db.insert(
        Tables.taskInstances,
        model.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
      AppLogger.db('Task instance created successfully (id=$id)');
      return id;
    } catch (e, s) {
      AppLogger.error('Error creating task instance', e, s);
      return null;
    }
  }

  Future<TaskInstanceModel?> getTaskInstance(int id) async {
    AppLogger.db('Fetching task instance ID=$id');
    try {
      final db = await _db;
      final maps = await db.query(
        Tables.taskInstances,
        where: '${TaskInstanceFields.id} = ?',
        whereArgs: [id],
      );
      if (maps.isNotEmpty) {
        AppLogger.db('Task instance found (ID=$id)');
        return TaskInstanceModel.fromMap(maps.first);
      }
      AppLogger.db('No task instance found (ID=$id)');
      return null;
    } catch (e, s) {
      AppLogger.error('Error fetching task instance ID=$id', e, s);
      return null;
    }
  }

  Future<int> updateTaskInstance(TaskInstanceModel model) async {
    AppLogger.db('Updating task instance ID=${model.id}');
    try {
      final db = await _db;
      final rows = await db.update(
        Tables.taskInstances,
        model.toMap(),
        where: '${TaskInstanceFields.id} = ?',
        whereArgs: [model.id],
      );
      AppLogger.db('Updated $rows task instance(s)');
      return rows;
    } catch (e, s) {
      AppLogger.error('Error updating task instance ID=${model.id}', e, s);
      return 0;
    }
  }

  Future<int> deleteTaskInstance(int id) async {
    AppLogger.db('Deleting task instance ID=$id');
    try {
      final db = await _db;
      final count = await db.delete(
        Tables.taskInstances,
        where: '${TaskInstanceFields.id} = ?',
        whereArgs: [id],
      );
      AppLogger.db('Deleted $count task instance(s)');
      return count;
    } catch (e, s) {
      AppLogger.error('Error deleting task instance ID=$id', e, s);
      return 0;
    }
  }

  Future<List<TaskInstanceModel>> getAllTaskInstances() async {
    AppLogger.db('Fetching all task instances');
    try {
      final db = await _db;
      final maps = await db.query(Tables.taskInstances);
      AppLogger.db('Fetched ${maps.length} task instances');
      return maps.map(TaskInstanceModel.fromMap).toList();
    } catch (e, s) {
      AppLogger.error('Error fetching all task instances', e, s);
      return [];
    }
  }

  Future<List<TaskInstanceModel>> getTaskInstancesForModuleInstance(
      int moduleInstanceId) async {
    AppLogger.db(
        'Fetching task instances for moduleInstanceId=$moduleInstanceId');
    try {
      final db = await _db;
      final maps = await db.query(
        Tables.taskInstances,
        where: '${TaskInstanceFields.moduleInstanceId} = ?',
        whereArgs: [moduleInstanceId],
      );
      AppLogger.db(
          'Fetched ${maps.length} task instances for moduleInstanceId=$moduleInstanceId');
      return maps.map(TaskInstanceModel.fromMap).toList();
    } catch (e, s) {
      AppLogger.error(
          'Error fetching task instances for moduleInstanceId=$moduleInstanceId',
          e,
          s);
      return [];
    }
  }

  Future<int?> getNumberOfTaskInstances() async {
    AppLogger.db('Counting task instances');
    try {
      final db = await _db;
      final result = await db
          .rawQuery('SELECT COUNT(*) as count FROM ${Tables.taskInstances}');
      final count = result.first['count'] as int?;
      AppLogger.db('Task instance count: $count');
      return count;
    } catch (e, s) {
      AppLogger.error('Error counting task instances', e, s);
      return null;
    }
  }

  Future<TaskInstanceModel?> getFirstPendingTaskInstance() async {
    AppLogger.db('Fetching first pending task instance');
    try {
      final db = await _db;
      final result = await db.rawQuery('''
        SELECT ti.* FROM ${Tables.taskInstances} ti
        INNER JOIN ${Tables.tasks} t ON ti.${TaskInstanceFields.taskId} = t.${TaskFields.id}
        WHERE ti.${TaskInstanceFields.status} = 0
        ORDER BY t.${TaskFields.position} ASC
        LIMIT 1
      ''');
      if (result.isNotEmpty) {
        AppLogger.db(
            'Found pending task instance ID=${result.first[TaskInstanceFields.id]}');
        return TaskInstanceModel.fromMap(result.first);
      }
      AppLogger.db('No pending task instance found');
      return null;
    } catch (e, s) {
      AppLogger.error('Error fetching first pending task instance', e, s);
      return null;
    }
  }

  Future<int> markAsCompleted(int id, {String? duration}) async {
    AppLogger.db('Marking task instance ID=$id as completed');
    try {
      final db = await _db;
      final map = {
        TaskInstanceFields.status: TaskStatus.completed.numericValue,
        if (duration != null) TaskInstanceFields.completingTime: duration,
      };
      final rows = await db.update(
        Tables.taskInstances,
        map,
        where: '${TaskInstanceFields.id} = ?',
        whereArgs: [id],
      );
      AppLogger.db(
          'Task instance ID=$id marked as completed ($rows row(s) affected)');
      return rows;
    } catch (e, s) {
      AppLogger.error(
          'Error marking task instance ID=$id as completed', e, s);
      return 0;
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_instance\data\task_instance_model.dart ===
import '../../task_instance/domain/task_instance_entity.dart';
import '../../task_instance/data/task_instance_constants.dart';
import '../../../core/constants/enums/progress_status.dart';

class TaskInstanceModel extends TaskInstanceEntity {
  const TaskInstanceModel({
    super.id,
    required super.taskId,
    required super.moduleInstanceId,
    required super.status,
    super.completingTime,
    super.task,
  });

  factory TaskInstanceModel.fromMap(Map<String, dynamic> map) {
    return TaskInstanceModel(
      id: map[TaskInstanceFields.id] as int?,
      taskId: map[TaskInstanceFields.taskId] as int,
      moduleInstanceId: map[TaskInstanceFields.moduleInstanceId] as int,
      status: TaskStatus.fromValue(map[TaskInstanceFields.status] as int),
      completingTime: map[TaskInstanceFields.completingTime] as String?,
    );
  }

  Map<String, dynamic> toMap() => {
    TaskInstanceFields.id: id,
    TaskInstanceFields.taskId: taskId,
    TaskInstanceFields.moduleInstanceId: moduleInstanceId,
    TaskInstanceFields.status: status.numericValue,
    TaskInstanceFields.completingTime: completingTime,
  };

  factory TaskInstanceModel.fromEntity(TaskInstanceEntity entity) {
    return TaskInstanceModel(
      id: entity.id,
      taskId: entity.taskId,
      moduleInstanceId: entity.moduleInstanceId,
      status: entity.status,
      completingTime: entity.completingTime,
      task: entity.task,
    );
  }

  TaskInstanceEntity toEntity() {
    return TaskInstanceEntity(
      id: id,
      taskId: taskId,
      moduleInstanceId: moduleInstanceId,
      status: status,
      completingTime: completingTime,
      task: task,
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_instance\data\task_instance_repository_impl.dart ===
import '../../task_instance/domain/task_instance_entity.dart';
import '../../task_instance/domain/task_instance_repository.dart';
import 'task_instance_local_datasource.dart';
import 'task_instance_model.dart';

class TaskInstanceRepositoryImpl implements TaskInstanceRepository {
  final TaskInstanceLocalDataSource localDataSource;

  TaskInstanceRepositoryImpl({required this.localDataSource});

  @override
  Future<int?> insert(TaskInstanceEntity entity) async {
    final model = TaskInstanceModel.fromEntity(entity);
    return await localDataSource.create(model);
  }

  @override
  Future<TaskInstanceEntity?> getById(int id) async {
    final model = await localDataSource.getTaskInstance(id);
    return model?.toEntity();
  }

  @override
  Future<List<TaskInstanceEntity>> getAll() async {
    final models = await localDataSource.getAllTaskInstances();
    return models.map((m) => m.toEntity()).toList();
  }

  @override
  Future<int> update(TaskInstanceEntity entity) async {
    final model = TaskInstanceModel.fromEntity(entity);
    return await localDataSource.updateTaskInstance(model);
  }

  @override
  Future<int> delete(int id) async {
    return await localDataSource.deleteTaskInstance(id);
  }

  @override
  Future<List<TaskInstanceEntity>> getByModuleInstance(int moduleInstanceId) async {
    final models = await localDataSource.getTaskInstancesForModuleInstance(moduleInstanceId);
    return models.map((m) => m.toEntity()).toList();
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_instance\domain\task_instance_entity.dart ===
import '../../task/domain/task_entity.dart';
import '../../../core/constants/enums/progress_status.dart';

class TaskInstanceEntity {
  final int? id;
  final int taskId;
  final int moduleInstanceId;
  final TaskStatus status;
  final String? completingTime;
  final TaskEntity? task;

  const TaskInstanceEntity({
    this.id,
    required this.taskId,
    required this.moduleInstanceId,
    this.status = TaskStatus.pending,
    this.completingTime,
    this.task,
  });

  TaskInstanceEntity copyWith({
    int? id,
    int? taskId,
    int? moduleInstanceId,
    TaskStatus? status,
    String? completingTime,
    TaskEntity? task,
  }) {
    return TaskInstanceEntity(
      id: id ?? this.id,
      taskId: taskId ?? this.taskId,
      moduleInstanceId: moduleInstanceId ?? this.moduleInstanceId,
      status: status ?? this.status,
      completingTime: completingTime ?? this.completingTime,
      task: task ?? this.task,
    );
  }

  @override
  String toString() =>
      'TaskInstanceEntity(id: $id, taskId: $taskId, moduleInstanceId: $moduleInstanceId, status: $status, completingTime: $completingTime)';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_instance\domain\task_instance_repository.dart ===
import 'task_instance_entity.dart';

abstract class TaskInstanceRepository {
  Future<int?> insert(TaskInstanceEntity entity);
  Future<TaskInstanceEntity?> getById(int id);
  Future<List<TaskInstanceEntity>> getAll();
  Future<int> update(TaskInstanceEntity entity);
  Future<int> delete(int id);
  Future<List<TaskInstanceEntity>> getByModuleInstance(int moduleInstanceId);
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_prompt\data\task_prompt_constants.dart ===
import '../../../core/constants/database_constants.dart';
import '../../task/data/task_constants.dart';

class TaskPromptFields {
  static const promptID = 'prompt_id';
  static const taskID = TaskFields.id;
  static const filePath = 'file_path';
  static const transcription = 'transcription';

  static const values = [promptID, taskID, filePath, transcription];
}

final scriptCreateTableTaskPrompts = '''
CREATE TABLE ${Tables.taskPrompts} (
  ${TaskPromptFields.promptID} INTEGER PRIMARY KEY AUTOINCREMENT,
  ${TaskPromptFields.taskID} INTEGER UNIQUE NOT NULL,
  ${TaskPromptFields.filePath} TEXT NOT NULL,
  ${TaskPromptFields.transcription} TEXT,
  FOREIGN KEY (${TaskPromptFields.taskID}) REFERENCES ${Tables.tasks}(${TaskFields.id})
)
''';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_prompt\data\task_prompt_local_datasource.dart ===
import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import '../../../core/database_helper.dart';
import '../../../core/logger/app_logger.dart';
import '../../../core/constants/database_constants.dart';
import '../../task_prompt/data/task_prompt_constants.dart';
import '../../task_prompt/data/task_prompt_model.dart';

class TaskPromptLocalDataSource {
  static final TaskPromptLocalDataSource _instance =
  TaskPromptLocalDataSource._internal();

  factory TaskPromptLocalDataSource() => _instance;

  TaskPromptLocalDataSource._internal();

  final dbHelper = DatabaseHelper.instance;
  Future<Database> get _db async => dbHelper.database;

  Future<int?> insert(TaskPromptModel model) async {
    AppLogger.db('Inserting TaskPrompt for taskId=${model.taskID}');
    try {
      final db = await _db;
      final id = await db.insert(
        Tables.taskPrompts,
        model.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
      AppLogger.db('TaskPrompt inserted (id=$id)');
      return id;
    } catch (e, s) {
      AppLogger.error('Error inserting TaskPrompt', e, s);
      return null;
    }
  }

  Future<TaskPromptModel?> getById(int id) async {
    AppLogger.db('Fetching TaskPrompt by ID=$id');
    try {
      final db = await _db;
      final result = await db.query(
        Tables.taskPrompts,
        where: '${TaskPromptFields.promptID} = ?',
        whereArgs: [id],
      );
      return result.isNotEmpty ? TaskPromptModel.fromMap(result.first) : null;
    } catch (e, s) {
      AppLogger.error('Error fetching TaskPrompt by ID=$id', e, s);
      return null;
    }
  }

  Future<TaskPromptModel?> getByTaskId(int taskId) async {
    AppLogger.db('Fetching TaskPrompt by taskId=$taskId');
    try {
      final db = await _db;
      final result = await db.query(
        Tables.taskPrompts,
        where: '${TaskPromptFields.taskID} = ?',
        whereArgs: [taskId],
      );
      return result.isNotEmpty ? TaskPromptModel.fromMap(result.first) : null;
    } catch (e, s) {
      AppLogger.error('Error fetching TaskPrompt by taskId=$taskId', e, s);
      return null;
    }
  }

  Future<List<TaskPromptModel>> getAll() async {
    AppLogger.db('Fetching all TaskPrompts');
    try {
      final db = await _db;
      final result = await db.query(Tables.taskPrompts);
      AppLogger.db('Fetched ${result.length} TaskPrompts');
      return result.map(TaskPromptModel.fromMap).toList();
    } catch (e, s) {
      AppLogger.error('Error fetching all TaskPrompts', e, s);
      return [];
    }
  }

  Future<int> update(TaskPromptModel model) async {
    AppLogger.db('Updating TaskPrompt ID=${model.promptID}');
    try {
      final db = await _db;
      final rows = await db.update(
        Tables.taskPrompts,
        model.toMap(),
        where: '${TaskPromptFields.promptID} = ?',
        whereArgs: [model.promptID],
      );
      AppLogger.db('Updated $rows TaskPrompt(s)');
      return rows;
    } catch (e, s) {
      AppLogger.error('Error updating TaskPrompt ID=${model.promptID}', e, s);
      return 0;
    }
  }

  Future<int> delete(int id) async {
    AppLogger.db('Deleting TaskPrompt ID=$id');
    try {
      final db = await _db;
      final count = await db.delete(
        Tables.taskPrompts,
        where: '${TaskPromptFields.promptID} = ?',
        whereArgs: [id],
      );
      AppLogger.db('Deleted $count TaskPrompt(s)');
      return count;
    } catch (e, s) {
      AppLogger.error('Error deleting TaskPrompt ID=$id', e, s);
      return 0;
    }
  }

  Future<bool> exists(String promptId) async {
    final db = await _db;
    final result = await db.query(
      Tables.taskPrompts,
      where: '${TaskPromptFields.promptID} = ?',
      whereArgs: [promptId],
      limit: 1,
    );
    return result.isNotEmpty;
  }

}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_prompt\data\task_prompt_model.dart ===
import '../../task_prompt/domain/task_prompt_entity.dart';
import 'task_prompt_constants.dart';

class TaskPromptModel extends TaskPromptEntity {
  const TaskPromptModel({
    super.promptID,
    required super.taskID,
    required super.filePath,
    super.transcription,
  });

  factory TaskPromptModel.fromMap(Map<String, dynamic> map) {
    return TaskPromptModel(
      promptID: map[TaskPromptFields.promptID] as int?,
      taskID: map[TaskPromptFields.taskID] as int, //
      filePath: map[TaskPromptFields.filePath] as String,
      transcription: map[TaskPromptFields.transcription] as String?,
    );
  }

  Map<String, dynamic> toMap() => {
    TaskPromptFields.promptID: promptID,
    TaskPromptFields.taskID: taskID,
    TaskPromptFields.filePath: filePath,
    TaskPromptFields.transcription: transcription,
  };

  factory TaskPromptModel.fromEntity(TaskPromptEntity entity) =>
      TaskPromptModel(
        promptID: entity.promptID,
        taskID: entity.taskID,
        filePath: entity.filePath,
        transcription: entity.transcription,
      );

  TaskPromptEntity toEntity() => TaskPromptEntity(
    promptID: promptID,
    taskID: taskID,
    filePath: filePath,
    transcription: transcription,
  );
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_prompt\data\task_prompt_repository_impl.dart ===
import '../../task_prompt/domain/task_prompt_entity.dart';
import '../../task_prompt/domain/task_prompt_repository.dart';
import '../../task_prompt/data/task_prompt_local_datasource.dart';
import '../../task_prompt/data/task_prompt_model.dart';

class TaskPromptRepositoryImpl implements TaskPromptRepository {
  final TaskPromptLocalDataSource localDataSource;

  TaskPromptRepositoryImpl({required this.localDataSource});

  @override
  Future<int?> insert(TaskPromptEntity entity) async {
    final model = TaskPromptModel.fromEntity(entity);
    return await localDataSource.insert(model);
  }

  @override
  Future<TaskPromptEntity?> getById(int id) async {
    final model = await localDataSource.getById(id);
    return model?.toEntity();
  }

  @override
  Future<TaskPromptEntity?> getByTaskId(int taskId) async {
    final model = await localDataSource.getByTaskId(taskId);
    return model?.toEntity();
  }

  @override
  Future<List<TaskPromptEntity>> getAll() async {
    final models = await localDataSource.getAll();
    return models.map((m) => m.toEntity()).toList();
  }

  @override
  Future<int> update(TaskPromptEntity entity) async {
    final model = TaskPromptModel.fromEntity(entity);
    return await localDataSource.update(model);
  }

  @override
  Future<int> delete(int id) async {
    return await localDataSource.delete(id);
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_prompt\domain\task_prompt_entity.dart ===
class TaskPromptEntity {
  final int? promptID;
  final int taskID;
  final String filePath;
  final String? transcription;

  const TaskPromptEntity({
    this.promptID,
    required this.taskID,
    required this.filePath,
    this.transcription,
  });

  TaskPromptEntity copyWith({
    int? promptID,
    int? taskId,
    String? filePath,
    String? transcription,
  }) {
    return TaskPromptEntity(
      promptID: promptID ?? this.promptID,
      taskID: taskId ?? this.taskID,
      filePath: filePath ?? this.filePath,
      transcription: transcription ?? this.transcription,
    );
  }

  @override
  String toString() =>
      'TaskPromptEntity(id: $promptID, taskId: $taskID, filePath: $filePath, transcription: $transcription)';
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\features\task_prompt\domain\task_prompt_repository.dart ===
import 'task_prompt_entity.dart';

abstract class TaskPromptRepository {
  Future<int?> insert(TaskPromptEntity entity);
  Future<TaskPromptEntity?> getById(int id);
  Future<TaskPromptEntity?> getByTaskId(int taskId);
  Future<List<TaskPromptEntity>> getAll();
  Future<int> update(TaskPromptEntity entity);
  Future<int> delete(int id);
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\main.dart ===
import 'dart:ui';

import 'package:fluent_ui/fluent_ui.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:sqflite_common_ffi/sqflite_ffi.dart';

import 'core/router.dart';
import 'core/theme/app_theme.dart';
import 'core/logger/app_logger.dart';

Future<void> initDatabaseFactory() async {
  AppLogger.info('Initializing database factory...');
  sqfliteFfiInit();
  databaseFactory = databaseFactoryFfi;
  AppLogger.info('‚úÖ Database factory initialized using FFI');
}

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  AppLogger.info('Flutter bindings initialized');

  await initDatabaseFactory();

  FlutterError.onError = (FlutterErrorDetails details) {
    AppLogger.error('Flutter framework error', details.exception, details.stack);
  };

  PlatformDispatcher.instance.onError = (error, stack) {
    AppLogger.error('Uncaught async error', error, stack);
    return true;
  };

  AppLogger.info('üöÄ Application starting...');
  runApp(const ProviderScope(child: StartupApp()));
}

class StartupApp extends StatelessWidget {
  const StartupApp({super.key});

  @override
  Widget build(BuildContext context) {
    AppLogger.info('üèóÔ∏è Building StartupApp widget tree');
    return FluentApp.router(
      title: 'Novo Cogni',
      debugShowCheckedModeBanner: false,
      themeMode: ThemeMode.system,
      theme: AppTheme.light,
      darkTheme: AppTheme.dark,
      routerConfig: router,
    );
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\providers\auth_providers.dart ===
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../features/auth/application/login_notifier.dart';
import '../features/auth/data/auth_local_datasource.dart';
import '../features/auth/data/auth_repository_impl.dart';
import '../features/auth/domain/auth_repository.dart';
import 'database_provider.dart'; // ‚úÖ FIX

final authRepositoryProvider = FutureProvider<AuthRepository>((ref) async {
  final dbHelper = ref.watch(databaseProvider);
  final db = await dbHelper.database;
  return AuthRepositoryImpl(AuthLocalDataSource(db));
});


final loginProvider = AsyncNotifierProvider.autoDispose<LoginNotifier, bool>(
      () => LoginNotifier(),
);


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\providers\database_provider.dart ===
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../core/database_helper.dart';

final databaseProvider = Provider<DatabaseHelper>((_) => DatabaseHelper.instance);


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\providers\environment_provider.dart ===
import 'package:hooks_riverpod/hooks_riverpod.dart';
import '../core/environment.dart';


final environmentProvider = Provider<AppEnv>((ref) {
  return AppEnv.local;
});


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\providers\evaluator_providers.dart ===
import 'package:hooks_riverpod/hooks_riverpod.dart';
import '../../features/evaluator/data/evaluator_model.dart';

final currentUserProvider =
NotifierProvider<CurrentUserNotifier, EvaluatorModel?>(
  CurrentUserNotifier.new,
);

class CurrentUserNotifier extends Notifier<EvaluatorModel?> {
  @override
  EvaluatorModel? build() => null;

  void setUser(EvaluatorModel? user) => state = user;
  void clearUser() => state = null;
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\providers\participant_providers.dart ===
import 'package:hooks_riverpod/hooks_riverpod.dart';

import '../core/database/base_database_helper.dart';
import '../core/database/prod_database_helper.dart';
import '../core/logger/app_logger.dart';
import '../features/participant/presentation/create_participant_evaluation_notifier.dart';

/// DB Provider for participants (used in production)
final participantDbHelperProvider = Provider<BaseDatabaseHelper>((ref) {
  AppLogger.db('Providing ProdDatabaseHelper.instance (participant_providers)');
  return ProdDatabaseHelper.instance;
});

/// Notifier to create participant + evaluation hierarchy
final createParticipantEvaluationProvider =
AsyncNotifierProvider<CreateParticipantEvaluationNotifier, dynamic>(
      () {
    AppLogger.info(
      'Initializing CreateParticipantEvaluationNotifier via createParticipantEvaluationProvider',
    );
    return CreateParticipantEvaluationNotifier();
  },
);


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\providers\providers.dart ===
export 'auth_providers.dart';
export 'evaluator_providers.dart';
export 'participant_providers.dart';
export 'startup_provider.dart';
export 'environment_provider.dart';


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\providers\startup_provider.dart ===
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/database_helper.dart';
import '../../core/logger/app_logger.dart';
import '../../features/evaluator/data/evaluator_local_datasource.dart';

enum StartupState { ready }

final startupProvider =
FutureProvider<StartupState>((ref) async {
  AppLogger.info('[STARTUP] Checking evaluator presence...');
  final db = await DatabaseHelper.instance.database;
  final evaluatorDS = EvaluatorLocalDataSource(db);

  final evaluators = await evaluatorDS.getAll();

  if (evaluators.isEmpty) {
    AppLogger.warning(
        '[STARTUP] No evaluators found ‚Äî seeder might not have run yet');
  } else {
    AppLogger.info(
        '[STARTUP] Found ${evaluators.length} evaluator(s), proceeding to login');
  }

  return StartupState.ready;
});


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\evaluators\evaluator_seed.dart ===
import '../../core/database_helper.dart';
import '../../core/logger/app_logger.dart';
import '../../features/evaluator/data/evaluator_model.dart';
import '../../features/evaluator/data/evaluator_local_datasource.dart';
import '../../features/evaluator/domain/evaluator_entity.dart';

Future<void> seedDummyEvaluator() async {
  AppLogger.seed('[EVALUATOR] Checking for existing evaluators...');
  final db = await DatabaseHelper.instance.database;
  final datasource = EvaluatorLocalDataSource(db);

  final exists = await datasource.existsByEmail('dummy@local');
  if (exists) {
    AppLogger.seed('[EVALUATOR] Dummy evaluator already exists.');
    return;
  }


  final dummy = EvaluatorEntity(
    name: 'Dummy',
    surname: 'Evaluator',
    email: 'dummy@local',
    birthDate: '1990-01-01',
    specialty: 'Neuropsychology',
    cpfOrNif: '00000000000',
    username: 'dummy',
    password: '123456',
    firstLogin: false,
  );

  await datasource.insert(EvaluatorModel.fromEntity(dummy));
  AppLogger.seed('[EVALUATOR] ‚úÖ Dummy evaluator created successfully.');
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\modules\modules_seeds.dart ===
library module_seeds;

import 'package:sqflite_common_ffi/sqflite_ffi.dart';

import '../../core/logger/app_logger.dart';
import '../../features/module/data/module_constants.dart';
import '../../features/module/data/module_model.dart';
import '../../features/module/domain/module_entity.dart';
part 'modules_seeds_constants.dart';

Future<void> seedModules(Database db) async {
  AppLogger.seed('[MODULES] Seeding modules...');
  final modules = [
    ModuleEntity(moduleID: 1, title: 'Sociodemographic Info'),
    ModuleEntity(moduleID: 2, title: 'Cognitive Functions'),
    ModuleEntity(moduleID: 3, title: 'Functionality'),
    ModuleEntity(moduleID: 4, title: 'Depression Symptoms'),
    ModuleEntity(moduleID: 5, title: 'Tests'),
  ];

  for (final module in modules) {
    final result = await db.query(
      'modules',
      where: '${ModuleFields.id} = ?',
      whereArgs: [module.moduleID],
    );
    if (result.isEmpty) {
      await db.insert('modules', module.toModel().toMap());
      AppLogger.seed('[MODULES] Seeded module: ${module.moduleID} ‚Üí ${module.title}');
    } else {
      AppLogger.debug('[MODULES] Skipped existing module: ${module.moduleID}');
    }
  }
  AppLogger.seed('[MODULES] Done seeding modules.');
}

extension ModuleEntityMapper on ModuleEntity {
  ModuleModel toModel() => ModuleModel(
    moduleID: moduleID,
    title: title,
  );
}

=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\modules\modules_seeds_constants.dart ===
part of module_seeds;

String sociodemographicInfo = 'Dados Pessoais';
int sociodemographicInfoId = 1;

String cognitiveFunctions = 'Fun√ß√µes Cognitivas';
int cognitiveFunctionsId = 2;

String functionality = 'Funcionalidade';
int functionalityId = 3;

String depressionSymptoms = 'Sintomas de Depress√£o';
int depressionSymptomsId = 4;

String testsModuleTitle = 'Teste de √Åudio e Grava√ß√£o';
int testsModuleId = 9001;


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\prompts\prompts_seed.dart ===
library prompts_seeds;

import 'package:sqflite_common_ffi/sqflite_ffi.dart';

import '../../core/constants/database_constants.dart';
import '../../core/logger/app_logger.dart';
import '../../features/task_prompt/data/task_prompt_constants.dart';
import '../../features/task_prompt/data/task_prompt_model.dart';
import '../../features/task_prompt/domain/task_prompt_entity.dart';
import '../../core/constants/audio_file_paths.dart';
import '../tasks/task_seeds.dart';

part 'prompts_seeds_constants.dart';
part 'prompts_seeds_list.dart';

extension TaskPromptEntityMapper on TaskPromptEntity {
  TaskPromptModel toModel() {
    return TaskPromptModel(
      promptID: promptID,
      taskID: taskID,
      filePath: filePath,
      transcription: transcription,
    );
  }
}

Future<void> seedPrompts(Database db) async {
  AppLogger.seed('[PROMPTS] Seeding prompts...');

  for (final prompt in tasksPromptsList) {
    final result = await db.query(
      Tables.taskPrompts,
      where: '${TaskPromptFields.promptID} = ?',
      whereArgs: [prompt.promptID],
    );
    if (result.isEmpty) {
      await db.insert('task_prompts', prompt.toModel().toMap());
      AppLogger.seed('[PROMPTS] Seeded prompt: ${prompt.promptID} ‚Üí ${prompt.filePath}');
    } else {
      AppLogger.debug('[PROMPTS] Skipped existing prompt: ${prompt.promptID}');
    }
  }

  AppLogger.seed('[PROMPTS] Done seeding prompts.');
}

=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\prompts\prompts_seeds_constants.dart ===
part of prompts_seeds;

var helloHowAreYouTaskPromptID = 1;
var whatsYourNameTaskPromptID = 2;
var whatsYourDOBTaskPromptID = 3;
var whatsYourEducationLevelTaskPromptID = 4;
var whatWasYourProfessionTaskPromptID = 5;

var whoDoYouLiveWithTaskPromptID = 6;
var doYouExerciseFrequentlyTaskPromptID = 7;
var doYouReadFrequentlyTaskPromptID = 8;
var doYouPlayPuzzlesOrVideoGamesFrequentlyTaskPromptID = 9;
var doYouHaveAnyDiseaseTaskPromptID = 10;

var payCloseAttentionTaskPromptID = 11;
var subtracting3AndAgainTaskPromptID = 12;
var whatYearAreWeInTaskPromptID = 13;
var whatMonthAreWeInTaskPromptID = 14;
var whatDayOfTheMonthIsItTaskPromptID = 15;

var whatDayOfTheWeekIsItTaskPromptID = 16;
var howOldAreYouTaskPromptID = 17;
var whereAreWeNowTaskPromptID = 18;
var currentPresidentOfBrazilTaskPromptID = 19;
var formerPresidentOfBrazilTaskPromptID = 20;

var repeatWordsAfterListeningFirstTimeTaskPromptID = 21;
var recallWordsFromListFirstTimeTaskPromptID = 22;
var repeatWordsAfterListeningSecondTimeTaskPromptID = 23;
var recallWordsFromListSecondTimeTaskPromptID = 24;
var repeatWordsAfterListeningThirdTimeTaskPromptID = 25;

var recallWordsFromListThirdTimeTaskPromptID = 26;
var whatDidYouDoYesterdayTaskPromptID = 27;
var favoriteChildhoodGameTaskPromptID = 28;
var retellWordsHeardBeforeTaskPromptID = 29;
var payCloseAttentionToTheStoryTaskPromptID = 30;

var anasCatStoryTaskPromptID = 31;
var howManyAnimalsCanYouThinkOfTaskPromptID = 32;
var wordsStartingWithFTaskPromptID = 33;
var wordsStartingWithATaskPromptID = 34;
var wordsStartingWithSTaskPromptID = 35;

var describeWhatYouSeeTaskPromptID = 36;
var retellStoryTaskPromptID = 37;
var yesOrNoQuestionsTaskPromptID = 38;
var canYouBatheAloneTaskPromptID = 39;
var canYouDressAloneTaskPromptID = 40;

var canYouUseToiletAloneTaskPromptID = 41;
var canYouUsePhoneAloneTaskPromptID = 42;
var canYouShopAloneTaskPromptID = 43;
var canYouHandleMoneyAloneTaskPromptID = 44;
var canYouManageMedicationAloneTaskPromptID = 45;

var canYouUseTransportAloneTaskPromptID = 46;
var feelingsInPastTwoWeeksTaskPromptID = 47;
var feelingSadFrequentlyTaskPromptID = 48;
var feelingTiredOrLackingEnergyTaskPromptID = 49;
var troubleSleepingTaskPromptID = 50;

var preferringToStayHomeTaskPromptID = 51;
var feelingUselessOrGuiltyTaskPromptID = 52;
var lostInterestInActivitiesTaskPromptID = 53;
var hopefulAboutFutureTaskPromptID = 54;
var feelingLifeIsWorthLivingTaskPromptID = 55;
var thankingForParticipationTaskPromptID = 56;

// Validation
final aPressaEhInimigaTaskPromptId = 9001;
final conteAte5taskPromptID = 9004;


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\prompts\prompts_seeds_list.dart ===
part of prompts_seeds;

final helloHowAreYouPrompt = TaskPromptEntity(
  promptID: helloHowAreYouTaskPromptID,
  taskID: helloHowAreYouTask.taskID!,
  filePath: AudioFilePaths.hello_how_are_you,
  transcription: "Ol√°, tudo bem! Agora vou fazer algumas perguntas para conhecer voc√™ melhor.",
);

final whatsYourNamePrompt = TaskPromptEntity(
  promptID: whatsYourNameTaskPromptID,
  taskID: whatsYourNameTask.taskID!,
  filePath: AudioFilePaths.whats_your_name,
  transcription: "Qual o seu nome?",
);

final whatsYourDOBPrompt = TaskPromptEntity(
  promptID: whatsYourDOBTaskPromptID,
  taskID: whatsYourDOBTask.taskID!,
  filePath: AudioFilePaths.whats_your_dob,
  transcription: "Qual a sua data de nascimento?",
);

final whatsYourEducationLevelPrompt = TaskPromptEntity(
  promptID: whatsYourEducationLevelTaskPromptID,
  taskID: whatsYourEducationLevelTask.taskID!,
  filePath: AudioFilePaths.whats_your_education_level,
  transcription: "Qual a sua escolaridade? Me diga at√© quando voc√™ estudou:",
);

final whatWasYourProfessionPrompt = TaskPromptEntity(
  promptID: whatWasYourProfessionTaskPromptID,
  taskID: whatWasYourProfessionTask.taskID!,
  filePath: AudioFilePaths.what_was_your_profession,
  transcription: "Qual era a sua profiss√£o?",
);

final whoDoYouLiveWithPrompt = TaskPromptEntity(
  promptID: whoDoYouLiveWithTaskPromptID,
  taskID: whoDoYouLiveWithTask.taskID!,
  filePath: AudioFilePaths.who_do_you_live_with,
  transcription: "Com quem voc√™ mora atualmente?",
);

final doYouExerciseFrequentlyPrompt = TaskPromptEntity(
  promptID: doYouExerciseFrequentlyTaskPromptID,
  taskID: doYouExerciseFrequentlyTask.taskID!,
  filePath: AudioFilePaths.do_you_exercise_frequently,
  transcription: "Voc√™ faz alguma atividade f√≠sica com frequ√™ncia?",
);

final doYouReadFrequentlyPrompt = TaskPromptEntity(
  promptID: doYouReadFrequentlyTaskPromptID,
  taskID: doYouReadFrequentlyTask.taskID!,
  filePath: AudioFilePaths.do_you_read_frequently,
  transcription: "Voc√™ costuma ler com frequ√™ncia?",
);

final doYouPlayPuzzlesOrVideoGamesFrequentlyPrompt = TaskPromptEntity(
  promptID: doYouPlayPuzzlesOrVideoGamesFrequentlyTaskPromptID,
  taskID: doYouPlayPuzzlesOrVideoGamesFrequentlyTask.taskID!,
  filePath: AudioFilePaths.do_you_play_puzzles_or_video_games_frequently,
  transcription:
  "Voc√™ costuma jogar palavras-cruzadas, ca√ßa-palavras ou jogos eletr√¥nicos com frequ√™ncia?",
);

final doYouHaveAnyDiseasesPrompt = TaskPromptEntity(
  promptID: doYouHaveAnyDiseaseTaskPromptID,
  taskID: doYouHaveAnyDiseasesTask.taskID!,
  filePath: AudioFilePaths.do_you_have_any_diseases,
  transcription: "Algum m√©dico j√° disse que voc√™ tem alguma doen√ßa? Me diga quais s√£o essas doen√ßas:",
);

final aPressaEhInimigaTaskPrompt = TaskPromptEntity(
  promptID: aPressaEhInimigaTaskPromptId,
  taskID: pressaInimigaTask.taskID!,
  filePath: AudioFilePaths.aPressaEhInimiga,
);

final conteAteh5TaskPrompt = TaskPromptEntity(
  promptID: conteAte5taskPromptID,
  taskID: conteAte5Task.taskID!,
  filePath: AudioFilePaths.conteAte5,
);

List<TaskPromptEntity> tasksPromptsList = [
  helloHowAreYouPrompt,
  whatsYourNamePrompt,
  whatsYourDOBPrompt,
  whatsYourEducationLevelPrompt,
  whatWasYourProfessionPrompt,
  whoDoYouLiveWithPrompt,
  doYouExerciseFrequentlyPrompt,
  doYouReadFrequentlyPrompt,
  doYouPlayPuzzlesOrVideoGamesFrequentlyPrompt,
  doYouHaveAnyDiseasesPrompt,
  aPressaEhInimigaTaskPrompt,
  conteAteh5TaskPrompt,
];


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\seed_runner.dart ===
import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import '../core/logger/app_logger.dart';
import '../core/database_helper.dart';
import 'modules/modules_seeds.dart';
import 'tasks/task_seeds.dart';
import 'prompts/prompts_seed.dart';
import 'evaluators/evaluator_seed.dart';

class SeedRunner {
  /// Runs all database seeders in a controlled order.
  /// You can call this without parameters ‚Äî it will automatically open the DB.
  Future<void> run({Database? db}) async {
    AppLogger.seed('Starting database seeding...');
    final database = db ?? await DatabaseHelper.instance.database;

    try {
      await seedModules(database);
      await seedTasks(database);
      await seedPrompts(database);
      await seedDummyEvaluator();

      AppLogger.seed('‚úÖ Database seeding complete.');
    } catch (e, s) {
      AppLogger.error('‚ùå Database seeding failed', e, s);
      rethrow;
    }
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\tasks\task_seeds.dart ===
library task_seeds;

import 'package:sqflite_common_ffi/sqflite_ffi.dart';

import '../../core/constants/database_constants.dart';
import '../../core/logger/app_logger.dart';
import '../../core/constants/enums/task_mode.dart';
import '../../features/task/data/task_constants.dart';
import '../../features/task/data/task_model.dart';
import '../../features/task/domain/task_entity.dart';
import '../modules/modules_seeds.dart';

part 'task_seeds_constants.dart';
part 'task_seeds_list.dart';

Future<void> seedTasks(Database db) async {
  AppLogger.seed('[TASKS] Seeding tasks...');

  for (final task in tasksList) {
    final result = await db.query(
      Tables.tasks,
      where: '${TaskFields.id} = ?',
      whereArgs: [task.taskID],
    );

    if (result.isEmpty) {
      await db.insert(Tables.tasks, task.toModel().toMap());
      AppLogger.seed(
        '[TASKS] Seeded task: ${task.title} (module ${task.moduleID})',
      );
    } else {
      AppLogger.debug('[TASKS] Skipped existing task: ${task.title}');
    }
  }

  AppLogger.seed('[TASKS] Done seeding tasks.');
}

extension TaskEntityMapper on TaskEntity {
  TaskModel toModel() {
    return TaskModel(
      taskID: taskID,
      moduleID: moduleID,
      title: title,
      transcript: transcript,
      taskMode: taskMode,
      position: position,
      imagePath: imagePath,
      timeForCompletion: timeForCompletion,
      mayRepeatPrompt: mayRepeatPrompt,
      testOnly: testOnly,
    );
  }
}

=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\tasks\task_seeds_constants.dart ===
part of task_seeds;

// Sociodemographic Info Module
int helloHowAreYouTaskId = 1;
String helloHowAreYouTaskTitle = "Seja bem-vindo";
String helloHowAreYouTaskSnakeCaseTranscript = "hello_how_are_you";

int whatsYourNameTaskId = 2;
String whatsYourNameTaskTitle = "Dados Pessoais - Nome";
String whatsYourNameTaskSnakeCaseTranscript = "whats_your_name";

int whatsYourDOBTaskId = 3;
String whatsYourDOBTaskTitle = "Dados Pessoais - Nascimento";
String whatsYourDOBTaskSnakeCaseTranscript = "whats_your_dob";

int whatsYourEducationLevelTaskId = 4;
String whatsYourEducationLevelTaskTitle = "Escolaridade";
String whatsYourEducationLevelTaskSnakeCaseTranscript = "whats_your_education_level";

int whatWasYourProfessionTaskId = 5;
String whatWasYourProfessionTaskTitle = "Profiss√£o";
String whatWasYourProfessionTaskSnakeCaseTranscript = "what_was_your_profession";

int whoDoYouLiveWithTaskId = 6;
String whoDoYouLiveWithTaskTitle = "Com quem mora";
String whoDoYouLiveWithTaskSnakeCaseTranscript = "who_do_you_live_with";

int doYouExerciseFrequentlyTaskId = 7;
String doYouExerciseFrequentlyTaskTitle = "Exerc√≠cios f√≠sicos";
String doYouExerciseFrequentlyTaskSnakeCaseTranscript = "do_you_exercise_frequently";

int doYouReadFrequentlyTaskId = 8;
String doYouReadFrequentlyTaskTitle = "Leitura";
String doYouReadFrequentlyTaskSnakeCaseTranscript = "do_you_read_frequently";

int doYouPlayPuzzlesOrVideoGamesFrequentlyTaskId = 9;
String doYouPlayPuzzlesOrVideoGamesFrequentlyTaskTitle = "Jogos & passatempos";
String doYouPlayPuzzlesOrVideoGamesFrequentlyTaskSnakeCaseTranscript = "do_you_play_puzzles_or_video_games_frequently";

int doYouHaveAnyDiseasesTaskId = 10;
String doYouHaveAnyDiseasesTaskTitle = "Doen√ßas diagnosticadas";
String doYouHaveAnyDiseasesTaskSnakeCaseTranscript = "do_you_have_any_diseases";

// Validation
int pressaInimigaTaskId = 9001;
String pressaInimigaTaskTitle = "A pressa √© inimiga da perfei√ß√£o";
String pressaInimigaTaskSnakeCaseTranscript = "a_pressa_eh_inimiga";

int conteAte5TaskId = 9002;
String conteAte5TaskTitle = "Conte at√© 5";
String conteAte5TaskSnakeCaseTranscript = "conte_ate_5";


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\lib\seeders\tasks\task_seeds_list.dart ===
part of task_seeds;

// === Sociodemographic Module Tasks ===


TaskEntity helloHowAreYouTask = TaskEntity(
  taskID: helloHowAreYouTaskId,
  title: helloHowAreYouTaskTitle,
  transcript: helloHowAreYouTaskSnakeCaseTranscript,
  moduleID: sociodemographicInfoId,
  taskMode: TaskMode.play,
  timeForCompletion: 60,
  mayRepeatPrompt: true,
  position: 1,
);

TaskEntity whatsYourNameTask = TaskEntity(
  taskID: whatsYourNameTaskId,
  title: whatsYourNameTaskTitle,
  transcript: whatsYourNameTaskSnakeCaseTranscript,
  moduleID: sociodemographicInfoId,
  taskMode: TaskMode.record,
  timeForCompletion: 60,
  mayRepeatPrompt: true,
  position: 2,
);

TaskEntity whatsYourDOBTask = TaskEntity(
  taskID: whatsYourDOBTaskId,
  title: whatsYourDOBTaskTitle,
  transcript: whatsYourDOBTaskSnakeCaseTranscript,
  moduleID: sociodemographicInfoId,
  taskMode: TaskMode.record,
  timeForCompletion: 60,
  mayRepeatPrompt: true,
  position: 3,
);

TaskEntity whatsYourEducationLevelTask = TaskEntity(
  taskID: whatsYourEducationLevelTaskId,
  title: whatsYourEducationLevelTaskTitle,
  transcript: whatsYourEducationLevelTaskSnakeCaseTranscript,
  moduleID: sociodemographicInfoId,
  taskMode: TaskMode.record,
  timeForCompletion: 60,
  mayRepeatPrompt: true,
  position: 4,
);

TaskEntity whatWasYourProfessionTask = TaskEntity(
  taskID: whatWasYourProfessionTaskId,
  title: whatWasYourProfessionTaskTitle,
  transcript: whatWasYourProfessionTaskSnakeCaseTranscript,
  moduleID: sociodemographicInfoId,
  taskMode: TaskMode.record,
  timeForCompletion: 60,
  mayRepeatPrompt: true,
  position: 5,
);

TaskEntity whoDoYouLiveWithTask = TaskEntity(
  taskID: whoDoYouLiveWithTaskId,
  title: whoDoYouLiveWithTaskTitle,
  transcript: whoDoYouLiveWithTaskSnakeCaseTranscript,
  moduleID: sociodemographicInfoId,
  taskMode: TaskMode.record,
  timeForCompletion: 60,
  mayRepeatPrompt: true,
  position: 6,
);

TaskEntity doYouExerciseFrequentlyTask = TaskEntity(
  taskID: doYouExerciseFrequentlyTaskId,
  title: doYouExerciseFrequentlyTaskTitle,
  transcript: doYouExerciseFrequentlyTaskSnakeCaseTranscript,
  moduleID: sociodemographicInfoId,
  taskMode: TaskMode.record,
  timeForCompletion: 60,
  mayRepeatPrompt: true,
  position: 7,
);

TaskEntity doYouReadFrequentlyTask = TaskEntity(
  taskID: doYouReadFrequentlyTaskId,
  title: doYouReadFrequentlyTaskTitle,
  transcript: doYouReadFrequentlyTaskSnakeCaseTranscript,
  moduleID: sociodemographicInfoId,
  taskMode: TaskMode.record,
  timeForCompletion: 60,
  mayRepeatPrompt: true,
  position: 8,
);

TaskEntity doYouPlayPuzzlesOrVideoGamesFrequentlyTask = TaskEntity(
  taskID: doYouPlayPuzzlesOrVideoGamesFrequentlyTaskId,
  title: doYouPlayPuzzlesOrVideoGamesFrequentlyTaskTitle,
  transcript: doYouPlayPuzzlesOrVideoGamesFrequentlyTaskSnakeCaseTranscript,
  moduleID: sociodemographicInfoId,
  taskMode: TaskMode.record,
  timeForCompletion: 60,
  mayRepeatPrompt: true,
  position: 9,
);

TaskEntity doYouHaveAnyDiseasesTask = TaskEntity(
  taskID: doYouHaveAnyDiseasesTaskId,
  title: doYouHaveAnyDiseasesTaskTitle,
  transcript: doYouHaveAnyDiseasesTaskSnakeCaseTranscript,
  moduleID: sociodemographicInfoId,
  taskMode: TaskMode.record,
  timeForCompletion: 60,
  mayRepeatPrompt: true,
  position: 10,
);

// === Validation Tasks ===

TaskEntity pressaInimigaTask = TaskEntity(
  taskID: pressaInimigaTaskId,
  title: pressaInimigaTaskTitle,
  transcript: pressaInimigaTaskSnakeCaseTranscript,
  moduleID: testsModuleId,
  taskMode: TaskMode.play,
  timeForCompletion: 60,
  mayRepeatPrompt: true,
  position: 1,
);

TaskEntity conteAte5Task = TaskEntity(
  taskID: conteAte5TaskId,
  title: conteAte5TaskTitle,
  transcript: conteAte5TaskSnakeCaseTranscript,
  moduleID: testsModuleId,
  taskMode: TaskMode.record,
  timeForCompletion: 60,
  mayRepeatPrompt: true,
  position: 2,
);

List<TaskEntity> tasksList = [
  helloHowAreYouTask,
  whatsYourNameTask,
  whatsYourDOBTask,
  whatsYourEducationLevelTask,
  whatWasYourProfessionTask,
  whoDoYouLiveWithTask,
  doYouExerciseFrequentlyTask,
  doYouReadFrequentlyTask,
  doYouPlayPuzzlesOrVideoGamesFrequentlyTask,
  doYouHaveAnyDiseasesTask,
  pressaInimigaTask,
  conteAte5Task,
];


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\core\database\test_database_helper_test.dart ===
import 'package:flutter_test/flutter_test.dart';
import 'package:segundo_cogni/core/database/test_database_helper.dart';
import 'package:segundo_cogni/core/database/database_schema.dart';

void main() {
  late TestDatabaseHelper dbHelper;

  setUp(() async {
    dbHelper = TestDatabaseHelper.instance;
    await dbHelper.initDb(); // ‚úÖ Ensures schema creation
  });

  tearDown(() async {
    await dbHelper.close(); // ‚úÖ Ensures clean reset between tests
  });

  test('creates all expected tables', () async {
    final db = await dbHelper.database;

    final result = await db.rawQuery(
      "SELECT name FROM sqlite_master WHERE type='table';",
    );
    final names = result.map((e) => e['name'] as String).toSet();

    for (final table in [
      'evaluators',
      'participants',
      'evaluations',
      'modules',
      'tasks',
      'task_prompts',
      'module_instances',
      'task_instances',
      'recordings',
    ]) {
      expect(names.contains(table), true, reason: 'Missing table: $table');
    }
  }, timeout: Timeout(Duration(seconds: 5))); // ‚úÖ Prevents hanging

  test('dropAll removes tables', () async {
    final db = await dbHelper.database;

    await DatabaseSchema.dropAll(db);
    final result = await db.rawQuery(
      "SELECT name FROM sqlite_master WHERE type='table';",
    );
    final names = result.map((e) => e['name'] as String).toSet();

    for (final table in ['evaluators', 'participants', 'evaluations']) {
      expect(names.contains(table), false);
    }
  }, timeout: Timeout(Duration(seconds: 5))); // ‚úÖ Prevents hanging
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\core\utils\validation_helper_test.dart ===
import 'package:flutter_test/flutter_test.dart';
import 'package:segundo_cogni/core/utils/validation_helper.dart';

void main() {
  test('valid email format passes', () {
    expect(ValidationHelper.isValidEmail('a@b.com'), true);
  });

  test('invalid email format fails', () {
    expect(ValidationHelper.isValidEmail('not-email'), false);
    expect(ValidationHelper.isValidEmail('a@b'), false);
    expect(ValidationHelper.isValidEmail('@b.com'), false);
  });

  test('password at least 8 chars', () {
    expect(ValidationHelper.isValidPassword('12345678'), true);
    expect(ValidationHelper.isValidPassword('abc12345'), true);
    expect(ValidationHelper.isValidPassword('abc12'), false);
    expect(ValidationHelper.isValidPassword(''), false);
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\features\auth\auth_repository_test.dart ===
import 'package:flutter_test/flutter_test.dart';
import 'package:segundo_cogni/core/database/test_database_helper.dart';
import 'package:segundo_cogni/features/auth/data/auth_local_datasource.dart';
import 'package:segundo_cogni/features/auth/data/auth_repository_impl.dart';
import 'package:segundo_cogni/features/evaluator/data/evaluator_model.dart';
import 'package:segundo_cogni/features/evaluator/data/evaluator_model_extensions.dart';
import 'package:segundo_cogni/features/evaluator/application/evaluator_secure_service.dart';

void main() {
  late TestDatabaseHelper dbHelper;
  late AuthLocalDataSource authDataSource;
  late AuthRepositoryImpl authRepository;

  final dummyUser = EvaluatorModel(
    evaluatorId: null,
    name: 'Edu',
    surname: 'Fapro',
    email: 'edu@gmail.com',
    birthDate: '1990-01-01',
    cpfOrNif: '12345678900',
    username: 'edufapro',
    password: 'password123',
    specialty: 'Neuro',
  );

  Future<void> seedUser() async {
    await authDataSource.saveCurrentUser(dummyUser);
  }

  setUp(() async {
    await TestDatabaseHelper.delete();
    dbHelper = TestDatabaseHelper.instance;
    final db = await dbHelper.database;
    authDataSource = AuthLocalDataSource(db);
    authRepository = AuthRepositoryImpl(authDataSource);
  });

  tearDown(() async {
    await dbHelper.close();
  });

  test('üö™ Logout clears current user from DB', () async {
    await seedUser();
    expect(await authDataSource.getCachedUser(), isNotNull);

    await authRepository.signOut();
    expect(await authDataSource.getCachedUser(), isNull);
  });

  test('üß† Evaluator is encrypted before storage', () {
    final encrypted = dummyUser.encryptedAndHashed();

    expect(encrypted.name, isNot(dummyUser.name));
    expect(encrypted.email, isNot(dummyUser.email));
    expect(encrypted.password.length, 64); // SHA-256
  });

  test('üõ°Ô∏è Raw DB data is encrypted', () async {
    await seedUser();

    final raw = await dbHelper.database.then((db) => db.query('current_user'));
    expect(raw.first['email'], isNot(dummyUser.email));
    expect(raw.first['name'], isNot(dummyUser.name));
  });

  test('‚ùå fetchCurrentUserOrNull returns null when DB is empty', () async {
    final user = await authRepository.fetchCurrentUserOrNull();
    expect(user, isNull);
  });

  test('üöÄ Auto-login returns correct decrypted user from DB', () async {
    await seedUser();
    final user = await authRepository.fetchCurrentUserOrNull();

    expect(user, isNotNull);
    expect(user!.email, dummyUser.email);
    expect(user.name, dummyUser.name);
    expect(user.username, dummyUser.username);
  });



}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\features\auth\login_notifier_test.dart ===
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:segundo_cogni/providers/auth_providers.dart';

import '../../mocks/fake_auth_repository.dart';

void main() {
  late ProviderContainer container;

  setUp(() {
    container = ProviderContainer(overrides: [
      authRepositoryProvider.overrideWith((ref) => FakeAuthRepository()),
    ]);
  });

  tearDown(() => container.dispose());

  test('login succeeds with correct credentials', () async {
    final notifier = container.read(loginProvider.notifier);
    await notifier.login('john@example.com', 'correctPassword');

    final state = container.read(loginProvider);
    expect(state, isA<AsyncData<bool>>());
    expect((state as AsyncData).value, true);
  });

  test('login fails with wrong password', () async {
    final notifier = container.read(loginProvider.notifier);
    await notifier.login('john@example.com', 'wrongPassword');

    final state = container.read(loginProvider);
    expect(state.hasError, true);
  });

  test('auto-login loads from current_user table', () async {
    final notifier = container.read(loginProvider.notifier);
    final result = await notifier.build();
    expect(result, false); // assuming no user is saved in the fake initially
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\features\evaluator\evaluator_local_datasource_test.dart ===
import 'package:flutter_test/flutter_test.dart';
import 'package:segundo_cogni/core/database/test_database_helper.dart';
import 'package:segundo_cogni/features/evaluator/application/evaluator_secure_service.dart';
import 'package:segundo_cogni/features/evaluator/data/evaluator_local_datasource.dart';
import 'package:segundo_cogni/features/evaluator/data/evaluator_model.dart';
import 'package:segundo_cogni/features/evaluator/data/evaluator_model_extensions.dart';
import 'package:segundo_cogni/core/utils/encryption_helper.dart';

void main() {
  late TestDatabaseHelper dbHelper;
  late EvaluatorLocalDataSource ds;

  setUp(() async {
    await TestDatabaseHelper.delete(); // ‚úÖ clean start
    dbHelper = TestDatabaseHelper.instance;
    await dbHelper.database;
    ds = EvaluatorLocalDataSource(await dbHelper.database);
  });


  tearDown(() async {
    await dbHelper.close();
  });

  test('‚úÖ Create evaluator and verify encrypted storage', () async {
    final evaluator = EvaluatorModel(
      evaluatorId: null,
      name: 'John',
      surname: 'Doe',
      email: 'john.doe@example.com',
      birthDate: '1990-01-01',
      cpfOrNif: '12345678900',
      username: 'johndoe',
      password: 'securePass123',
      specialty: 'Neurologist',
    ).encryptedAndHashed();

    await ds.insert(evaluator);
    final fetched = await ds.getFirstEvaluator();

    expect(fetched, isNotNull);

    // Decrypt to validate correctness
    expect(EncryptionHelper.decryptText(fetched!.email), equals('john.doe@example.com'));
    expect(fetched.password.length, 64); // SHA256 hash
  });

  test('‚úÖ Insert and fetch evaluator works with encryption', () async {
    final evaluator = EvaluatorModel(
      evaluatorId: null,
      name: 'Jane',
      surname: 'Doe',
      email: 'jane@example.com',
      birthDate: '1990-01-01',
      cpfOrNif: '12312312312',
      username: 'janedoe',
      password: 'superSecret!',
      specialty: 'Psychologist',
    ).encryptedAndHashed();

    await ds.insert(evaluator);

    final fetched = await ds.getFirstEvaluator();

    expect(fetched, isNotNull);
    expect(EncryptionHelper.decryptText(fetched!.email), equals('jane@example.com'));
  });


  test('‚úÖ Create evaluator and verify encrypted storage + decrypted values', () async {
    const email = 'john.doe@example.com';
    const name = 'John';
    const surname = 'Doe';

    final evaluator = EvaluatorModel(
      evaluatorId: null,
      name: name,
      surname: surname,
      email: email,
      birthDate: '1990-01-01',
      cpfOrNif: '12345678900',
      username: 'johndoe',
      password: 'securePass123',
      specialty: 'Neurologist',
    ).encryptedAndHashed();

    await ds.insert(evaluator);
    final fetched = await ds.getFirstEvaluator();

    expect(fetched, isNotNull);

    // ‚úÖ Validate decrypted fields match user input
    expect(EncryptionHelper.decryptText(fetched!.name), equals(name));
    expect(EncryptionHelper.decryptText(fetched.surname), equals(surname));
    expect(EncryptionHelper.decryptText(fetched.email), equals(email));
  });


  test('üîí Login fails with wrong password', () async {
    const username = 'userfail';
    const correctPassword = 'rightPassword123';
    const wrongPassword = 'wrongPassword456';

    final evaluator = EvaluatorModel(
      evaluatorId: null,
      name: 'Fail',
      surname: 'Tester',
      email: 'fail@test.com',
      birthDate: '1995-01-01',
      cpfOrNif: '99988877766',
      username: username,
      password: correctPassword,
      specialty: 'Psychiatrist',
    ).encryptedAndHashed();

    await ds.insert(evaluator);

    final loggedIn = await ds.login(username, wrongPassword);
    expect(loggedIn, isNull); // ‚úÖ Should not log in
  });

  test('üîí Login fails with wrong username', () async {
    const correctUsername = 'realuser';
    const wrongUsername = 'wronguser';
    const password = 'correctPassword';

    final evaluator = EvaluatorModel(
      evaluatorId: null,
      name: 'Real',
      surname: 'User',
      email: 'real@user.com',
      birthDate: '1993-05-10',
      cpfOrNif: '12312312312',
      username: correctUsername,
      password: password,
      specialty: 'Neurologist',
    ).encryptedAndHashed();

    await ds.insert(evaluator);

    final loggedIn = await ds.login(wrongUsername, password);
    expect(loggedIn, isNull); // ‚úÖ Should not log in
  });

  test('‚ùå Login fails with wrong password', () async {
    final evaluator = EvaluatorSecureService.encrypt(
      EvaluatorModel(
        evaluatorId: null,
        name: 'Jane',
        surname: 'Smith',
        email: 'jane.smith@example.com',
        birthDate: '1985-12-05',
        cpfOrNif: '11122233344',
        username: 'janesmith',
        password: 'securePass123',
        specialty: 'Psychologist',
      ),
    );

    await ds.insert(evaluator);

    final result = await ds.login('janesmith', 'wrongpass');
    expect(result, isNull);
  });

  test('‚ùå Login fails with wrong username', () async {
    final evaluator = EvaluatorSecureService.encrypt(
      EvaluatorModel(
        evaluatorId: null,
        name: 'Jane',
        surname: 'Smith',
        email: 'jane.smith@example.com',
        birthDate: '1985-12-05',
        cpfOrNif: '11122233344',
        username: 'janesmith',
        password: 'securePass123',
        specialty: 'Psychologist',
      ),
    );

    await ds.insert(evaluator);

    final result = await ds.login('notjanesmith', 'securePass123');
    expect(result, isNull);
  });

}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\features\participant\participant_local_datasource_test.dart ===
import 'package:flutter_test/flutter_test.dart';
import 'package:segundo_cogni/core/constants/enums/laterality_enums.dart';
import 'package:segundo_cogni/core/logger/app_logger.dart';
import 'package:segundo_cogni/features/participant/data/participant_constants.dart';
import 'package:segundo_cogni/features/participant/data/participant_local_datasource.dart';
import 'package:segundo_cogni/core/database/test_database_helper.dart';

void main() {
  late ParticipantLocalDataSource dataSource;

  setUp(() async {
    final dbHelper = TestDatabaseHelper.instance;
    await dbHelper.initDb();
    dataSource = ParticipantLocalDataSource(dbHelper: dbHelper);
  });

  test('insert and retrieve participant', () async {
    final db = await TestDatabaseHelper.instance.database;

    final id = await dataSource.insertParticipant(db, {
      ParticipantFields.name: 'Test User',
      ParticipantFields.surname: 'User',
      ParticipantFields.birthDate: '2000-01-01',       // must match schema
      ParticipantFields.sex: 1,                         // assuming numeric enum value
      ParticipantFields.educationLevel: 3,            // assuming numeric enum value
      ParticipantFields.laterality: Laterality.ambidextrous,
    });


    AppLogger.info('Test inserted participant with id=$id');
    expect(id, isNotNull);

    final participant = await dataSource.getById(id!);
    expect(participant?.name, equals('Test User'));
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\features\recording_file\recording_file_local_datasource_test.dart ===
import 'package:flutter_test/flutter_test.dart';
import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import 'package:segundo_cogni/core/database/test_database_helper.dart';
import 'package:segundo_cogni/features/recording_file/data/recording_file_local_datasource.dart';
import 'package:segundo_cogni/features/recording_file/data/recording_file_model.dart';

void main() {
  // ‚úÖ Initialize FFI before tests
  sqfliteFfiInit();
  databaseFactory = databaseFactoryFfi;

  late TestDatabaseHelper dbHelper;
  late RecordingFileLocalDataSource ds;

  setUp(() async {
    dbHelper = TestDatabaseHelper.instance;
    await dbHelper.deleteDb();
    await dbHelper.initDb();
    ds = RecordingFileLocalDataSource(dbHelper: dbHelper);
  });

  tearDown(() async {
    await dbHelper.close();
  });

  test('insert and getById', () async {
    final model = RecordingFileModel(
      id: null,
      taskInstanceId: 1,
      filePath: 'test_audio.wav',
    );

    final id = await ds.insert(model);
    expect(id, isNotNull);

    final fetched = await ds.getById(id!);
    expect(fetched, isNotNull);
    expect(fetched!.filePath, equals(model.filePath));
    expect(fetched.taskInstanceId, equals(model.taskInstanceId));
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\features\task\task_local_datasource_test.dart ===
// test/features/task/task_local_datasource_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:segundo_cogni/core/constants/enums/task_mode.dart';
import 'package:segundo_cogni/core/database/test_database_helper.dart';
import 'package:segundo_cogni/features/task/data/task_local_datasource.dart';
import 'package:segundo_cogni/features/task/data/task_model.dart';

void main() {
  late TestDatabaseHelper dbHelper;
  late TaskLocalDataSource ds;

  setUp(() async {
    dbHelper = TestDatabaseHelper.instance;
    ds = TaskLocalDataSource(dbHelper: dbHelper);
    await dbHelper.database;
  });

  tearDown(() async {
    await dbHelper.close();
  });

  test('insertTask and getTaskById', () async {
    final task = TaskModel(
      taskID: null,
      moduleID: 1,
      title: 'Task A',
      transcript: 'Desc',
      position: 1,
      taskMode: TaskMode.play,
    );

    final id = await ds.insertTask(task);
    expect(id, isNotNull);

    final fetched = await ds.getTaskById(id!);
    expect(fetched, isNotNull);
    expect(fetched!.title, 'Task A');
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\features\task_prompt\task_prompt_local_datasource_test.dart ===
import 'package:flutter_test/flutter_test.dart';
import 'package:segundo_cogni/core/database/test_database_helper.dart';
import 'package:segundo_cogni/features/task_prompt/data/task_prompt_local_datasource.dart';
import 'package:segundo_cogni/features/task_prompt/data/task_prompt_model.dart';

void main() {
  late TestDatabaseHelper dbHelper;
  late TaskPromptLocalDataSource ds;

  setUp(() async {
    dbHelper = TestDatabaseHelper.instance;
    ds = TaskPromptLocalDataSource();
    await dbHelper.database;
  });

  tearDown(() async {
    await dbHelper.close();
  });

  test('insert and getByTaskId', () async {
    final model = TaskPromptModel(
      promptID: null,
      taskID: 1,
      transcription: 'Say your name', filePath: '',
      // other fields if required
    );

    final id = await ds.insert(model);
    expect(id, isNotNull);

    final fetched = await ds.getByTaskId(1);
    expect(fetched, isNotNull);
    expect(fetched!.transcription, 'Say your name');
  });
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\mocks\fake_auth_repository.dart ===
import 'package:segundo_cogni/features/auth/domain/auth_repository.dart';
import 'package:segundo_cogni/features/evaluator/data/evaluator_model.dart';

class FakeAuthRepository implements AuthRepository {
  EvaluatorModel? _cachedUser;

  @override
  Future<EvaluatorModel?> login(String email, String password) async {
    if (email == 'john@example.com' && password == 'correctPassword') {
      final user = EvaluatorModel(
        name: 'John',
        surname: 'Doe',
        email: email,
        birthDate: '1990-01-01',
        specialty: 'Psychology',
        cpfOrNif: '12345678900',
        username: 'johndoe',
        password: 'hashed_password',
      );
      _cachedUser = user;
      return user;
    }
    return null;
  }

  @override
  Future<void> saveCurrentUserToDB(EvaluatorModel user) async {
    _cachedUser = user;
  }

  @override
  Future<EvaluatorModel?> getCachedUser() async => _cachedUser;

  @override
  Future<void> clearCurrentUser() async {
    _cachedUser = null;
  }

  @override
  Future<void> clearCurrentUserFromDB() async {
    _cachedUser = null;
  }

  @override
  Future<void> cacheUser(EvaluatorModel user) async {
    _cachedUser = user;
  }

  @override
  Future<void> clearCachedUser() async {
    _cachedUser = null;
  }

  @override
  Future<EvaluatorModel?> fetchCurrentUserOrNull() async => _cachedUser;

  @override
  Future<void> signOut() async {
    _cachedUser = null;
  }
}


=== FILE: C:\DevProjects\StudioProjects\segundo_cogni\test\widget_test.dart ===
import 'package:flutter_test/flutter_test.dart';

void main() {
  testWidgets('dummy widget test', (tester) async {
    expect(1, 1);
  });
}


